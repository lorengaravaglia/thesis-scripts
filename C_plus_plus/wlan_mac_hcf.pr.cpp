/* Process model C++ form file: wlan_mac_hcf.pr.cpp */
/* Portions of this file copyright 1986-2008 by OPNET Technologies, Inc. */



/* This variable carries the header into the object file */
const char wlan_mac_hcf_pr_cpp [] = "MIL_3_Tfile_Hdr_ 145A 30A modeler 7 56EE0A92 56EE0A92 1 Loren Loren 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 1e80 8                                                                                                                                                                                                                                                                                                                                                                                                              ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/** Include files **/

#include <math.h>
#include <string.h>

//Loren OpenCV includes
#include "opencv2\core\core.hpp"
#include "opencv2\contrib\contrib.hpp"
#include "opencv2\highgui\highgui.hpp"
#include "opencv2\imgproc\imgproc.hpp"
#include "opencv2\objdetect\objdetect.hpp"

#include "oms_pr.h"
#include "oms_tan.h"
#include "oms_bgutil.h"
#include "wlan_support.h"
#include "oms_auto_addr_support.h"
#include "oms_dist_support.h"
#include "bridge_header.h"	
#include "prg_mapping.h"
#include "ip_dgram_sup.h"
#include "oms_dim_stat_support.h"
#include "oms_protocol.h"
#include "jammers.h"
#include <prg_geo.h>
#include <prg_bin_hash.h>
//#include "engine.h" matlab
#include <Windows.h>
#include <stdio.h>
#include <conio.h>
#include <tchar.h>

//#include "cv.h"
//#include "highgui.h"
#include "myffmpegheader.h"
#include "myRTPJPEGheader.h"

#include <vector>
#include <fstream>
#include <sstream>
#include <iostream>

//////////// end of my header code

using namespace std;
/** Constants **/

#define BUFFERSIZE 1000 //matlab output buffer size

/* Incoming statistics and stream wires.							*/
#define 	TRANSMITTER_BUSY_INSTAT		1
//did not work//#define 	TRANSMITTER_TROUGHPUT_INSTAT		4
//did not work//#define 	TRANSMITTER_UTILIZATION_INSTAT		5
//#define 	APPL_PACKETSIZE_INSTAT		3
#define 	APPL_FRAMERATE_INSTAT		2
//#define 	APPL_APPRATEINBITS_INSTAT		6

#define		LOW_LAYER_INPUT_STREAM		0
#define		LOW_LAYER_OUTPUT_STREAM		0

/* Special value indicating that the number of back-off slots are	*/
/* not determined yet.												*/
#define		BACKOFF_SLOTS_UNSET			-1

/* Special value for nav_reset_time when NAV is not set based on a	*/
/* received RTS.													*/
#define		NAV_RESET_TIME_UNSET		-1.0

/* Define a small value (= 1 psec), which will be used to recover	*/
/* from double arithmetic precision losts while doing time related	*/
/* precision sensitive computations.								*/
#define		PRECISION_RECOVERY			0.000000000001

/* Special attribute values indicating that the attribute value is	*/
/* set to the default value specified in the standard for the		*/
/* corresponding parameter.											*/
#define		STANDARD_DEFAULT			-1
#define		STANDARD_DEFAULT_QAP		-2

/* Define the range for valid user priority (UP) values.			*/
#define		MIN_UP_VALUE				0
#define		MAX_UP_VALUE				7

/* Retry counts and timeout values used during ADDBA exchange while	*/
/* establishing BA agreements.										*/
#define		ADDBA_FAILURE_TIMEOUT		1.0		/* sec */
#define		ADDBA_FAILURE_RETRY_LIMIT	2

/* Standard specified special BA inactivity timeout value			*/
/* indicating no timeout.											*/
#define		NO_BA_INACTIVITY_TIMEOUT	0.0

/* Special value used for fragment count of an MSDU until the tail	*/
/* fragment is received and its fragment number is recorded.		*/
#define		FRAG_NUM_UNKNOWN			0

/* Adjustment of block-ACK block size when delayed-BA policy is in	*/
/* use. This makes the initiator send a BAR message before the		*/
/* number of the MPDUs in the block reach to the maximum block size.*/
#define		DELAYED_BA_BK_SIZE_ADJ		4

/* Maximum waiting time for a delayed Block-ACK after the arrival	*/
/* of BAR's ACK before we assume that delayed BA won't come and we	*/
/* can queue another BAR if needed. This constant will be used only	*/
/* inactivity timer of the BA agreement is disabled by user			*/
/* configuration.													*/
#define		MAX_DELAYED_BA_WAIT_TIME	5.0		/* sec */

/** Enumerated Types **/

/* Define interrupt codes for generating handling interrupts					*/
/* indicating changes in deference, frame timeout which infers         			*/
/* that the collision has occurred, random backoff and transmission 			*/
/* completion by the physical layer.											*/
typedef enum WlanT_Mac_Intrpt_Code
	{	
	WlanC_End_Of_SIFS,		/* SIFS completed before response frame tx.			*/
	WlanC_Backoff_Elapsed,  /* Backoff done before frame transmission			*/
	WlanC_CW_Elapsed,		/* Backoff done after successful frame transmission	*/	
	WlanC_Frame_Timeout,	/* Expected frame response not received				*/
	WlanC_End_Of_NAV,		/* Medium is idle w.r.t. virtual carrier sensing.	*/
	WlanC_NAV_Reset_Time,	/* Time to reset NAV that is updated by an RTS		*/
	WlanC_Beacon_Tx_Time,	/* Time to transmit beacon frame                    */
	
	
	WlanC_StateReport_Tx_Time,	/*(Mohammad) Time to transmit statReport frame*/
	WlanC_OperationalSpeed_Change,
	WlanC_matlabOptimization,
	
	REINIT,
	
	
	WlanC_AP_Check_Timeout,	/* Time to check the connectivity status with the	*/
							/* current AP.										*/
	WlanC_Scan_Timeout,		/* End of scan duration for given channel 			*/
	WlanC_BA_Inactive_Tout_Init,/* BA inactivity timer expired with a peer/TID,	*/
	WlanC_BA_Inactive_Tout_Rcpt,/* where this MAC is originator/recipient.		*/
	WlanC_ADDBA_Failure_Timeout /* Expected ADDBA response is not received.		*/
	} WlanT_Mac_Intrpt_Code;

/* HCF EDCA access categories specified in the IEEE 802.11e standard.			*/ 
typedef enum WlanT_HCF_Access_Category
	{
	WlanC_AC_BK = 0,
	WlanC_AC_BE,
	WlanC_AC_VI,
	WlanC_AC_VO,
	WlanC_AC_None
	} WlanT_HCF_Access_Category;

/* ACK policies used in QoS data control fields.								*/
typedef enum WlanT_HCF_Ack_Policy
	{
	WlanC_Normal_ACK       = 0,
	WlanC_No_ACK           = 1,
	WlanC_No_Explicit_ACK  = 2,
	WlanC_Block_ACK        = 3
	} WlanT_HCF_Ack_Policy;

/* Block ACK policies specified in the standard.								*/
typedef enum WlanT_HCF_BA_Policy
	{
	WlanC_Immediate_BA = 0,
	WlanC_Delayed_BA   = 1
	} WlanT_HCF_BA_Policy;

/* Block ACK status with a peer for a TID.										*/
typedef enum WlanT_HCF_BA_Status
	{
	WlanC_BA_Uninitiated = 0,
	WlanC_BA_Requested   = 1,
	WlanC_BA_Established = 2,
	WlanC_BA_Failure     = 3
	} WlanT_HCF_BA_Status;

/* Special values indicating the direction of an BA agreement with a peer for a	*/
/* TID.																			*/
typedef enum WlanT_HCF_BA_Direction
	{
	WlanC_BA_Recipient     = 0,
	WlanC_BA_Initiator     = 1,
	Wlanc_BA_Bidirectional = 2
	} WlanT_HCF_BA_Direction;	

/** Data Structures **/

/* This structure contains all the flags used in this process model to determine	*/
/* various conditions as mentioned in the comments for each flag.					*/
typedef struct WlanT_Mac_Flags
	{
	Boolean		rts_sent;   		/* Flag to indicate that whether the RTS for this		*/
								    /* particular data frame is sent and CTS is received.	*/
	Boolean		rcvd_bad_packet;	/* Flag to indicate that the received packet is bad		*/
    Boolean	    receiver_busy;		/* Set this flag if receiver busy stat is enabled.		*/
	Boolean		phy_pkt_expected;	/* Set when a packet is expected from physical layer.	*/
    Boolean	    transmitter_busy;	/* Set this flag if we are transmitting something.		*/	
	Boolean		wait_eifs_dur;		/* Set this flag if the station needs to wait for eifs	*/
									/* duration.											*/
	Boolean		ad_hoc_or_ap;		/* Set for APs or STAs of an IBSS.						*/
	Boolean		gateway_flag;		/* Set this flag if the station is a gateway.			*/
	Boolean		bridge_flag;		/* Set this flag if the station is a bridge				*/
	Boolean		immediate_xmt;		/* Set this flag if the new frame can be transmitted	*/
									/* without deferring.									*/
	Boolean		forced_bk_end;		/* Special case: resume with completion of back-off (or	*/
									/* CW) period regardless of receiver's status.			*/
	Boolean		nav_updated;		/* Indicates a new NAV value since the last time when	*/
									/* self interrupt is scheduled for the end of deference.*/
	Boolean		collision;			/* Set this flag if a channel became busy while another	*/
									/* one busy.											*/
	Boolean		collided_packet;	/* Set this flag to drop the next received packet		*/
									/* because of collision.								*/
	Boolean		tx_beacon;          /* Set this flag if time to send a beacon               */
	
	
	Boolean		tx_stateReport;		/*(mohammad) Set this flag if time to send a status report*/
	
	
	Boolean		non_erp_present;	/* Set this flag if we are an ERP STA and our BSS has	*/
									/* at least one non-ERP STA.							*/
	Boolean		cts_to_self;		/* Set this flag if the optional 11g CTS-to-self		*/
									/* protection mechanism is enabled for this MAC.		*/
	Boolean		wait_signal_ext;	/* Set if current tx requires 11g signal extension.		*/
	Boolean		rcvd_bad_cts;		/* Set if a reception is detected during the last		*/
									/* CTS-to-self transmission.							*/
	Boolean		edca_params_updated;/* Set if EDCA parameters are updated from AP's beacon.	*/
	Boolean		txop_on;			/* Set if there is sufficient time in TXOP for the next	*/
									/* transmission after the current transmission.			*/
	Boolean		not_first_in_txop;	/* Set if the currently transmitted frame is not the	*/
									/* first one in the ongoing TXOP.						*/
	Boolean		nqsta_operation;	/* Set if all the 802.11e features are disabled as a	*/
									/* result of being in a non-QoS BSS (nQBSS).			*/
	Boolean		ba_support;			/* Set if the MAC supports "Block ACK" functionalities.	*/
	Boolean		scanning;			/* Set this flag while running the scanning procedure	*/	
									/* to look for a new access point connectivity.			*/
	Boolean		bad_packet_dropped;	/* Set this flag if the received packet is marked as 	*/
									/* bad and dropped by thie MAC.							*/
	} WlanT_Mac_Flags;

/* Data structure for the MAC operation flags that are maintained			*/
/* separately for each access category, such that each AC has a				*/
/* corresponding bit within the flag indicating the value of that flag for	*/
/* that AC.																	*/
typedef struct WlanT_AC_Bit_Flags
	{
	unsigned short	cw_required;	/* Set when a CW-backoff following a successful         */
									/* transmission needs to be performed.					*/
	unsigned short	frsize_req_rts;	/* Flag that is set when the current frame in process	*/
									/* of transmission is larger than the RTS threshold.	*/
	unsigned short	std_cwmin;		/* Set if AC uses the standard default CWmin value.		*/
	unsigned short	std_cwmax;		/* Set if AC uses the standard default CWmax value.		*/
	unsigned short	stats_registered; /* Set if the statistics of the AC are registered.	*/
									/* Bits 0-3 for the statistics of the outgoing traffic,	*/
									/* bits 4-7 for the statistics of the incoming traffic.	*/
	} WlanT_AC_Bit_Flags;


/* Structure that contains the information conveyed in the QoS Control		*/
/* field of the data frames.												*/
typedef struct WlanT_QoS_Control_Fields
	{
	OpT_uInt8				tid;
	WlanT_HCF_Ack_Policy	ack_policy;
	} WlanT_QoS_Control_Fields;

/* Structure that contains the action specific information conveyed in the	*/
/* ADDBA messages.															*/
typedef struct WlanT_ADDBA_Fields
	{
	WlanT_HCF_BA_Policy		policy;
	int						block_size;
	int						starting_seq_num;
	double					timeout_value;
	} WlanT_ADDBA_Fields;

/* Structure that contains the action specific information conveyed in the	*/
/* DELBA messages.															*/
typedef struct WlanT_DELBA_Fields
	{
	Boolean					initiator;
	} WlanT_DELBA_Fields;

/* Structure that represents block ACK specific fields of block ACK control	*/
/* frames "Block ACK Request" and "Block ACK".								*/
typedef struct WlanT_BA_Control_Fields
	{
	int						tid;
	int						starting_seq_num;
	OpT_uInt16				status_bitmap [WLANC_BA_STATUS_BITMAP_MAX_MSDU];
	} WlanT_BA_Control_Fields;

/* Configuration record of a traffic class.									*/
typedef struct WlanT_HCF_TC_Config
	{
	WlanT_HCF_Ack_Policy	ack_policy;
	WlanT_HCF_BA_Policy		ba_policy;
	int						ba_block_size;
	double					ba_timeout_value;
	} WlanT_HCF_TC_Config;

/* Prototype for peer STA information record, which is defined later below.	*/
struct WlanT_HCF_Peer_Info;

/* Information record kept for each entity (MSDU, MMPDU, Block ACK Request	*/
/* or Block ACK) while they are queued for transmission.					*/
typedef struct WlanT_HCF_Hld_Info
	{
	Packet*     				pkptr;
	OpT_Int64					dest_addr;
	OpT_Int64					orig_addr;
	int							protocol_type;
	WlanT_Mac_Frame_Type		type;
	WlanT_HCF_Ack_Policy		ack_policy;
	Boolean						ba_retx;	
	OpT_uInt8					up;
	unsigned int				mmpdu_cat_action_tid;
	OpT_Packet_Size				size;				 	
	double						time_rcvd;
	struct WlanT_HCF_Peer_Info*	addr1_info_ptr;
	} WlanT_HCF_Hld_Info;

/* Data structure used for storing MPDUs in block-ACK related buffers.		*/
typedef struct WlanT_BA_Buffered_MPDU
	{
	Packet*							mpdu_data_pkptr;
	struct WlanT_BA_Buffered_MPDU*	next_mpdu_ptr;
	} WlanT_BA_Buffered_MPDU;

/* Data structure used for storing MSDUs in block-ACK related buffers.		*/
typedef struct WlanT_BA_Buffered_MSDU
	{
	OpT_Int64						final_dest_addr;
	WlanT_Mac_Frame_Type			frame_type;
	int								sequence_number;
	int								num_fragments;
	int								hl_protocol;
	WlanT_HCF_Ack_Policy			ack_policy;
	Boolean							complete;
	OpT_Packet_Id					pkt_id;
	WlanT_BA_Buffered_MPDU*			mpdu_lptr;
	struct WlanT_BA_Buffered_MSDU*	next_msdu_ptr;
	} WlanT_BA_Buffered_MSDU;

/* Data structure used for management of block ACK operation between this	*/
/* MAC and a peer MAC for the data traffic of a TID in both directions.		*/
typedef struct WlanT_HCF_BA_State
	{
	OpT_Int64					peer_addr;
	int							tid;
	
	/* Fields for BAs initiated by this MAC.	*/
	WlanT_HCF_BA_Status			status;
	int							addba_failure_count;
	int							block_size;
	int							starting_seq_num;
	int							max_acked_seq_num;
	int							queued_msdu_count;
	int							mpdu_count;
	int							retx_arr_size;
	Boolean						bar_pending;
	Boolean						awaiting_delayed_ba;
	double						bar_tx_time;
	double						bar_ack_time;
	WlanT_HCF_Hld_Info**		retx_arr;
	Evhandle					addba_resp_timeout_evh;
	Evhandle					inactivity_evh;	
	
	/* Fields for BAs initiated by the peer MAC.*/
	WlanT_HCF_BA_Policy			peer_policy;
	int							peer_block_size;
	int							peer_starting_seq_num;
	int							last_fwd_seq_num;
	int							rcvd_mpdu_count;
	Boolean						first_mpdu_rcvd;
	double						peer_timeout_value;
	OpT_uInt16*					status_bitmap;
	WlanT_BA_Buffered_MSDU*		reordering_buffer_ptr;
	WlanT_BA_Buffered_MSDU*		last_rcvd_msdu_ptr;
	WlanT_BA_Control_Fields*	block_ack_fields_ptr;
	Evhandle					peer_inactivity_evh;
	Pmohandle					buffered_msdu_pmh;
	Pmohandle					buffered_mpdu_pmh;
	} WlanT_HCF_BA_State;

/* Information record kept by QAPs and QSTAs in QIBSS for each other STA in	*/
/* their BSSs.																*/
typedef struct WlanT_HCF_Peer_Info
	{
	Boolean					is_qsta; 	
	Boolean					is_erp;
	Boolean					ba_support;
	OpT_uInt16				seq_cntl; 
	OpT_uInt16*				tid_seq_counter_arr;
	OpT_uInt16*				tid_rcvd_seq_cntl_arr;
	WlanT_HCF_BA_State**	ba_state_ptr_arr;
	
	//(mohammad) new information needed by AP about each peer station 
	OpT_Int64				peer_addr;
	double 					peer_a;
	double 					peer_b;
	double 					peer_c;
	double 					peer_importance;
	double 					peer_physicalRate;
	double 					peer_frameRate;
	double					peer_averageProtocolOverhead;
	double					peer_droppedBRate;
	double					peer_droppedRRate;
	double					peer_TXOP;
	double					peer_appRate;
		
	} WlanT_HCF_Peer_Info;

/* The record kept separately for each access category to store interframe	*/
/* spacing and backoff slots information during the contention for the		*/
/* medium.																	*/
typedef struct WlanT_AC_Deference_Info
	{
	int						backoff_slots;
	WlanT_Mac_Intrpt_Code	type;
	Evhandle				deference_end_evh;
	} WlanT_AC_Deference_Info;

/* Information record kept for the peers sending fragmented data frames in	*/
/* order to reassemble their fragments.										*/
typedef struct WlanT_HCF_Defragmentation_Info
	{		
	OpT_Int64					tx_station_address;
	WlanT_HCF_Access_Category	tx_ac;
	double						time_rcvd; 
	Sbhandle					reassembly_buffer_ptr;  		 
	} WlanT_HCF_Defragmentation_Info;

/* Read-only array for mapping between access category indices and names.	*/
const char*			WLANC_AC_NAME_ARRAY [WLANC_HCF_AC_COUNT] = {"Background", "Best Effort", "Video", "Voice"};

/* Read-only table to map UP (User Priority) values (i.e., the traffic		*/
/* classes, since a higher layer packet with UP "X" is associated with the	*/
/* TC with TID "X") to EDCA access categories as specified in section		*/
/* 9.1.3.1 of the standard.													*/
WlanT_HCF_Access_Category	WLANC_UP_TO_AC_MAPPING_ARRAY [MAX_UP_VALUE - MIN_UP_VALUE + 1] = 
							{WlanC_AC_BE, WlanC_AC_BK, WlanC_AC_BK, WlanC_AC_BE,
							 WlanC_AC_VI, WlanC_AC_VI, WlanC_AC_VO, WlanC_AC_VO};
							
/* Read-only table to map access categories to bit-map values, which are	*/
/* used to set/read/reset the corresponding bits of the ACs in the flag		*/
/* variables of the MAC that can be true or false for each AC independently,*/
/* so that each AC has its on bit within the flag.							*/
unsigned int	WLANC_AC_BITMAP_ARRAY [WLANC_HCF_AC_COUNT] = {0x0001, 0x0002, 0x0004, 0x0008};

//loren, made static
static char myString[3000];
						
int pruning_flag = 0;
//int accu_woe_flag = 0;
char curve[101];
						

double TXOPinterval = 0.02;
						
						
Distribution* geometricDis;
//(mohammad) End of my variables



char buffer[BUFFERSIZE];
						
						
float *fees, *Y,*D, *T, *W ,*TXOP;
		
//matlab engin variables
//Engine *ep;						
//mxArray * results;
//char x0Command[2000];
char Wline[2000];
char Yline[2000];
char Dline[2000];
char Tline[2000];

FILE * myobjfun;
FILE * myconfun;

						
	
						
						
						
/** Macro Definitions **/

/* Due to a bug in Microsoft Visual C++ 6.0 compiler, the compilation of	*/
/* this process model never completes (i.e., compiler enters into an		*/
/* infinite loop) if compiled with MSVC 6.0, optimized kernel is used and	*/
/* the environment attribute comp_trace_info is set to true. To workaround	*/
/* this bug, the code below is added, which turns off the optimization		*/
/* flags for MSVC 6.0 and older MSVC compilers if comp_trace_info is set to	*/
/* true.																	*/
#if !defined (VOSD_NO_FIN)						
#if defined (_WIN32) && (_MSC_VER <= 1200)
#pragma optimize ("", off)
#endif
#endif						

/* Macro definitions to compute the PLCP overhead for control and data		*/
/* frames.																	*/
#define	PLCP_OVERHEAD_CTRL(size)				(phy_type == WlanC_11b_PHY ? plcp_overhead_control : wlan_hcf_non_11b_plcp_overhead_compute (size, control_data_rate))
#define	PLCP_OVERHEAD_DATA(size)				(phy_type == WlanC_11b_PHY ? plcp_overhead_data    : wlan_hcf_non_11b_plcp_overhead_compute (size, operational_speed))
#define	PLCP_OVERHEAD_CTRL_DR(size,data_rate)	(phy_type == WlanC_11b_PHY ? plcp_overhead_control : wlan_hcf_non_11b_plcp_overhead_compute (size, data_rate))
#define	PLCP_OVERHEAD_DATA_DR(size,data_rate)	(phy_type == WlanC_11b_PHY ? \
													(phy_char_flag != WlanC_Infra_Red ? \
														plcp_overhead_data : (data_rate == 1000000.0 ? WLANC_PLCP_OVERHEAD_IR_1MBPS : WLANC_PLCP_OVERHEAD_IR_2MBPS)) \
													: wlan_hcf_non_11b_plcp_overhead_compute (size, data_rate))

/* Macro that compares two MSDU sequence numbers by considering the			*/
/* possibility  that the sequence number may be wrapped around. Block size,	*/
/* multiplied by two (and adjusted by 16 to handle extremely small block	*/
/* sizes), determines the size of the window, which the sequence numbers	*/
/* are expected to belong to.												*/
#define	SEQ_A_GREATER_THAN_SEQ_B(seq_a, seq_b, block_size)		((seq_a > seq_b && seq_a - seq_b < (block_size << 1) + 16) || \
																 (seq_a < seq_b && seq_a + WLANC_SEQ_NUM_WRAP_VALUE - seq_b < (block_size << 1) + 16))
						
/* Macro definitions to compute the transmission delay of control and data	*/
/* frames.																	*/
#define	TXTIME_CTRL(size)				(PLCP_OVERHEAD_CTRL (size) + (double) size / control_data_rate + \
										 ((phy_char_flag == WlanC_ERP_OFDM_11g && control_data_rate > 5500000.0 && control_data_rate != 11000000.0) ? \
										  WLANC_11g_SIGNAL_EXTENSION : 0.0))						
#define	TXTIME_DATA(size)				(PLCP_OVERHEAD_DATA (size) + (double) size / operational_speed + \
										 ((phy_char_flag == WlanC_ERP_OFDM_11g && operational_speed > 5500000.0 && operational_speed != 11000000.0) ? \
										  WLANC_11g_SIGNAL_EXTENSION : 0.0))
#define	TXTIME_CTRL_DR(size,data_rate)	(PLCP_OVERHEAD_CTRL_DR (size, data_rate) + (double) size / data_rate + \
										 ((phy_char_flag == WlanC_ERP_OFDM_11g && data_rate > 5500000.0 && data_rate != 11000000.0) ? WLANC_11g_SIGNAL_EXTENSION : 0.0))
#define	TXTIME_DATA_DR(size,data_rate)	(PLCP_OVERHEAD_DATA_DR (size, data_rate) + (double) size / data_rate + \
										 ((phy_char_flag == WlanC_ERP_OFDM_11g && data_rate > 5500000.0 && data_rate != 11000000.0) ? WLANC_11g_SIGNAL_EXTENSION : 0.0))
							
/* Macro that determines the MAC header size based on frame type.			*/
#define	MPDU_HEADER_SIZE(frame_type)	((frame_type & WLANC_CONTROL_TYPE_BIT) ? 0 : \
										 (frame_type == WlanC_QoS_Data ? WLANC_QOS_MPDU_HEADER_SIZE : WLANC_MPDU_HEADER_SIZE))							

/* The size of the step between two non-overlapping WLAN channels in terms	*/
/* of channel numbers.														*/
#define WLANC_CH_STEP_FOR_NO_OVERLAP	((int) ceil (channel_bandwidth / channel_spacing))	

/* Macro that returns the latest time when the receiver became idle both	*/
/* physically and virtually.												*/
#define	MEDIUM_IDLE_TIME				((nav_duration > rcv_idle_time) ? nav_duration : rcv_idle_time)							
						
/* Macro to check whether WLAN beacon transmission efficiency mode is on.	*/						
#define	BEACON_TX_EFFICIENCY_ENABLED	(beacon_tx_count != WLANC_PERIODIC_BEACON_TX)
						
/* Condition checked to differentiate the first entry into a state from		*/
/* re-entries.																*/						
#define	SET_REENTRY						(state_reentered = OPC_TRUE)							

/* Maximum age of the MPDUs of a BAR while deciding to retransmit or		*/
/* discard a BAR when its previous transmission fails. If the transmit		*/
/* lifetimes of all MPDUs of the BAR are greater than this value then BAR	*/
/* is discarded rather than retransmitted. It is assumed to be equal to the	*/
/* maximum receive lifetime value used by the MAC.							*/
#define MAX_MSDU_TX_LIFETIME			(max_receive_lifetime)
						
/**	State Transitions **/

#define	HL_FRAME_TO_SEND		(ac_queue_status_arr [0] != WlanC_AC_None && AP_CONNECTED)
							
#define	IMMEDIATE_XMT			(wlan_flags->immediate_xmt == OPC_TRUE)

#define	MEDIUM_IS_IDLE			((wlan_flags->receiver_busy == OPC_FALSE && current_time + PRECISION_RECOVERY >= nav_duration && \
								  wlan_flags->phy_pkt_expected == OPC_FALSE) || \
								 fresp_to_send == WlanC_Ack || fresp_to_send == WlanC_BA)

#define	RESPONSE_TO_SEND		(fresp_to_send != WlanC_None)
							
#define	DEFER					(HL_FRAME_TO_SEND && fresp_to_send == WlanC_None && MEDIUM_IS_IDLE && wlan_flags->immediate_xmt == OPC_FALSE)

#define	END_OF_SIFS				(intrpt_type == OPC_INTRPT_SELF && intrpt_code == WlanC_End_Of_SIFS)							

#define BACKOFF_COMPLETE		((intrpt_type == OPC_INTRPT_SELF        && intrpt_code == WlanC_Backoff_Elapsed)     || \
								 (wlan_flags->forced_bk_end == OPC_TRUE && ac_queue_status_arr [0] != WlanC_AC_None) || \
								 wlan_flags->immediate_xmt == OPC_TRUE                                                  )
							
#define CW_COMPLETED			((intrpt_type == OPC_INTRPT_SELF        && intrpt_code == WlanC_CW_Elapsed)          || \
								 (wlan_flags->forced_bk_end == OPC_TRUE && ac_queue_status_arr [0] == WlanC_AC_None)    )
							
#define CW_BACKOFF_COMPLETE		(CW_COMPLETED && AP_CONNECTED)
							
#define	SUSPENDED_BACKOFF		(!MEDIUM_IS_IDLE && wlan_flags->forced_bk_end == OPC_FALSE)
							
#define	TX_COMPLETE				(intrpt_type == OPC_INTRPT_STAT && op_intrpt_stat () == TRANSMITTER_BUSY_INSTAT)
							
#define	RESPONSE_EXPECTED		(expected_frame_type != WlanC_None)
							
#define FRM_END_TO_IDLE			(fresp_to_send == WlanC_None && ac_queue_status_arr [0] == WlanC_AC_None && AP_CONNECTED)
							
#define FRAME_TIMEOUT           ((intrpt_type == OPC_INTRPT_SELF && intrpt_code == WlanC_Frame_Timeout) || \
								 bad_cts_to_self_rcvd == OPC_TRUE)

#define FRAME_RCVD			    (intrpt_type == OPC_INTRPT_STRM && bad_packet_rcvd == OPC_FALSE && \
		 						 i_strm == LOW_LAYER_INPUT_STREAM)

/* The macro TX_QUEUE_FLUSHED provides transition from "MEDIUM BUSY" state	*/
/* back to "IDLE" state. This transition happens only in APs and only if	*/
/* all the AC transmission queues become empty after removing the frames of	*/
/* an STA from the queues as a result of STA's disassociation from the BSS.	*/
#define	TX_QUEUE_FLUSHED		(fresp_to_send == WlanC_None && ac_queue_status_arr [0] == WlanC_AC_None)
						
/* Macros associated with the "SCAN" state. If the scan mode flag is set,	*/
/* the STA considers itself disconnected from its AP and starts	scanning	*/
/* for a new AP-- only in DCF STAs.											*/
#define AP_DISCONNECTED 		(roam_state_ptr->scan_mode == OPC_TRUE && fresp_to_send == WlanC_None)

#define AP_CONNECTED 			(roam_state_ptr->scan_mode == OPC_FALSE)

#define SCAN_AFTER_CW			(CW_COMPLETED && AP_DISCONNECTED)
						
						
						
						
//mohammad
#define	REINITIALIZE			(intrpt_type == OPC_INTRPT_SELF && intrpt_code == REINIT)

/** Function Prototypes **/
static void							wlan_hcf_sv_init (void);
static void							wlan_hcf_edca_parameter_set_read (Objid edca_param_set_comp_objid);
static void							wlan_hcf_edca_ac_parameter_set_read (Objid ac_edca_params_set_objid, WlanT_HCF_Access_Category ac);
static void							wlan_hcf_bss_edca_parameter_set_read (Objid edca_param_set_comp_objid);
static void							wlan_hcf_tc_parameters_read (Objid hcf_params_objid);
static WlanT_HCF_Access_Category	wlan_hcf_higher_layer_data_arrival (void);
static void							wlan_hcf_ac_statistics_register (WlanT_HCF_Access_Category ac, Boolean outbound_traf_stats);
static void							wlan_hcf_hl_packet_drop (Packet* hld_pkptr, OpT_Packet_Size data_size, WlanT_HCF_Access_Category ac);
static void							wlan_hcf_hlpk_enqueue (Packet* hld_pkptr, WlanT_HCF_Access_Category ac, OpT_Int64 dest_addr, OpT_Int64 orig_addr, int up, int protocol_type, OpT_Packet_Size data_size, WlanT_HCF_Peer_Info* dest_info_ptr);
static OpT_Packet_Size				wlan_hcf_hlpk_dequeue (WlanT_HCF_Access_Category ac, int queue_pos);
static void							wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanT_Act_Mgmt_Category category, WlanT_Act_Mgmt_Action action, int tid, OpT_Int64 dest_addr, int starting_seq_num, Boolean ba_initiator);
static void							wlan_hcf_mmpdu_enqueue (Packet* mmpdu_pkptr, OpT_Int64 dest_addr, OpT_Packet_Size size, WlanT_Mac_Frame_Type frame_type, unsigned int cat_action_tid);
static void							wlan_hcf_new_ac_to_contention_add (WlanT_HCF_Access_Category new_ac);
static void							wlan_hcf_suspended_backoff_remaining_slots_compute (WlanT_HCF_Access_Category ac_to_skip);							
static void							wlan_hcf_ba_control_enqueue (WlanT_Mac_Frame_Type type, OpT_Int64 dest_addr, OpT_uInt8 up, WlanT_HCF_Access_Category ac);
static int							wlan_hcf_ac_queue_transmission_status_check (List* ac_hlpk_ptr, WlanT_HCF_Access_Category ac);
static void							wlan_hcf_frame_transmit (void);
static double						wlan_hcf_non_11b_plcp_overhead_compute (OpT_Packet_Size mpdu_length, double data_rate);
static double						wlan_hcf_plcp_overhead_ofdm_compute (OpT_Packet_Size mpdu_length, double data_rate);
static void 						wlan_hcf_control_frame_send (WlanT_Mac_Frame_Type frame_type, OpT_Int64 dest_addr, WlanT_HCF_Hld_Info* hld_ptr);
static void							wlan_hcf_data_frame_send (WlanT_HCF_Hld_Info* hld_ptr);
static WlanT_HCF_Hld_Info*			wlan_hcf_ba_control_queue_entry_create (WlanT_Mac_Frame_Type type, OpT_Int64 peer_addr, OpT_uInt8 tid);
static Boolean						wlan_hcf_next_txop_transmission_check (double txop_time_left, double* duration_ptr, int queue_index);
static void							wlan_hcf_beacon_send (void);							
static void							wlan_hcf_stateReport_send (void);				
static void							wlan_hcf_ba_control_frame_send (WlanT_HCF_Hld_Info* ba_cntl_info_ptr);
static void							wlan_hcf_slot_time_set (double new_slot_time);
static WlanT_HCF_Access_Category	wlan_hcf_interrupts_process (void);
static void							wlan_hcf_sta_disassociation_process (OpT_Int64 sta_addr);
static void							wlan_hcf_peer_tid_ba_info_flush (WlanT_HCF_BA_State* peer_tid_ba_info_ptr, WlanT_HCF_BA_Direction direction);
static void							wlan_hcf_physical_layer_data_arrival (void);
static Boolean						wlan_hcf_tuple_find (WlanT_Mac_Frame_Type type, int tid, OpT_Int64 sta_addr, int seq_control, OpT_Int64 dest_addr, Boolean retry, WlanT_HCF_Peer_Info** src_sta_info_pptr, OpT_uInt16* prev_seq_num_ptr);
static void							wlan_hcf_data_process (WlanT_Mac_Frame_Type frame_type, Packet* seg_pkptr, OpT_Int64 dest_addr, OpT_Int64 sta_addr, OpT_Int64 final_dest_addr, int protocol_type, int frag_num, int more_frag, OpT_Packet_Id pkt_id, short tid, WlanT_HCF_Peer_Info* src_sta_info_ptr);
static void							wlan_hcf_ba_data_process (WlanT_Mac_Frame_Type frame_type, Packet* mpdu_body_pkptr, OpT_Int64 peer_addr, WlanT_HCF_Peer_Info* peer_info_ptr, OpT_Int64 final_dest_addr, int tid, int sequence_control, int more_frag, int protocol_type, OpT_Packet_Id data_pkt_id, WlanT_HCF_Ack_Policy ack_policy, OpT_uInt16 last_seq_num);
static void							wlan_hcf_bar_process (OpT_Int64 peer_addr, Packet* rcvd_frame_pkptr);
static void							wlan_hcf_ba_status_bitmap_shift (WlanT_HCF_BA_State* ba_info_ptr, int seq_num_shift_amount);
static void							wlan_hcf_delayed_ba_complete_msdu_check (WlanT_HCF_BA_State* ba_info_ptr);
static Packet*						wlan_hcf_buffered_ba_msdu_reassemble (WlanT_BA_Buffered_MSDU* msdu_info_ptr);
static void							wlan_hcf_completed_frame_forward (Packet* seg_pkptr, OpT_Int64 src_addr, OpT_Int64 dest_addr, OpT_Int64 final_dest_addr, int protocol_type, OpT_Packet_Id pkt_id, int tid);
static void							wlan_hcf_ba_process (OpT_Int64 peer_addr, Packet* rcvd_frame_pkptr);
static void							wlan_hcf_ba_inactivity_timeout_handle (WlanT_HCF_BA_State* ba_info_vptr, int code);
static void							wlan_hcf_ac_queue_ba_terminate (WlanT_HCF_Access_Category ac, OpT_Int64 peer_addr, int tid);
static void							wlan_hcf_queued_ba_remove (OpT_Int64 peer_addr, int tid);
static void							wlan_hcf_action_mmpdu_process (Packet* frame_body_pkptr, OpT_Int64 peer_addr, WlanT_HCF_Peer_Info* peer_info_ptr);
static WlanT_HCF_BA_State*			wlan_hcf_ba_state_info_get (WlanT_HCF_Peer_Info* peer_info_ptr, OpT_Int64 peer_addr, OpT_uInt8 tid);						
static void							wlan_hcf_accepted_frame_stats_update (Packet* seg_pkptr, WlanT_HCF_Access_Category ac);
static void							wlan_hcf_frame_discard (WlanT_HCF_Access_Category discard_ac);
static void							wlan_hcf_frame_remove (WlanT_HCF_Access_Category discard_ac, int list_pos);
static void							wlan_hcf_bar_mpdus_discard (WlanT_HCF_Hld_Info* bar_info_ptr);
static void							wlan_hcf_mac_rcv_channel_status_update (int channel_id);
static void							wlan_hcf_sta_addr_register (int bss_idx, OpT_Int64 sta_addr, int sta_is_ap, Objid sta_mac_objid, WlanT_Phy_Char_Code phy_char);
static void 						wlan_hcf_sta_addr_deregister (int bss_idx, OpT_Int64 sta_addr);
static void 						wlan_hcf_begin_new_scan (void);
static void							wlan_hcf_ap_switch (void);
static void							wlan_hcf_ac_queues_merge (WlanT_HCF_Access_Category src_ac, WlanT_HCF_Access_Category dst_ac);
static void							wlan_hcf_sv_reset (void);
static void							wlan_hcf_cw_values_adjust (void);							
static void 						wlan_hcf_find_new_ap_virtual (void);
static int							wlan_hcf_seq_a_minus_seq_b (int seq_a, int seq_b, int block_size);
static void							wlan_hcf_ptr_fields_print_functions_set (void);

						
						
						
						
						
typedef enum CalculationMethod 
	{
	PERIODIC,
	FRAMESIZECHECK,
	FRAMESTAT
	}CalculationMethod;

CalculationMethod calculationMethod = FRAMESTAT;
double calculationPeriod = 7.5;

					
int myDebugFlag = 0;
int myDataFileGenerationFlag = 1;
int myStringDebug = 0;
int fee_lambda_trace_flag = 1;
int generatePacketTraceFlag = 0;
int opencvDebugFlag = 0;
int LorenDebugFlag = 1;

FILE * opencvDebugFile;

int trainingCompleteFlag = 0;
cv::Ptr<cv::FaceRecognizer> model = cv::createLBPHFaceRecognizer();
int im_width, im_height;
double recognitionAccuracy = 0;
int totalRecognitions = 0;
int correctRecognitions = 0;
double totalDetectedFaces = 0, totalActualFaces = 0, totalDetectionAccuracy = 0;
double node1correct = 0, node1total = 0;
double node1accuracy = 0;

char tempBnadwidth_allocation_method[101] =  "" ;
char bnadwidth_allocation_method[101] =  "" ;

int EAestimationFlag = 1;
int startSendingStateReport = 0;
 
//double max_operational_speed; moved to state variables
int nodes_no = 1;
double 							EA;

double simulationTime = 600;
int transitionTime = 20;  // used to be 20
int EAestimationTime = 20;
int EACalculationPeriod = 5;
double EACalulationFraction = 0.5;
double round = 0.7;//round should be equal to EACalulationFraction at the begining 
int EAdone = 0;


double lastEAWithoutDropping = 0;

double EACalculationLastTime = 0, lastIncrement = 0, lastDecrement = 0;
int lastOperation = -1;

double dropping[21];

int sumDCounter = 0;
double sumsumD=0;


//PID stuff
float error;
float  Kprop  = 0.5;
float  Kinteg = 0.25;
float  Kderv  = 0.25;
float  LastError = 0;
float  BeforeLastError = 0;



// Loren: packet format name
//made static
static char  fmt_name[20];
static int   im_write_counter = 0;
static int   process_start_flag = 0;

//FILE * MyExcecutionTrace; //mohammad
//char MyExcecutionTracename[500];//mohammad
int EAcalculatedFlag= 0;

// Create memory for calculations
CvMemStorage* storage = 0;
// Create a string that contains the cascade name
char cascade_name[100];// =  "C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt2.xml";
//Create a new Haar classifier
CvHaarClassifierCascade* cascade = 0;

int framesCounter = 0;

enum PixelFormat	 dst_pixfmt = AV_PIX_FMT_YUV420P; //AV_PIX_FMT_GRAY8; //PIX_FMT_BGR24;

extern AVCodecContext		 *pCodecCtx;
extern char 				 filepath[];
extern int					 videoindex;

/*
cv::Size s;
int rows = 0, cols = 0;
cv::VideoCapture cap;
*/


int imwriteFlag = 0;

/* Callback functions		*/
#if defined (__cplusplus)
extern "C" {
#endif

static void							wlan_hcf_data_qos_info_print (void* structure_ptr, PrgT_List* output_list);
static void							wlan_hcf_ba_control_info_print (void* structure_ptr, PrgT_List* output_list);

#if defined (__cplusplus)
} /* end of 'extern "C" {' */
#endif

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
class wlan_mac_hcf_state
	{
	private:
		/* Internal state tracking for FSM */
		FSM_SYS_STATE

	public:
		wlan_mac_hcf_state (void);

		/* Destructor contains Termination Block */
		~wlan_mac_hcf_state (void);

		/* State Variables */
		Stathandle	             		a_stat                                          ;
		Stathandle	             		ac_access_delay_shndl_arr [WLANC_HCF_AC_COUNT]  ;	/* Statistic handle array for local media access delay statistic */
		                        		                                                	/* dimensioned for each access category.                         */
		Stathandle	             		ac_backoff_slots_shndl_arr [WLANC_HCF_AC_COUNT] ;	/* Statistic handle array for local number of backoff slots */
		                        		                                                	/* statistic dimensioned for each access category.          */
		Stathandle	             		ac_delay_shndl_arr [WLANC_HCF_AC_COUNT]         ;	/* Statistic handle array for local end-to-end statistic */
		                        		                                                	/* dimensioned for each access category.                 */
		Stathandle	             		ac_dropped_buffer_bits_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for local statistic measuring dropped */
		                        		                                                	/* data traffic due to full buffer in bits/sec dimensioned for  */
		                        		                                                	/* each access category.                                        */
		Stathandle	             		ac_dropped_buffer_pkts_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for local statistic measuring dropped */
		                        		                                                	/* data traffic due to full buffer in packets/sec dimensioned   */
		                        		                                                	/* for each access category.                                    */
		Stathandle	             		ac_dropped_retx_bits_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for local statistic measuring dropped */
		                        		                                                	/* data traffic in bits/sec as a result of reaching retry limit */
		                        		                                                	/* dimensioned for each access category in bits/sec.            */
		Stathandle	             		ac_dropped_retx_pkts_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for local statistic measuring dropped */
		                        		                                                	/* data traffic in packets/sec as a result of reaching retry    */
		                        		                                                	/* limit dimensioned for each access category in bits/sec.      */
		Stathandle	             		ac_gb_access_delay_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for global media access delay */
		                        		                                                	/* statistic dimensioned for each access category.      */
		Stathandle	             		ac_gb_delay_shndl_arr [WLANC_HCF_AC_COUNT]      ;	/* Statistic handle array for global end-to-end statistic */
		                        		                                                	/* dimensioned for each access category.                  */
		Stathandle	             		ac_gb_dropped_buffer_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for global statistic measuring dropped */
		                        		                                                	/* data traffic due to full buffer in bits/sec dimensioned for   */
		                        		                                                	/* each access category.                                         */
		Stathandle	             		ac_gb_dropped_retx_shndl_arr [WLANC_HCF_AC_COUNT];	/* Statistic handle array for global statistic measuring dropped */
		                        		                                                	/* data traffic in bits/sec as a result of reaching retry limit  */
		                        		                                                	/* dimensioned for each access category.                         */
		Stathandle	             		ac_gb_load_shndl_arr [WLANC_HCF_AC_COUNT]       ;	/* Statistic handle array for global load statistic dimensioned */
		                        		                                                	/* for each access category.                                    */
		Stathandle	             		ac_gb_throughput_shndl_arr [WLANC_HCF_AC_COUNT] ;	/* Statistic handle array for global throughput statistic */
		                        		                                                	/* dimensioned for each access category.                  */
		Stathandle	             		ac_internal_coll_shndl_arr [WLANC_HCF_AC_COUNT - 1];	/* Statistic handle array for local internal collision statistic */
		                        		                                                	/* dimensioned for each access category accept voice.            */
		Stathandle	             		ac_load_bits_shndl_arr [WLANC_HCF_AC_COUNT]     ;	/* Statistic handle array for local load (bits/sec) statistic */
		                        		                                                	/* dimensioned for each access category.                      */
		Stathandle	             		ac_load_pkts_shndl_arr [WLANC_HCF_AC_COUNT]     ;	/* Statistic handle array for local load (packets/sec) statistic */
		                        		                                                	/* dimensioned for each access category.                         */
		Stathandle	             		ac_queue_size_shndl_arr [WLANC_HCF_AC_COUNT]    ;	/* Statistic handle array for local queue size statistic */
		                        		                                                	/* dimensioned for each access category.                 */
		WlanT_HCF_Access_Category			ac_queue_status_arr [WLANC_HCF_AC_COUNT + 1]    ;	/* Array that contains the indices of the ACs that have non- */
		                        		                                                	/* empty higher layer queue. Additional cell is reserved for */
		                        		                                                	/* the end-of-list marker.                                   */
		Stathandle	             		ac_throughput_shndl_arr [WLANC_HCF_AC_COUNT]    ;	/* Statistic handle array for local throughput statistic */
		                        		                                                	/* dimensioned for each access category.                 */
		int	                    		accept_large_packets                            ;	/* Flag to accept packets larger than MAXMSDU size. */
		int *	                  		accuracyCalculationCounter                      ;
		int *	                  		accuracyCalculationCounter2                     ;
		double	                 		accuracyConstant_a                              ;
		double	                 		accuracyConstant_b                              ;
		double	                 		accuracyConstant_c                              ;
		double	                 		aifs_arr [WLANC_HCF_AC_COUNT]                   ;	/* AIFS (DIFS) value of each access category. */
		int	                    		aifsn_arr [WLANC_HCF_AC_COUNT]                  ;	/* AIFSN parameter for each access category. */
		Stathandle	             		ap_conn_handle                                  ;	/* Statistic handle for recording AP connectivity of the MAC. */
		Evhandle	               		ap_connectivity_check_evhndl                    ;	/* Event handle for the periodic AP connectivity check */
		double	                 		ap_connectivity_check_interval                  ;	/* Time interval for periodic check on the connectivity from AP */
		double	                 		ap_connectivity_check_time                      ;	/* Time value indicating the next sim time to check the AP connectivity */
		int	                    		ap_flag                                         ;	/* Flag to read the attribute which indicates whether */
		                        		                                                	/* the station has Access point functional or not.    */
		Stathandle	             		AP_Lambda_stat                                  ;
		OpT_Int64	              		ap_mac_address                                  ;	/* The MAC address of the access point. */
		WlanT_HCF_Peer_Info*	   		ap_peer_info_ptr                                ;	/* Peer STA information record kept for the AP only by the non-AP */
		                        		                                                	/* STAs that belong to an infrastructure BSS.                     */
		double	                 		appRateBits                                     ;
		Stathandle	             		average_accuracy                                ;
		Stathandle	             		average_distortion                              ;
		Stathandle	             		average_stream_DataRate                         ;
		Stathandle	             		b_stat                                          ;
		WlanT_HCF_Access_Category			backoff_ac                                      ;	/* Specifies the access category with the shortest number of */
		                        		                                                	/* slots when its AIFSN and random backoff slots are added.  */
		Evhandle	               		backoff_elapsed_evh                             ;	/* Event handle that keeps track of the self interrupt due to backoff. */
		double	                 		beacon_int                                      ;	/* Beacon Interval in seconds */
		Stathandle	             		beacon_interval_stat                            ;
		int	                    		beacon_tx_count                                 ;	/* The beacon transmission efficiency mode specified in terms of  */
		                        		                                                	/* number of beacons to be transmitted when it is essential to    */
		                        		                                                	/* transmit beacons. If the efficiency mode is disabled then this */
		                        		                                                	/* state variable will have the special value of "-1".            */
		double	                 		beacon_tx_time                                  ;	/* This variable used only by APs when beacon transmission efficiency */
		                        		                                                	/* is enabled. It contains the TBTT of the last transmitted beacon,   */
		                        		                                                	/* or the next beacon whose transmission is already scheduled.        */
		Stathandle	             		bits_load_handle                                ;	/* Reporting the packet size arrived from higher layer. */
		int	                    		bits_sent_in_the_last_TXOP                      ;
		double	                 		bk_medium_idle_time                             ;	/* The time when the MAC enters into the "IFS and BACKOFF" state */
		                        		                                                	/* and starts its deference, which will be adjusted if           */
		                        		                                                	/* wait_eifs_duration flag is set.                               */
		WlanT_AC_EDCA_Param_Rec*			bss_edca_params_arr                             ;	/* Array that contains EDCA Parameters for each access category */
		                        		                                                	/* to be advertised by the AP to its BSS. This array is not     */
		                        		                                                	/* created if the MAC is not an AP or it is not configured to   */
		                        		                                                	/* advertise EDCA parameters to its BSS.                        */
		Boolean	                		bss_flag                                        ;	/* Flag to check whether the network is configured for BSS or IBSS. */
		int	                    		bss_id                                          ;	/* When BSS_ID attribute is being used , this variable identifies  */
		                        		                                                	/* the BSS to which a node belongs. Otherwise, each subnet defines */
		                        		                                                	/* a BSS, and this state variable just retains its default value,  */
		                        		                                                	/* which is -1.                                                    */
		                        		                                                	/* CHANGED: BSS now stores the subnet object ID as the BSS ID      */
		Stathandle	             		buffer_drop_bits_handle                         ;	/* Keep track of the dropped packets in bits/sec by the higher */
		                        		                                                	/* layer queue due to the overflow of the buffer.              */
		Stathandle	             		buffer_drop_pkts_handle                         ;	/* Keep track of the dropped packets in packets/sec by the higher */
		                        		                                                	/* layer queue due to the overflow of the buffer.                 */
		Stathandle	             		c_stat                                          ;
		double	                 		channel_bandwidth                               ;	/* The bandwidth of the operating WLAN radio channels in */
		                        		                                                	/* MHz.                                                  */
		int	                    		channel_count                                   ;	/* The number of operating WLAN radio channels, which     */
		                        		                                                	/* depends on the physical layer technology (i.e. 802.11a */
		                        		                                                	/* or 802.11/11b).                                        */
		int	                    		channel_num                                     ;	/* The number of the channel that is currently being used. */
		double	                 		channel_spacing                                 ;	/* The spacing between two operating WLAN radio channels in */
		                        		                                                	/* MHz.                                                     */
		Sbhandle	               		common_rsmbuf_ptr                               ;	/* Common reassembly buffer used for segments containing the entire */
		                        		                                                	/* original packet.                                                 */
		OpT_uInt16	             		common_seq_count                                ;	/* Sequence number counter used for MMPDUs, non-QoS data */
		                        		                                                	/* frames and broadcast QoS data frames.                 */
		int	                    		completeFrameRecievedFlag                       ;
		int *	                  		completeFrames                                  ;
		int *	                  		concealedFrames                                 ;
		Log_Handle	             		config_log_handle                               ;	/* Simulation log handle for configuration related messages. */
		WlanT_AP_Position_Info*			conn_ap_pos_info_ptr                            ;	/* Position information for the connected AP. */
		double	                 		control_data_rate                               ;	/* Data rate used for the transmission of control frames. The rate */
		                        		                                                	/* is the lowest one of the mandatory data rates set of the        */
		                        		                                                	/* configured physical layer technology.                           */
		Stathandle	             		ctrl_traffic_rcvd_handle                        ;	/* Control Traffic (Rts,Cts or Ack) received by the station in packets */
		Stathandle	             		ctrl_traffic_rcvd_handle_inbits                 ;	/* Control Traffic (Rts,Cts or Ack) received by the station in bits */
		Stathandle	             		ctrl_traffic_sent_handle                        ;	/* Control Traffic (Rts,Cts or Ack) sent by the station */
		Stathandle	             		ctrl_traffic_sent_handle_inbits                 ;	/* Control Traffic (Rts,Cts or Ack) sent by the station in bits */
		WlanT_HCF_Access_Category			cur_tx_ac                                       ;	/* Specifies the access category of the currently ongoing */
		                        		                                                	/* physical layer transmission process (i.e., the access  */
		                        		                                                	/* category that won the last contention).                */
		double	                 		current_lambda                                  ;
		char	                   		current_state_name [32]                         ;	/* Keeping track of the current state of the station. */
		double	                 		current_time                                    ;	/* Keeps track of the current simulation time at each interrupt */
		Stathandle	             		CVAccuracyA                                     ;
		Stathandle	             		CVAccuracyC                                     ;
		Stathandle	             		CVAccuracyI                                     ;
		int	                    		cw_arr [WLANC_HCF_AC_COUNT]                     ;	/* The size of current CW dimensioned for each AC. */
		int	                    		cwmax_arr [WLANC_HCF_AC_COUNT]                  ;	/* CWmax parameter of backoff procedure dimensioned for each AC. */
		int	                    		cwmin_arr [WLANC_HCF_AC_COUNT]                  ;	/* CWmin parameter of backoff procedure dimensioned for each AC. */
		int	                    		data_frames_sent_in_the_last_stateREport_int_count;
		Stathandle	             		data_frames_sent_in_the_last_stateREport_int_count_stat;
		int	                    		data_packet_dropped                             ;
		int	                    		data_packet_droppedB_in_the_last_stateReport_int_count;
		int	                    		data_packet_loaded_in_the_last_stateReport_int_count;
		int	                    		data_packet_sent_count                          ;
		Stathandle	             		data_packet_sent_count_stat                     ;
		Stathandle	             		data_traffic_rcvd_handle                        ;	/* Data Traffic received by the station */
		Stathandle	             		data_traffic_rcvd_handle_inbits                 ;	/* Data Traffic received by the station in bits */
		Stathandle	             		data_traffic_sent_handle                        ;	/* Data Traffic sent by the station */
		Stathandle	             		data_traffic_sent_handle_inbits                 ;	/* Data Traffic sent  by the station in bits */
		double	                 		data_tx_rate                                    ;	/* Used in storing data rate attribute. This is the rate at which */
		                        		                                                	/* data frame is transmitted.                                     */
		int	                    		dataRatePeriodCounter                           ;
		Boolean	                		debug_mode                                      ;	/* Flag that is set if the simulation is executed in debugging */
		                        		                                                	/* mode.                                                       */
		WlanT_AC_Deference_Info			deference_info_arr [WLANC_HCF_AC_COUNT]         ;	/* Deference (AIFS + back-off) related information maintained */
		                        		                                                	/* separately for each access category.                       */
		List*	                  		defragmentation_list_ptr                        ;	/* This buffer contains the fragments received from   */
		                        		                                                	/* remote station and maintains following information */
		                        		                                                	/* for each fragment:                                 */
		                        		                                                	/* 1. remote station address                          */
		                        		                                                	/* 2. time the last fragment was received             */
		                        		                                                	/* 3. reassembly buffer                               */
		double	                 		difs_time                                       ;	/* DIFS interval is used by the stations to transmit data frames. */
		char **	                		directoryName                                   ;
		List*	                  		disassociating_sta_lptr                         ;	/* List of STA addresses (integers) that are leaving our BSS  */
		                        		                                                	/* and their disassociations need to be processes at the next */
		                        		                                                	/* opportunity.                                               */
		int	                    		drop_pkt_entry_log_flag                         ;	/* This is to make sure that the entry is written only once. */
		Log_Handle	             		drop_pkt_log_handle                             ;	/* Logging information if the packet is dropped due to higher layer */
		                        		                                                	/* queue overflow.                                                  */
		Boolean	                		duplicate_entry                                 ;	/* Flag for duplicate entry. Keeps track that whether the receive frame was */
		                        		                                                	/* a duplicate frame or not. This information is transmitted in ACK frame.  */
		Stathandle	             		EA_stat                                         ;
		int	                    		EAcounter                                       ;
		double	                 		EAsum                                           ;
		double	                 		EDCA_last_DataRate_reset_time                   ;
		double	                 		eifs_time                                       ;	/* EIFS duration which is used when the station receives an erroneous frame */
		                        		                                                	/*                                                                          */
		Stathandle	             		ete_delay_handle                                ;	/* Handle for the end to end delay statistic that is recorded for   */
		                        		                                                	/* the packets that are accepted and forwarded to the higher layer. */
		int	                    		eval_bss_id                                     ;	/* BSS ID of the BSS under evaluation. */
		WlanT_Mac_Frame_Type	   		expected_frame_type                             ;	/* Set the expected frame type needed in response */
		                        		                                                	/* to the transmitted frame                       */
		Stathandle	             		fee_stat                                        ;
		double	                 		first_chan_min_freq                             ;	/* The minimum frequency of the first one of the operating */
		                        		                                                	/* WLAN radio channels (in MHz).                           */
		int	                    		frag_threshold                                  ;	/* Used in storing fragmentation threshold attribute */
		Sbhandle	               		fragmentation_buffer_arr [WLANC_HCF_AC_COUNT]   ;	/* AC specific segmentation buffers used to create fragments of */
		                        		                                                	/* the MSDUs and MMPDUs when required.                          */
		Evhandle	               		frame_timeout_evh                               ;	/* Event handle that keeps track of the self interrupt due to frame timeout */
		                        		                                                	/* when the station is waiting for a response.                              */
		int	                    		frameRate                                       ;
		Stathandle	             		frameRate_stat                                  ;
		int	                    		frameRecievedFlag                               ;
		double*	                		frameSizeOfNode                                 ;
		Evhandle	               		fresp_ifs_evh                                   ;	/* Event handle for the interrupt that indicates the end of IFS */
		                        		                                                	/* (SIFS) before sending a response frame.                      */
		WlanT_Mac_Frame_Type	   		fresp_to_send                                   ;	/* After receiving a frame station will determine that what response */
		                        		                                                	/* need to be sent.                                                  */
		Stathandle	             		global_buffer_drop_handle                       ;	/* Statistic handle for global dropped higher layer data due to full */
		                        		                                                	/* buffer.                                                           */
		Stathandle	             		global_ete_delay_handle                         ;	/* Handle for global end-to-end delay statistic. */
		Stathandle	             		global_load_handle                              ;	/* Handle for global WLAN load statistic. */
		Stathandle	             		global_mac_delay_handle                         ;	/* Handle for global media access delay statistic. */
		OmsT_Dim_Stat_Handle	   		global_network_load_handle                      ;	/* Handle for the network load statistic that is collected globally */
		                        		                                                	/* and dimensioned for each BSS.                                    */
		Stathandle	             		global_retrans_handle                           ;	/* Keep track of the global number of retransmissions before the packet was */
		                        		                                                	/* successfully transmitted.                                                */
		Stathandle	             		global_retx_drop_handle                         ;	/* Statistic handle for global dropped higher layer data due to */
		                        		                                                	/* reaching the short or long retry limits.                     */
		Stathandle	             		global_throughput_handle                        ;	/* Handle for global WLAN throughput statistic. */
		Stathandle	             		hl_packets_rcvd                                 ;	/* Monitor queue size as the packets arrive from higher layer. */
		int	                    		hld_max_size                                    ;	/* This variable maintains the maximum size of the higher layer */
		                        		                                                	/* data buffer as specified by the user.                        */
		Pmohandle	              		hld_pmh                                         ;	/* This list stores the information of the received packet.  */
		                        		                                                	/* The information includes source station address, packet   */
		                        		                                                	/* sequence id, and packet fragment number. This             */
		                        		                                                	/* is used to keep track that whether the received packet is */
		                        		                                                	/* a duplicate of the previously received frame. If that's   */
		                        		                                                	/* the case then packet is simply discarded.                 */
		                        		                                                	/*                                                           */
		                        		                                                	/* Pool memory handle used to allocate memory for the data   */
		                        		                                                	/* received from the higher layer and inserted in the queue  */
		List*	                  		hlpk_lptr_arr [WLANC_HCF_AC_COUNT]              ;	/* Higher layer packet queues maintained separately for each AC. */
		int	                    		i_strm                                          ;	/* Keeping track of incoming packet stream from the lower layer. */
		char **	                		imageName                                       ;
		int	                    		imageNo                                         ;
		double	                 		importance                                      ;
		Stathandle	             		importance_stat                                 ;
		int *	                  		incompleteFrames                                ;
		int	                    		incrementCounter                                ;
		int	                    		instrm_from_mac_if                              ;	/* Stream index coming from the higher layer MAC interface. */
		WlanT_Mac_Intrpt_Code	  		intrpt_code                                     ;	/* Enumerated intrpt code for interrupts */
		double	                 		intrpt_time                                     ;	/* Storing total backoff time when backoff duration is set */
		int	                    		intrpt_type                                     ;	/* Intrpt type is stored in this variable */
		Stathandle	             		lambda_stat                                     ;
		double	                 		last_calculated_average_TXOP_displasement       ;
		double	                 		last_calculated_droppedB_prob                   ;
		double*	                		last_DataRate_reset_time                        ;
		double *	               		last_DataRate_reset_time2                       ;
		double	                 		last_DataRate_reset_time_PERIODIC               ;
		double	                 		last_my_droppedB_calculated_time                ;
		double	                 		last_my_droppedR_calculated_time                ;
		double	                 		last_my_load_calculated_time                    ;
		double	                 		last_my_sent_calculated_time                    ;
		double	                 		last_rcvd_duration                              ;	/* The duration value retrieved from the last successfully */
		                        		                                                	/* received physical layer packet.                         */
		double	                 		last_sent_averageProtocolOverhead               ;
		double	                 		last_sent_droppedBRate                          ;
		double	                 		last_sent_droppedRRate                          ;
		double	                 		last_sent_loadRate                              ;
		double	                 		last_sent_physicalRate                          ;
		double	                 		last_sent_protocolOverheadRate                  ;
		double	                 		last_sent_sentRate                              ;
		double	                 		last_sent_video_frame_size                      ;
		double	                 		last_sent_video_frame_size_without_header       ;
		double	                 		last_sent_video_frame_time                      ;
		WlanT_Mac_Frame_Type	   		last_tx_frtype_arr [WLANC_HCF_AC_COUNT]         ;	/* Type of the last transmitted frame under each access category. */
		                        		                                                	/* This information is used during retransmissions.               */
		double	                 		last_TXOP_start_time                            ;
		int *	                  		lastFrameN                                      ;
		int *	                  		lastFrameSizeInPackets                          ;
		int *	                  		lastImageLineNumber                             ;
		int *	                  		lastPacketN                                     ;
		int *	                  		lastQ                                           ;
		int	                    		linesIndex                                      ;
		Ici*	                   		llc_iciptr                                      ;	/* Sending ici to the bridge queue with final destination address. */
		int	                    		long_retry_limit                                ;	/* This is the retry limit for the frames which are greater than or equal to */
		                        		                                                	/* Rts threshold.                                                            */
		Stathandle	             		LoopSum_stat                                    ;
		int	                    		lostPackets[100][200]                           ;
		int	                    		lostPacketsCounter[100]                         ;
		short	                  		lrc_arr [WLANC_HCF_AC_COUNT]                    ;	/* Short retry count values maintained independently for */
		                        		                                                	/* each access category.                                 */
		double	                 		Ls                                              ;
		Stathandle	             		mac_appRate_stat                                ;
		Sbhandle	               		mac_client_reassembly_buffer                    ;	/* Reassembly buffer for higher layer packets segmented in */
		                        		                                                	/* multiprotocol switches.                                 */
		PrgT_Mutex*	            		mapping_info_mutex                              ;	/* Mutex used to serialize calling prg_mapping functions, which */
		                        		                                                	/* read/write global WLAN information, under multi-threaded     */
		                        		                                                	/* execution with multiple CPUs.                                */
		int	                    		max_frags_per_msdu                              ;	/* Maximum expected number of fragments per MSDU */
		                        		                                                	/* (i.e., MAX_MSDU_SIZE / frag_threshold).       */
		double	                 		max_operational_speed                           ;
		Stathandle	             		max_operational_speed_stat                      ;
		double	                 		max_receive_lifetime                            ;	/* Maximum time after the initial reception of the fragmented MSDU         */
		                        		                                                	/* after which further attempts to reassemble the MSDU will be terminated. */
		double	                 		maxLoad                                         ;
		Stathandle	             		maxLoad_stat                                    ;
		Stathandle	             		media_access_delay                              ;	/* Keep tracks of the delay from the time the packet is received       */
		                        		                                                	/* from the higher layer to the time it is transmitted by the station. */
		Stathandle	             		mgmt_retx_drop_bits_handle                      ;	/* Keep track of the dropped management, BAR and delayed BA frames */
		                        		                                                	/* in bits/sec as a result reaching retry limit.                   */
		Stathandle	             		mgmt_retx_drop_pkts_handle                      ;	/* Keep track of the dropped management, BAR and delayed BA frames */
		                        		                                                	/* in packets/sec as a result reaching retry limit.                */
		Stathandle	             		mgmt_traffic_rcvd_handle                        ;	/* Management traffic received by the station in packets */
		Stathandle	             		mgmt_traffic_rcvd_handle_inbits                 ;	/* Management traffic received by the station in bits */
		Stathandle	             		mgmt_traffic_sent_handle                        ;	/* Management traffic sent by the station in packets */
		Stathandle	             		mgmt_traffic_sent_handle_inbits                 ;	/* Management traffic sent by the station in bits */
		int *	                  		missedFrames                                    ;
		Packet*	                		mpdu_retx_copy_arr [WLANC_HCF_AC_COUNT]         ;	/* Copy of the last transmitted MPDU of each access category */
		                        		                                                	/* that requires an ACK, which is not received, yet. Hence,  */
		                        		                                                	/* these copies are used for retransmissions when necessary. */
		OpT_Int64	              		my_address                                      ;	/* Station's own address */
		WlanT_Bss_Mapping_Info*			my_bss_info_ptr                                 ;	/* Handle to the information record of the current BSS */
		                        		                                                	/* including the list of STAs that belong to that BSS. */
		Stathandle	             		my_droppedB_stat                                ;
		double	                 		my_droppedB_sum                                 ;
		Stathandle	             		my_droppedR_stat                                ;
		double	                 		my_droppedR_sum                                 ;
		Stathandle	             		my_load_stat                                    ;
		double	                 		my_load_sum                                     ;
		Objid	                  		my_node_objid                                   ;	/* The object ID of the surrounding node. */
		Objid	                  		my_objid                                        ;	/* The object ID of the surrounding module. */
		Stathandle	             		my_sent_stat                                    ;
		double	                 		my_sent_sum                                     ;
		Objid	                  		my_subnet_objid                                 ;	/* The object ID of the subnet in which the */
		                        		                                                	/* surrounding node model resides.          */
		double*	                		myDataRates                                     ;
		FILE *	                 		MyExcecutionTrace                               ;
		char *	                 		MyExcecutionTracename                           ;
		double	                 		nav_duration                                    ;	/* Network allocation vector duration this an absolute time from the   */
		                        		                                                	/* beginning of the simulation. It will be considered as zero if it is */
		                        		                                                	/* set to the current time.                                            */
		Evhandle	               		nav_end_evh                                     ;	/* Event handle for the interrupt that indicates the end of NAV, */
		                        		                                                	/* which means the medium is available according to the virtual  */
		                        		                                                	/* carrier sensing.                                              */
		Evhandle	               		nav_reset_evh                                   ;	/* Handle for the procedure interrupt that is scheduled to reset the */
		                        		                                                	/* NAV that is updated based on a received RTS, if no activity is    */
		                        		                                                	/* detected on the medium for a certain time as specified in section */
		                        		                                                	/* 9.2.5.4 of the IEEE 802.11-1999 standard.                         */
		int	                    		new_variable                                    ;
		int	                    		num_fragments_arr [WLANC_HCF_AC_COUNT]          ;	/* The total number of fragments composing the MSDU or MMPDU */
		                        		                                                	/* that is currently being transmitted under each AC.        */
		Stathandle	             		number_of_stations                              ;
		int	                    		number_of_TXOP_in_calculation_period            ;
		int	                    		numberOfInputDataRates                          ;
		OmsT_Aa_Address_Handle	 		oms_aa_handle                                   ;	/* used to obtain address handle to resolve wlan MAC address */
		double	                 		operational_speed                               ;	/* Current data rate used for the transmissions of the data frames. */
		                        		                                                	/* This rate can be different than the value of data_tx_rate if the */
		                        		                                                	/* current connected access point can't support that rate.          */
		double	                 		Os                                              ;
		int	                    		outstrm_to_mac_if                               ;	/* Stream index connected to the higher layer MAC interface. */
		Objid	                  		own_ac_edca_params_objid                        ;	/* Object ID of the compound attribute that contains the AC */
		                        		                                                	/* EDCA Parameter Set configured for this MAC.              */
		OmsT_Pr_Handle	         		own_process_record_handle                       ;	/* Handle to the own process record in the network wide process */
		                        		                                                	/* registery.                                                   */
		Stathandle	             		packet_data_percent_stat                        ;
		Stathandle	             		packet_load_handle                              ;	/* Recording number of packets received from the */
		                        		                                                	/* higher layer                                  */
		Stathandle	             		packet_size_stat                                ;
		int *	                  		packetCounter                                   ;
		PrgT_Bin_Hash_Table*	   		peer_info_hash_tbl                              ;	/* Hash table to access the information records of peer STAs quickly. */
		int *	                  		peerAddress                                     ;
		double *	               		peerStreamAccuracy                              ;
		double*	                		peerStreamAccuracy2                             ;
		double*	                		peerStreamAccuracyError                         ;
		double *	               		peerStreamAccuracyError2                        ;
		double*	                		peerStreamData                                  ;
		double *	               		peerStreamData2                                 ;
		double*	                		peerStreamDataForRate                           ;
		double *	               		peerStreamDataForRate2                          ;
		double *	               		peerStreamDataRate                              ;
		double *	               		peerStreamDataRate2                             ;
		double *	               		peerStreamDistortion                            ;
		double *	               		peerStreamDistortion2                           ;
		WlanT_Phy_Char_Code	    		phy_char_flag                                   ;	/* This variable stores the physical layer characteristic type information. */
		int	                    		phy_cw_max                                      ;	/* Maximum contention window size based on deployed physical */
		                        		                                                	/* layer technology.                                         */
		int	                    		phy_cw_min                                      ;	/* Minimum contention window size based on deployed physical */
		                        		                                                	/* layer technology.                                         */
		WlanT_Phy_Type	         		phy_type                                        ;	/* Type of the 802.11 standard that specifies the physical layer */
		                        		                                                	/* technology used by this MAC. Frequency hopping and infra-red  */
		                        		                                                	/* technologies are referred as 802.11b technologies.            */
		double	                 		physicalRate                                    ;
		Stathandle	             		physicalRate_readfromtransmiter_stat            ;
		Stathandle	             		physicalRate_stat                               ;
		OpT_uInt16	             		pkt_seq_cntl_arr [WLANC_HCF_AC_COUNT]           ;	/* Array that stores the sequence control (sequence + fragment */
		                        		                                                	/* number) of the frame that is being transmitted by each AC.  */
		double	                 		plcp_overhead_control                           ;	/* Delay in seconds to transmit PLCP Preamble and PLCP Header at lowest */
		                        		                                                	/* mandatory data rate of the physical layer for WLAN control frames.   */
		double	                 		plcp_overhead_data                              ;	/* Delay in seconds to transmit PLCP Preamble and PLCP Header for WLAN */
		                        		                                                	/* data frames.                                                        */
		double	                 		pruning_percent                                 ;
		double	                 		rcv_idle_time                                   ;	/* Last simulation time when the receiver became idle again. */
		int	                    		rcvd_bar_tid                                    ;	/* TID value of last successfully received block ACK request to be	 */
		                        		                                                	/* used in composing the immediate block ACK message.				           */
		double	                 		rcvd_frame_drate                                ;	/* Data rate of the last successfully received frame, which is used */
		                        		                                                	/* in determining the transmission rate of the control response     */
		                        		                                                	/* messages (CTS and ACK).                                          */
		double	                 		receive_time                                    ;	/* The arrival time of the packet that is currently handled. */
		int	                    		received_beacon_count                           ;	/* mohammad */
		Stathandle	             		received_beacon_count_stat                      ;	/* mohammad */
		int	                    		received_RTS_count                              ;
		Stathandle	             		received_RTS_count_stat                         ;
		int	                    		received_stateReport_count                      ;
		Stathandle	             		received_stateReport_count_stat                 ;
		FILE *	                 		receivedPacketTrace                             ;
		int	                    		rem_beacon_tx                                   ;	/* This state variable used only by APs. It specifies how many more */
		                        		                                                	/* beacons need to be transmitted before beacon transmission is     */
		                        		                                                	/* stopped due to efficiency mode. If the efficiency mode is        */
		                        		                                                	/* disabled then this variable will have the special value "-1".    */
		OpT_Packet_Size	        		remainder_size_arr [WLANC_HCF_AC_COUNT]         ;	/* The size of the last (or maybe the only) fragment of the */
		                        		                                                	/* MSDU or MMPDU that is being transmitted under each AC.   */
		OpT_Int64	              		response_sta_addr                               ;	/* The MAC address of the STA, which we need to send a response frame. */
		Stathandle	             		retrans_handle                                  ;	/* Keep track of the number of retransmissions before the packet was */
		                        		                                                	/* successfully transmitted.                                         */
		Stathandle	             		retx_drop_bits_handle                           ;	/* Keep track of the dropped packets in bits/sec as a result of */
		                        		                                                	/* reaching short or long retry limit.                          */
		Stathandle	             		retx_drop_pkts_handle                           ;	/* Keep track of the dropped packets in packets/sec as a result of */
		                        		                                                	/* reaching short or long retry limit.                             */
		WlanT_Roam_State_Info*	 		roam_state_ptr                                  ;	/* Roaming related information. */
		int	                    		rts_threshold                                   ;	/* Used in storing Rts threshold attribute */
		Objid	                  		rx_objid                                        ;	/* Object ID of the radio receiver that we */
		                        		                                                	/* are connected to.                       */
		double	                 		rx_power_threshold                              ;	/* Receiver power threshold for valid WLAN packets. */
		WlanT_Rx_State_Info*	   		rx_state_info_ptr                               ;	/* Receiver channel state information. */
		Objid	                  		rxch_objid                                      ;	/* Object ID of the channel of our receiver. */
		int	                    		sent_beacon_count                               ;	/* mohammad */
		Stathandle	             		sent_beacon_count_stat                          ;	/* mohammad */
		int	                    		sent_stateReport_count                          ;
		Stathandle	             		sent_stateReport_count_stat                     ;
		FILE *	                 		sentPacketTrace                                 ;
		OpT_Packet_Id	          		served_pk_id_arr [WLANC_HCF_AC_COUNT]           ;	/* The ID of the data packet that is currently being */
		                        		                                                	/* transmitted by each access category.              */
		int	                    		short_retry_limit                               ;	/* This is the retry limit for the frames which are less than or equal to */
		                        		                                                	/* Rts threshold.                                                         */
		double	                 		sifs_time                                       ;	/* Read the SIFS time from the model attributes */
		int **	                 		sizes                                           ;
		double	                 		slot_time                                       ;	/* Read the Slot time from the model attributes */
		short	                  		src_arr [WLANC_HCF_AC_COUNT]                    ;	/* Short retry count values maintained independently for */
		                        		                                                	/* each access category.                                 */
		double *	               		start_times                                     ;
		double	                 		stateReport_int                                 ;
		double	                 		stateReport_tx_time                             ;
		int	                    		stateReportStarted                              ;
		Stathandle	             		sumD_stat                                       ;
		WlanT_HCF_TC_Config	    		tc_config_arr [WLANC_HCF_TC_COUNT]              ;	/* Array that maintains the configuration records of all the */
		                        		                                                	/* traffic classes.                                          */
		double	                 		temp_ph_rate                                    ;
		double	                 		tempAccuracy                                    ;
		double	                 		tempFrameSize                                   ;
		Stathandle	             		throughput_handle                               ;	/* Keep track of the number of data bits sent to the higher layer. */
		double	                 		total_ba_reorder_buf_size                       ;	/* Total size of reordering buffers of currently active BA */
		                        		                                                	/* agreements.                                             */
		int	                    		total_bits_sent_in_the_last_TXOP                ;
		double	                 		total_data_header_size_sent                     ;
		double	                 		total_data_sent                                 ;
		double	                 		total_data_size_sent_without_headers            ;
		int	                    		total_hlpk_num                                  ;	/* Maintaining total number of the packets in higher layer queues. */
		OpT_Packet_Size	        		total_hlpk_size                                 ;	/* Maintaining total size of the packets in higher layer queues. */
		Stathandle	             		total_reorder_size_handle                       ;	/* Keep track of total size of the reordering buffers of active */
		                        		                                                	/* Block-ACK agreements.                                        */
		int	                    		totalDataResetedFalg                            ;
		int *	                  		totalDataResetedFalgArray                       ;
		int *	                  		totalFrames                                     ;
		double*	                		totalPeerStreamData                             ;
		double *	               		totalPeerStreamData2                            ;
		int *	                  		trimmedAccuracyCounter                          ;
		int *	                  		trimmedAccuracyCounter2                         ;
		Objid	                  		tx_objid                                        ;	/* Object ID of the radio transmitter that */
		                        		                                                	/* we are connected to.                    */
		Objid	                  		txch_objid                                      ;	/* Object ID of the channel of our transmitter. */
		WlanT_Mac_Frame_Type	   		txframe_type                                    ;	/* Type of the frame that is at the head of the transmission	   */
		                        		                                                	/* queue of the AC that has done the last transmission of the	  */
		                        		                                                	/* MAC or just experienced an internal collision. The value of	 */
		                        		                                                	/* this state variable is used in the wlan_hcf_frame_discard()  */
		                        		                                                	/* function.                                                    */
		int	                    		TXOP_counter                                    ;
		Stathandle	             		TXOP_displasement_stat                          ;
		double	                 		TXOP_displasement_total                         ;
		double	                 		txop_limit_arr [WLANC_HCF_AC_COUNT]             ;	/* Transmission opportunity (TXOP) limits for each access */
		                        		                                                	/* category.                                              */
		double	                 		txop_start_time                                 ;	/* The start time of the current (or last) TXOP. */
		Stathandle	             		video_TXOP_stat                                 ;
		Stathandle	             		weighted_accuracy_sum                           ;
		WlanT_AC_Bit_Flags*	    		wlan_ac_flags                                   ;	/* This structure contains all the access category specific */
		                        		                                                	/* flags which the process model used to convey information */
		                        		                                                	/* from one state to another for details check the header   */
		                        		                                                	/* block where the structure is defined.                    */
		WlanT_Mac_Flags*	       		wlan_flags                                      ;	/* This structure contains all the flags which the process    */
		                        		                                                	/* model used to convey information from one state to another */
		                        		                                                	/* for details check the header block where the structure is  */
		                        		                                                	/* defined.                                                   */
		Boolean	                		wlan_trace_active                               ;	/* Debugging/trace flag for all activities in this MAC. */

		/* FSM code */
		void wlan_mac_hcf (OP_SIM_CONTEXT_ARG_OPT);
		/* Diagnostic Block */
		void _op_wlan_mac_hcf_diag (OP_SIM_CONTEXT_ARG_OPT);

#if defined (VOSD_NEW_BAD_ALLOC)
		void * operator new (size_t) throw (VOSD_BAD_ALLOC);
#else
		void * operator new (size_t);
#endif
		void operator delete (void *);

		/* Memory management */
		static VosT_Obtype obtype;
	};

VosT_Obtype wlan_mac_hcf_state::obtype = (VosT_Obtype)OPC_NIL;

#define a_stat                  		op_sv_ptr->a_stat
#define ac_access_delay_shndl_arr		op_sv_ptr->ac_access_delay_shndl_arr
#define ac_backoff_slots_shndl_arr		op_sv_ptr->ac_backoff_slots_shndl_arr
#define ac_delay_shndl_arr      		op_sv_ptr->ac_delay_shndl_arr
#define ac_dropped_buffer_bits_shndl_arr		op_sv_ptr->ac_dropped_buffer_bits_shndl_arr
#define ac_dropped_buffer_pkts_shndl_arr		op_sv_ptr->ac_dropped_buffer_pkts_shndl_arr
#define ac_dropped_retx_bits_shndl_arr		op_sv_ptr->ac_dropped_retx_bits_shndl_arr
#define ac_dropped_retx_pkts_shndl_arr		op_sv_ptr->ac_dropped_retx_pkts_shndl_arr
#define ac_gb_access_delay_shndl_arr		op_sv_ptr->ac_gb_access_delay_shndl_arr
#define ac_gb_delay_shndl_arr   		op_sv_ptr->ac_gb_delay_shndl_arr
#define ac_gb_dropped_buffer_shndl_arr		op_sv_ptr->ac_gb_dropped_buffer_shndl_arr
#define ac_gb_dropped_retx_shndl_arr		op_sv_ptr->ac_gb_dropped_retx_shndl_arr
#define ac_gb_load_shndl_arr    		op_sv_ptr->ac_gb_load_shndl_arr
#define ac_gb_throughput_shndl_arr		op_sv_ptr->ac_gb_throughput_shndl_arr
#define ac_internal_coll_shndl_arr		op_sv_ptr->ac_internal_coll_shndl_arr
#define ac_load_bits_shndl_arr  		op_sv_ptr->ac_load_bits_shndl_arr
#define ac_load_pkts_shndl_arr  		op_sv_ptr->ac_load_pkts_shndl_arr
#define ac_queue_size_shndl_arr 		op_sv_ptr->ac_queue_size_shndl_arr
#define ac_queue_status_arr     		op_sv_ptr->ac_queue_status_arr
#define ac_throughput_shndl_arr 		op_sv_ptr->ac_throughput_shndl_arr
#define accept_large_packets    		op_sv_ptr->accept_large_packets
#define accuracyCalculationCounter		op_sv_ptr->accuracyCalculationCounter
#define accuracyCalculationCounter2		op_sv_ptr->accuracyCalculationCounter2
#define accuracyConstant_a      		op_sv_ptr->accuracyConstant_a
#define accuracyConstant_b      		op_sv_ptr->accuracyConstant_b
#define accuracyConstant_c      		op_sv_ptr->accuracyConstant_c
#define aifs_arr                		op_sv_ptr->aifs_arr
#define aifsn_arr               		op_sv_ptr->aifsn_arr
#define ap_conn_handle          		op_sv_ptr->ap_conn_handle
#define ap_connectivity_check_evhndl		op_sv_ptr->ap_connectivity_check_evhndl
#define ap_connectivity_check_interval		op_sv_ptr->ap_connectivity_check_interval
#define ap_connectivity_check_time		op_sv_ptr->ap_connectivity_check_time
#define ap_flag                 		op_sv_ptr->ap_flag
#define AP_Lambda_stat          		op_sv_ptr->AP_Lambda_stat
#define ap_mac_address          		op_sv_ptr->ap_mac_address
#define ap_peer_info_ptr        		op_sv_ptr->ap_peer_info_ptr
#define appRateBits             		op_sv_ptr->appRateBits
#define average_accuracy        		op_sv_ptr->average_accuracy
#define average_distortion      		op_sv_ptr->average_distortion
#define average_stream_DataRate 		op_sv_ptr->average_stream_DataRate
#define b_stat                  		op_sv_ptr->b_stat
#define backoff_ac              		op_sv_ptr->backoff_ac
#define backoff_elapsed_evh     		op_sv_ptr->backoff_elapsed_evh
#define beacon_int              		op_sv_ptr->beacon_int
#define beacon_interval_stat    		op_sv_ptr->beacon_interval_stat
#define beacon_tx_count         		op_sv_ptr->beacon_tx_count
#define beacon_tx_time          		op_sv_ptr->beacon_tx_time
#define bits_load_handle        		op_sv_ptr->bits_load_handle
#define bits_sent_in_the_last_TXOP		op_sv_ptr->bits_sent_in_the_last_TXOP
#define bk_medium_idle_time     		op_sv_ptr->bk_medium_idle_time
#define bss_edca_params_arr     		op_sv_ptr->bss_edca_params_arr
#define bss_flag                		op_sv_ptr->bss_flag
#define bss_id                  		op_sv_ptr->bss_id
#define buffer_drop_bits_handle 		op_sv_ptr->buffer_drop_bits_handle
#define buffer_drop_pkts_handle 		op_sv_ptr->buffer_drop_pkts_handle
#define c_stat                  		op_sv_ptr->c_stat
#define channel_bandwidth       		op_sv_ptr->channel_bandwidth
#define channel_count           		op_sv_ptr->channel_count
#define channel_num             		op_sv_ptr->channel_num
#define channel_spacing         		op_sv_ptr->channel_spacing
#define common_rsmbuf_ptr       		op_sv_ptr->common_rsmbuf_ptr
#define common_seq_count        		op_sv_ptr->common_seq_count
#define completeFrameRecievedFlag		op_sv_ptr->completeFrameRecievedFlag
#define completeFrames          		op_sv_ptr->completeFrames
#define concealedFrames         		op_sv_ptr->concealedFrames
#define config_log_handle       		op_sv_ptr->config_log_handle
#define conn_ap_pos_info_ptr    		op_sv_ptr->conn_ap_pos_info_ptr
#define control_data_rate       		op_sv_ptr->control_data_rate
#define ctrl_traffic_rcvd_handle		op_sv_ptr->ctrl_traffic_rcvd_handle
#define ctrl_traffic_rcvd_handle_inbits		op_sv_ptr->ctrl_traffic_rcvd_handle_inbits
#define ctrl_traffic_sent_handle		op_sv_ptr->ctrl_traffic_sent_handle
#define ctrl_traffic_sent_handle_inbits		op_sv_ptr->ctrl_traffic_sent_handle_inbits
#define cur_tx_ac               		op_sv_ptr->cur_tx_ac
#define current_lambda          		op_sv_ptr->current_lambda
#define current_state_name      		op_sv_ptr->current_state_name
#define current_time            		op_sv_ptr->current_time
#define CVAccuracyA             		op_sv_ptr->CVAccuracyA
#define CVAccuracyC             		op_sv_ptr->CVAccuracyC
#define CVAccuracyI             		op_sv_ptr->CVAccuracyI
#define cw_arr                  		op_sv_ptr->cw_arr
#define cwmax_arr               		op_sv_ptr->cwmax_arr
#define cwmin_arr               		op_sv_ptr->cwmin_arr
#define data_frames_sent_in_the_last_stateREport_int_count		op_sv_ptr->data_frames_sent_in_the_last_stateREport_int_count
#define data_frames_sent_in_the_last_stateREport_int_count_stat		op_sv_ptr->data_frames_sent_in_the_last_stateREport_int_count_stat
#define data_packet_dropped     		op_sv_ptr->data_packet_dropped
#define data_packet_droppedB_in_the_last_stateReport_int_count		op_sv_ptr->data_packet_droppedB_in_the_last_stateReport_int_count
#define data_packet_loaded_in_the_last_stateReport_int_count		op_sv_ptr->data_packet_loaded_in_the_last_stateReport_int_count
#define data_packet_sent_count  		op_sv_ptr->data_packet_sent_count
#define data_packet_sent_count_stat		op_sv_ptr->data_packet_sent_count_stat
#define data_traffic_rcvd_handle		op_sv_ptr->data_traffic_rcvd_handle
#define data_traffic_rcvd_handle_inbits		op_sv_ptr->data_traffic_rcvd_handle_inbits
#define data_traffic_sent_handle		op_sv_ptr->data_traffic_sent_handle
#define data_traffic_sent_handle_inbits		op_sv_ptr->data_traffic_sent_handle_inbits
#define data_tx_rate            		op_sv_ptr->data_tx_rate
#define dataRatePeriodCounter   		op_sv_ptr->dataRatePeriodCounter
#define debug_mode              		op_sv_ptr->debug_mode
#define deference_info_arr      		op_sv_ptr->deference_info_arr
#define defragmentation_list_ptr		op_sv_ptr->defragmentation_list_ptr
#define difs_time               		op_sv_ptr->difs_time
#define directoryName           		op_sv_ptr->directoryName
#define disassociating_sta_lptr 		op_sv_ptr->disassociating_sta_lptr
#define drop_pkt_entry_log_flag 		op_sv_ptr->drop_pkt_entry_log_flag
#define drop_pkt_log_handle     		op_sv_ptr->drop_pkt_log_handle
#define duplicate_entry         		op_sv_ptr->duplicate_entry
#define EA_stat                 		op_sv_ptr->EA_stat
#define EAcounter               		op_sv_ptr->EAcounter
#define EAsum                   		op_sv_ptr->EAsum
#define EDCA_last_DataRate_reset_time		op_sv_ptr->EDCA_last_DataRate_reset_time
#define eifs_time               		op_sv_ptr->eifs_time
#define ete_delay_handle        		op_sv_ptr->ete_delay_handle
#define eval_bss_id             		op_sv_ptr->eval_bss_id
#define expected_frame_type     		op_sv_ptr->expected_frame_type
#define fee_stat                		op_sv_ptr->fee_stat
#define first_chan_min_freq     		op_sv_ptr->first_chan_min_freq
#define frag_threshold          		op_sv_ptr->frag_threshold
#define fragmentation_buffer_arr		op_sv_ptr->fragmentation_buffer_arr
#define frame_timeout_evh       		op_sv_ptr->frame_timeout_evh
#define frameRate               		op_sv_ptr->frameRate
#define frameRate_stat          		op_sv_ptr->frameRate_stat
#define frameRecievedFlag       		op_sv_ptr->frameRecievedFlag
#define frameSizeOfNode         		op_sv_ptr->frameSizeOfNode
#define fresp_ifs_evh           		op_sv_ptr->fresp_ifs_evh
#define fresp_to_send           		op_sv_ptr->fresp_to_send
#define global_buffer_drop_handle		op_sv_ptr->global_buffer_drop_handle
#define global_ete_delay_handle 		op_sv_ptr->global_ete_delay_handle
#define global_load_handle      		op_sv_ptr->global_load_handle
#define global_mac_delay_handle 		op_sv_ptr->global_mac_delay_handle
#define global_network_load_handle		op_sv_ptr->global_network_load_handle
#define global_retrans_handle   		op_sv_ptr->global_retrans_handle
#define global_retx_drop_handle 		op_sv_ptr->global_retx_drop_handle
#define global_throughput_handle		op_sv_ptr->global_throughput_handle
#define hl_packets_rcvd         		op_sv_ptr->hl_packets_rcvd
#define hld_max_size            		op_sv_ptr->hld_max_size
#define hld_pmh                 		op_sv_ptr->hld_pmh
#define hlpk_lptr_arr           		op_sv_ptr->hlpk_lptr_arr
#define i_strm                  		op_sv_ptr->i_strm
#define imageName               		op_sv_ptr->imageName
#define imageNo                 		op_sv_ptr->imageNo
#define importance              		op_sv_ptr->importance
#define importance_stat         		op_sv_ptr->importance_stat
#define incompleteFrames        		op_sv_ptr->incompleteFrames
#define incrementCounter        		op_sv_ptr->incrementCounter
#define instrm_from_mac_if      		op_sv_ptr->instrm_from_mac_if
#define intrpt_code             		op_sv_ptr->intrpt_code
#define intrpt_time             		op_sv_ptr->intrpt_time
#define intrpt_type             		op_sv_ptr->intrpt_type
#define lambda_stat             		op_sv_ptr->lambda_stat
#define last_calculated_average_TXOP_displasement		op_sv_ptr->last_calculated_average_TXOP_displasement
#define last_calculated_droppedB_prob		op_sv_ptr->last_calculated_droppedB_prob
#define last_DataRate_reset_time		op_sv_ptr->last_DataRate_reset_time
#define last_DataRate_reset_time2		op_sv_ptr->last_DataRate_reset_time2
#define last_DataRate_reset_time_PERIODIC		op_sv_ptr->last_DataRate_reset_time_PERIODIC
#define last_my_droppedB_calculated_time		op_sv_ptr->last_my_droppedB_calculated_time
#define last_my_droppedR_calculated_time		op_sv_ptr->last_my_droppedR_calculated_time
#define last_my_load_calculated_time		op_sv_ptr->last_my_load_calculated_time
#define last_my_sent_calculated_time		op_sv_ptr->last_my_sent_calculated_time
#define last_rcvd_duration      		op_sv_ptr->last_rcvd_duration
#define last_sent_averageProtocolOverhead		op_sv_ptr->last_sent_averageProtocolOverhead
#define last_sent_droppedBRate  		op_sv_ptr->last_sent_droppedBRate
#define last_sent_droppedRRate  		op_sv_ptr->last_sent_droppedRRate
#define last_sent_loadRate      		op_sv_ptr->last_sent_loadRate
#define last_sent_physicalRate  		op_sv_ptr->last_sent_physicalRate
#define last_sent_protocolOverheadRate		op_sv_ptr->last_sent_protocolOverheadRate
#define last_sent_sentRate      		op_sv_ptr->last_sent_sentRate
#define last_sent_video_frame_size		op_sv_ptr->last_sent_video_frame_size
#define last_sent_video_frame_size_without_header		op_sv_ptr->last_sent_video_frame_size_without_header
#define last_sent_video_frame_time		op_sv_ptr->last_sent_video_frame_time
#define last_tx_frtype_arr      		op_sv_ptr->last_tx_frtype_arr
#define last_TXOP_start_time    		op_sv_ptr->last_TXOP_start_time
#define lastFrameN              		op_sv_ptr->lastFrameN
#define lastFrameSizeInPackets  		op_sv_ptr->lastFrameSizeInPackets
#define lastImageLineNumber     		op_sv_ptr->lastImageLineNumber
#define lastPacketN             		op_sv_ptr->lastPacketN
#define lastQ                   		op_sv_ptr->lastQ
#define linesIndex              		op_sv_ptr->linesIndex
#define llc_iciptr              		op_sv_ptr->llc_iciptr
#define long_retry_limit        		op_sv_ptr->long_retry_limit
#define LoopSum_stat            		op_sv_ptr->LoopSum_stat
#define lostPackets             		op_sv_ptr->lostPackets
#define lostPacketsCounter      		op_sv_ptr->lostPacketsCounter
#define lrc_arr                 		op_sv_ptr->lrc_arr
#define Ls                      		op_sv_ptr->Ls
#define mac_appRate_stat        		op_sv_ptr->mac_appRate_stat
#define mac_client_reassembly_buffer		op_sv_ptr->mac_client_reassembly_buffer
#define mapping_info_mutex      		op_sv_ptr->mapping_info_mutex
#define max_frags_per_msdu      		op_sv_ptr->max_frags_per_msdu
#define max_operational_speed   		op_sv_ptr->max_operational_speed
#define max_operational_speed_stat		op_sv_ptr->max_operational_speed_stat
#define max_receive_lifetime    		op_sv_ptr->max_receive_lifetime
#define maxLoad                 		op_sv_ptr->maxLoad
#define maxLoad_stat            		op_sv_ptr->maxLoad_stat
#define media_access_delay      		op_sv_ptr->media_access_delay
#define mgmt_retx_drop_bits_handle		op_sv_ptr->mgmt_retx_drop_bits_handle
#define mgmt_retx_drop_pkts_handle		op_sv_ptr->mgmt_retx_drop_pkts_handle
#define mgmt_traffic_rcvd_handle		op_sv_ptr->mgmt_traffic_rcvd_handle
#define mgmt_traffic_rcvd_handle_inbits		op_sv_ptr->mgmt_traffic_rcvd_handle_inbits
#define mgmt_traffic_sent_handle		op_sv_ptr->mgmt_traffic_sent_handle
#define mgmt_traffic_sent_handle_inbits		op_sv_ptr->mgmt_traffic_sent_handle_inbits
#define missedFrames            		op_sv_ptr->missedFrames
#define mpdu_retx_copy_arr      		op_sv_ptr->mpdu_retx_copy_arr
#define my_address              		op_sv_ptr->my_address
#define my_bss_info_ptr         		op_sv_ptr->my_bss_info_ptr
#define my_droppedB_stat        		op_sv_ptr->my_droppedB_stat
#define my_droppedB_sum         		op_sv_ptr->my_droppedB_sum
#define my_droppedR_stat        		op_sv_ptr->my_droppedR_stat
#define my_droppedR_sum         		op_sv_ptr->my_droppedR_sum
#define my_load_stat            		op_sv_ptr->my_load_stat
#define my_load_sum             		op_sv_ptr->my_load_sum
#define my_node_objid           		op_sv_ptr->my_node_objid
#define my_objid                		op_sv_ptr->my_objid
#define my_sent_stat            		op_sv_ptr->my_sent_stat
#define my_sent_sum             		op_sv_ptr->my_sent_sum
#define my_subnet_objid         		op_sv_ptr->my_subnet_objid
#define myDataRates             		op_sv_ptr->myDataRates
#define MyExcecutionTrace       		op_sv_ptr->MyExcecutionTrace
#define MyExcecutionTracename   		op_sv_ptr->MyExcecutionTracename
#define nav_duration            		op_sv_ptr->nav_duration
#define nav_end_evh             		op_sv_ptr->nav_end_evh
#define nav_reset_evh           		op_sv_ptr->nav_reset_evh
#define new_variable            		op_sv_ptr->new_variable
#define num_fragments_arr       		op_sv_ptr->num_fragments_arr
#define number_of_stations      		op_sv_ptr->number_of_stations
#define number_of_TXOP_in_calculation_period		op_sv_ptr->number_of_TXOP_in_calculation_period
#define numberOfInputDataRates  		op_sv_ptr->numberOfInputDataRates
#define oms_aa_handle           		op_sv_ptr->oms_aa_handle
#define operational_speed       		op_sv_ptr->operational_speed
#define Os                      		op_sv_ptr->Os
#define outstrm_to_mac_if       		op_sv_ptr->outstrm_to_mac_if
#define own_ac_edca_params_objid		op_sv_ptr->own_ac_edca_params_objid
#define own_process_record_handle		op_sv_ptr->own_process_record_handle
#define packet_data_percent_stat		op_sv_ptr->packet_data_percent_stat
#define packet_load_handle      		op_sv_ptr->packet_load_handle
#define packet_size_stat        		op_sv_ptr->packet_size_stat
#define packetCounter           		op_sv_ptr->packetCounter
#define peer_info_hash_tbl      		op_sv_ptr->peer_info_hash_tbl
#define peerAddress             		op_sv_ptr->peerAddress
#define peerStreamAccuracy      		op_sv_ptr->peerStreamAccuracy
#define peerStreamAccuracy2     		op_sv_ptr->peerStreamAccuracy2
#define peerStreamAccuracyError 		op_sv_ptr->peerStreamAccuracyError
#define peerStreamAccuracyError2		op_sv_ptr->peerStreamAccuracyError2
#define peerStreamData          		op_sv_ptr->peerStreamData
#define peerStreamData2         		op_sv_ptr->peerStreamData2
#define peerStreamDataForRate   		op_sv_ptr->peerStreamDataForRate
#define peerStreamDataForRate2  		op_sv_ptr->peerStreamDataForRate2
#define peerStreamDataRate      		op_sv_ptr->peerStreamDataRate
#define peerStreamDataRate2     		op_sv_ptr->peerStreamDataRate2
#define peerStreamDistortion    		op_sv_ptr->peerStreamDistortion
#define peerStreamDistortion2   		op_sv_ptr->peerStreamDistortion2
#define phy_char_flag           		op_sv_ptr->phy_char_flag
#define phy_cw_max              		op_sv_ptr->phy_cw_max
#define phy_cw_min              		op_sv_ptr->phy_cw_min
#define phy_type                		op_sv_ptr->phy_type
#define physicalRate            		op_sv_ptr->physicalRate
#define physicalRate_readfromtransmiter_stat		op_sv_ptr->physicalRate_readfromtransmiter_stat
#define physicalRate_stat       		op_sv_ptr->physicalRate_stat
#define pkt_seq_cntl_arr        		op_sv_ptr->pkt_seq_cntl_arr
#define plcp_overhead_control   		op_sv_ptr->plcp_overhead_control
#define plcp_overhead_data      		op_sv_ptr->plcp_overhead_data
#define pruning_percent         		op_sv_ptr->pruning_percent
#define rcv_idle_time           		op_sv_ptr->rcv_idle_time
#define rcvd_bar_tid            		op_sv_ptr->rcvd_bar_tid
#define rcvd_frame_drate        		op_sv_ptr->rcvd_frame_drate
#define receive_time            		op_sv_ptr->receive_time
#define received_beacon_count   		op_sv_ptr->received_beacon_count
#define received_beacon_count_stat		op_sv_ptr->received_beacon_count_stat
#define received_RTS_count      		op_sv_ptr->received_RTS_count
#define received_RTS_count_stat 		op_sv_ptr->received_RTS_count_stat
#define received_stateReport_count		op_sv_ptr->received_stateReport_count
#define received_stateReport_count_stat		op_sv_ptr->received_stateReport_count_stat
#define receivedPacketTrace     		op_sv_ptr->receivedPacketTrace
#define rem_beacon_tx           		op_sv_ptr->rem_beacon_tx
#define remainder_size_arr      		op_sv_ptr->remainder_size_arr
#define response_sta_addr       		op_sv_ptr->response_sta_addr
#define retrans_handle          		op_sv_ptr->retrans_handle
#define retx_drop_bits_handle   		op_sv_ptr->retx_drop_bits_handle
#define retx_drop_pkts_handle   		op_sv_ptr->retx_drop_pkts_handle
#define roam_state_ptr          		op_sv_ptr->roam_state_ptr
#define rts_threshold           		op_sv_ptr->rts_threshold
#define rx_objid                		op_sv_ptr->rx_objid
#define rx_power_threshold      		op_sv_ptr->rx_power_threshold
#define rx_state_info_ptr       		op_sv_ptr->rx_state_info_ptr
#define rxch_objid              		op_sv_ptr->rxch_objid
#define sent_beacon_count       		op_sv_ptr->sent_beacon_count
#define sent_beacon_count_stat  		op_sv_ptr->sent_beacon_count_stat
#define sent_stateReport_count  		op_sv_ptr->sent_stateReport_count
#define sent_stateReport_count_stat		op_sv_ptr->sent_stateReport_count_stat
#define sentPacketTrace         		op_sv_ptr->sentPacketTrace
#define served_pk_id_arr        		op_sv_ptr->served_pk_id_arr
#define short_retry_limit       		op_sv_ptr->short_retry_limit
#define sifs_time               		op_sv_ptr->sifs_time
#define sizes                   		op_sv_ptr->sizes
#define slot_time               		op_sv_ptr->slot_time
#define src_arr                 		op_sv_ptr->src_arr
#define start_times             		op_sv_ptr->start_times
#define stateReport_int         		op_sv_ptr->stateReport_int
#define stateReport_tx_time     		op_sv_ptr->stateReport_tx_time
#define stateReportStarted      		op_sv_ptr->stateReportStarted
#define sumD_stat               		op_sv_ptr->sumD_stat
#define tc_config_arr           		op_sv_ptr->tc_config_arr
#define temp_ph_rate            		op_sv_ptr->temp_ph_rate
#define tempAccuracy            		op_sv_ptr->tempAccuracy
#define tempFrameSize           		op_sv_ptr->tempFrameSize
#define throughput_handle       		op_sv_ptr->throughput_handle
#define total_ba_reorder_buf_size		op_sv_ptr->total_ba_reorder_buf_size
#define total_bits_sent_in_the_last_TXOP		op_sv_ptr->total_bits_sent_in_the_last_TXOP
#define total_data_header_size_sent		op_sv_ptr->total_data_header_size_sent
#define total_data_sent         		op_sv_ptr->total_data_sent
#define total_data_size_sent_without_headers		op_sv_ptr->total_data_size_sent_without_headers
#define total_hlpk_num          		op_sv_ptr->total_hlpk_num
#define total_hlpk_size         		op_sv_ptr->total_hlpk_size
#define total_reorder_size_handle		op_sv_ptr->total_reorder_size_handle
#define totalDataResetedFalg    		op_sv_ptr->totalDataResetedFalg
#define totalDataResetedFalgArray		op_sv_ptr->totalDataResetedFalgArray
#define totalFrames             		op_sv_ptr->totalFrames
#define totalPeerStreamData     		op_sv_ptr->totalPeerStreamData
#define totalPeerStreamData2    		op_sv_ptr->totalPeerStreamData2
#define trimmedAccuracyCounter  		op_sv_ptr->trimmedAccuracyCounter
#define trimmedAccuracyCounter2 		op_sv_ptr->trimmedAccuracyCounter2
#define tx_objid                		op_sv_ptr->tx_objid
#define txch_objid              		op_sv_ptr->txch_objid
#define txframe_type            		op_sv_ptr->txframe_type
#define TXOP_counter            		op_sv_ptr->TXOP_counter
#define TXOP_displasement_stat  		op_sv_ptr->TXOP_displasement_stat
#define TXOP_displasement_total 		op_sv_ptr->TXOP_displasement_total
#define txop_limit_arr          		op_sv_ptr->txop_limit_arr
#define txop_start_time         		op_sv_ptr->txop_start_time
#define video_TXOP_stat         		op_sv_ptr->video_TXOP_stat
#define weighted_accuracy_sum   		op_sv_ptr->weighted_accuracy_sum
#define wlan_ac_flags           		op_sv_ptr->wlan_ac_flags
#define wlan_flags              		op_sv_ptr->wlan_flags
#define wlan_trace_active       		op_sv_ptr->wlan_trace_active

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wlan_mac_hcf_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wlan_mac_hcf_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

static void
wlan_hcf_sv_init (void)
	{
	Objid					mac_params_comp_attr_objid, hcf_params_objid;
	Objid					params_attr_objid;
	Objid					chann_objid;
	Objid					comp_attr_objid;
	int						num_chann;
	Boolean					data_rate_11b;
	double					tx_power;
	int						i;
	Objid					statwire_objid;
	int						num_statwires;
	double					threshold;
	double					rx_power_threshold_dbm;
	void*                   temp_ptr;
	int						roaming_cap_flag, cts_to_self_flag;
	Evhandle				invalid_evh = OPC_EV_HANDLE_INVALID;
	int						advertise_edca_params;
	char					stat_info [16];
	int						integer_mac_address = -1;
	
	/**	1. Initialize state variables.						**/
	/** 2. Read model attribute values in variables.	    **/
	/** 3. Create global lists								**/
	/** 4. Register statistics handlers						**/
	
	FIN (wlan_hcf_sv_init (void));

	/* Object id of the surrounding processor.				*/
	my_objid = op_id_self ();

	/* Obtain the node's object identifier					*/
	my_node_objid = op_topo_parent (my_objid);
	
	
	
	/* Obtain subnet objid.									*/
	my_subnet_objid = op_topo_parent (my_node_objid);

	/* Obtain the values assigned to the various attributes	*/
	op_ima_obj_attr_get (my_objid, "Wireless LAN Parameters", &mac_params_comp_attr_objid);
    params_attr_objid = op_topo_child (mac_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);

	/* Determine the assigned MAC address.					*/
	op_ima_obj_attr_get (my_objid, "Address", &integer_mac_address);
	my_address = integer_mac_address;
	
	
		
	/* Obtain an address handle for resolving WLAN MAC addresses.				*/
	oms_aa_handle = oms_aa_address_handle_get ("MAC Addresses", "Address");

 	/* Obtain the BSS_Id attribute to determine if BSS based network is used	*/ 
	op_ima_obj_attr_get (params_attr_objid, "BSS Identifier", &bss_id);
	
	/* Register the log handles and related flags.								*/
	config_log_handle	= op_prg_log_handle_create (OpC_Log_Category_Configuration, "Wireless LAN", "MAC Configuration", 128);
	drop_pkt_log_handle	= op_prg_log_handle_create (OpC_Log_Category_Protocol,      "Wireless LAN", "Data packet Drop",  128);
    drop_pkt_entry_log_flag = 0;

	/* Update the global variable if this is the first node to come up. If not the	*/ 
	/* first node, then check for mismatches. A subnet can be a traditional subnet	*/
	/* (i.e. a subnet with one BSS, this is the existing model) or a  BSS based		*/
	/* subnet where for every node the attribute BSS_Id is set to indicate to which */
	/* BSS a node belongs. If the global is set to traditional subnet and the this	*/
	/* node has its BSS_Id attribute set then log a warning message and recover		*/
	/* by considering the BSS_Id attribute setting as not used. If the global is	*/
	/* set to BSS based subnet and this node is not using its BSS_Id attribute 		*/
	/* then log an error message and stop the simulation.					 		*/
	if (bss_id_type == WlanC_Not_Set)
		{
		if (bss_id ==  WLANC_BSSID_NOT_USED)
			{
			bss_id_type = WlanC_Entire_Subnet ;
			}
		else
			{
			bss_id_type = WlanC_Bss_Divided_Subnet ;
			}
		}
	
		
	/* Configuration error checking */
	if (bss_id_type == WlanC_Entire_Subnet && bss_id != WLANC_BSSID_NOT_USED)
		{
		/* Recoverable mismatch, log warning and continue by enforcing			*/
		/* traditional subnet, i.e. force the bss_id variable to not used.		*/

		/* Write the warning message.											*/
		op_prg_log_entry_write (config_log_handle,
			"WARNING:\n"
			" A node with an explicit BSS\n"
			" assignment was found in a network\n"
			" containing WLAN nodes with auto-\n"
			" assigned BSS identifiers.\n"
			"ACTION:\n"
			" The BSS identifier is set to\n"
			" the default value \"Auto Assigned\".\n"
			"CAUSE:\n"
			" There are some nodes in the\n"
			" network which have their BSS\n"
			" identifiers set explicitly\n"
			" while the others have the\n"
			" default \"Auto Assigned\" setting.\n"
			"SUGGESTION:\n"
			" Ensure that all nodes have their\n"
			" BSS identifier either set to the\n"
			" default value or explicitly\n"
			" assigned.\n");
		}

		
	else if (bss_id_type == WlanC_Bss_Divided_Subnet && bss_id == WLANC_BSSID_NOT_USED)
		{
		/* Unrecoverable error-- not all BSS IDs have been configured.		*/
		/* Cannot guess what the BSS ID should be, hence terminate.			*/

		wlan_error_print ("BSS ID not set in a node which belongs to a network in which some BSS IDs are set", 
						  "Please set a non-default BSS ID on all nodes in the network", OPC_NIL);
		}


	/* Use the subnet ID as the BSS ID if it is set to "Auto Assigned".		*/
	if (bss_id_type == WlanC_Entire_Subnet)
		{
		bss_id = my_subnet_objid;
		}

   	/* Get model attributes.												*/
	op_ima_obj_attr_get (params_attr_objid, "Data Rate", &data_tx_rate);//will be overritten by the code below
	op_ima_obj_attr_get (params_attr_objid, "Fragmentation Threshold", &frag_threshold);
	op_ima_obj_attr_get (params_attr_objid, "Rts Threshold", &rts_threshold);
	op_ima_obj_attr_get (params_attr_objid, "Short Retry Limit", &short_retry_limit);
	op_ima_obj_attr_get (params_attr_objid, "Long Retry Limit", &long_retry_limit);
	op_ima_obj_attr_get (params_attr_objid, "Access Point Functionality", &ap_flag);	
	op_ima_obj_attr_get (params_attr_objid, "AP Beacon Interval", &beacon_int);
	
	op_ima_obj_attr_get (params_attr_objid, "State Report Interval", &stateReport_int);
	
	
	op_ima_obj_attr_get (params_attr_objid, "Buffer Size", &hld_max_size);
	op_ima_obj_attr_get (params_attr_objid, "Max Receive Lifetime", &max_receive_lifetime);
	op_ima_obj_attr_get (params_attr_objid, "Large Packet Processing", &accept_large_packets);
	
	
	if(myStringDebug)
		{
		sprintf(myString,"I am  %d: importance of %d is initialized to %f",(int)my_address,(int)my_address, importance);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	
	
	/* If specified, convert the fragmentation and RTS thresholds to bits.	*/
	if (frag_threshold != -1)
		frag_threshold *= 8;
	if (rts_threshold != -1)
		rts_threshold *= 8;
	
	/* Compute the maximum expected numbers of fragments per MSDU.			*/
	// ceil edited by Loren to match the correct type casting for C++.
	max_frags_per_msdu = (frag_threshold != -1) ? (int) ceil ((double)WLANC_MAXMSDU_LENGTH / (double)frag_threshold) : 1;
	
	/* Check whether beacon transmission efficiency is enabled.				*/
	op_ima_sim_attr_get (OPC_IMA_INTEGER, "WLAN Beacon Transmission Count", &beacon_tx_count);
	
			
	//mohammad: get the bandwidth allocation scheme and pruning information
	op_ima_sim_attr_get_str("Bnadwidth Allocation Method",100, tempBnadwidth_allocation_method);
	tempBnadwidth_allocation_method[100]='\0';
	
	sprintf(bnadwidth_allocation_method,"%s","EDCA");//Start with EDCA for EA ESTIMATION
	
	
	op_ima_sim_attr_get_int32("Network Size",&nodes_no);
	
	
	if(ap_flag == OPC_BOOLINT_ENABLED && 
		(strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0 || strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD")==0
		|| strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")==0||strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")==0))
		{
		
		//create dynamic arrays that depends on nodes_no
	
		fees = (float*) calloc (nodes_no+1,sizeof(float)); 
		Y = (float*) calloc (nodes_no+1,sizeof(float));
		D = (float*) calloc (nodes_no+1,sizeof(float));
		T = (float*) calloc (nodes_no+1,sizeof(float));
		W = (float*) calloc (nodes_no+1,sizeof(float));
		TXOP = (float*) calloc (nodes_no+1,sizeof(float));
		
		}
	
	
	//moved from init state
			
	if((int)my_address !=0)  //Read data rates input file
		{
		FILE* dataRatesInputFile;
		char tempInputLine[20];
		char dataRatesInputFileName[200];

		
		sprintf(myString,"I am  %d: trying to construct file name\n",(int)my_address);
		op_prg_odb_print_major(myString,OPC_NIL);
				
		sprintf(dataRatesInputFileName,"C:/opnetInputFiles/%d/node%d_ph.txt",(int)nodes_no,(int)my_address);
		
		sprintf(myString,"I am  %d: input file name to read is constructed and it is %s\n I will try to open the file next",(int)my_address,dataRatesInputFileName);
		op_prg_odb_print_major(myString,OPC_NIL);
				
		
		dataRatesInputFile = fopen(dataRatesInputFileName,"r");
		
		if(dataRatesInputFile != NULL)
			{
			sprintf(myString,"I am  %d: rate file was opened successfully for read",(int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		else
			{
			sprintf(myString,"I am  %d: rate file was unsuccessfully opened for read",(int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			}

		fgets(tempInputLine, 10,dataRatesInputFile);  
		numberOfInputDataRates = atoi(tempInputLine);
		
		myDataRates = (double*) calloc (numberOfInputDataRates,sizeof(double));		
		
		for(linesIndex = 0 ; linesIndex < numberOfInputDataRates; linesIndex ++)
			{
			fgets(tempInputLine, 10,dataRatesInputFile);   
			myDataRates[linesIndex] = atoi(tempInputLine);
			}
		
		fclose(dataRatesInputFile);
		
		for(linesIndex = 1 ; linesIndex < numberOfInputDataRates; linesIndex ++)//set times to change the operational speed
			{
			op_intrpt_schedule_self (floor(linesIndex*simulationTime/numberOfInputDataRates), WlanC_OperationalSpeed_Change);
			}
		
		
		
		data_tx_rate = myDataRates[0];
		physicalRate = data_tx_rate;
		
		sprintf(myString,"I am  %d: data_tx_rate is read as %d",(int)my_address,(int)data_tx_rate);
		op_prg_odb_print_major(myString,OPC_NIL);
		
		//operational_speed = data_tx_rate;
		last_sent_physicalRate = data_tx_rate;
		dataRatePeriodCounter = 1;
	
		}
	
	physicalRate = data_tx_rate;
	sprintf(myString,"I am  %d: physicalRate is %d",(int)my_address, (int)physicalRate);
	op_prg_odb_print_major(myString,OPC_NIL);
		
	
	//initialize app rate
	appRateBits = data_tx_rate / nodes_no;
	op_stat_write (mac_appRate_stat, appRateBits);
					
		
	if((int)my_address !=0 )  //Read importance input file
		{
		FILE * importanceFile;
		char importanceFileName[500];
		char tempInputLine[20];

		
		if(myStringDebug)
			{
			sprintf(myString,"I am  %d: trying to construct file name\n",(int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		
		sprintf(importanceFileName,"C:/opnetInputFiles/%d/node%d_importance.txt",nodes_no,(int)my_address);

		if(myStringDebug)
		{
		sprintf(myString,"I am  %d: input file name to read is constructed and it is %s\n I will try to open the file next",(int)my_address,importanceFileName);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
		
		
		importanceFile = fopen(importanceFileName,"r");
	
		if(myStringDebug)
			{

			if(importanceFile != NULL)
				{
		
		
				sprintf(myString,"I am  %d: input file input file was opened successfully for read",(int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
		
			else
				{
				sprintf(myString,"I am  %d: input file input file was opened unsuccessfully for read",(int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
			}

		fgets(tempInputLine, 10,importanceFile);  
		importance = atof(tempInputLine);

		fclose(importanceFile);
	
		}	
	else
		{
		importance = op_dist_uniform (100) ;
		}
			
	if(strcmp(tempBnadwidth_allocation_method,"matlabOptimization_accu")==0 || strcmp(tempBnadwidth_allocation_method,"matlabOptimization_accuD")==0
		||strcmp(tempBnadwidth_allocation_method,"matlabOptimization_dist")==0||strcmp(tempBnadwidth_allocation_method,"matlabOptimization_wdist")==0)
		{

		fees[(int)my_address] = 1.0/nodes_no;
		TXOP[(int)my_address] = txop_limit_arr[WlanC_AC_VI];
		Y[(int)my_address] = operational_speed/1024.0/1024.0/8.0;
		W[(int)my_address] = importance;
		D[(int)my_address] = 0;
		}
			
		
	if(strcmp(tempBnadwidth_allocation_method,"accu_H")==0 || strcmp(tempBnadwidth_allocation_method,"accu_D")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_D")==0||strcmp(tempBnadwidth_allocation_method,"wdis_D")==0|| strcmp(tempBnadwidth_allocation_method,"accu_link_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_app_D")==0)
		op_stat_write (mac_appRate_stat, (double)importance * operational_speed/2.0);
	//// end of moved from init state	
	
	
	
	op_ima_sim_attr_get_int32("Pruning Flag",&pruning_flag);
	
	op_ima_sim_attr_get_dbl("Pruning Percent",&pruning_percent);
	op_ima_sim_attr_get_dbl("TXOP Interval",&TXOPinterval);


	if(myStringDebug)
		{
	sprintf(myString,"I am  %d: interval %f is to be used",(int)my_address,TXOPinterval);
	op_prg_odb_print_major(myString,OPC_NIL);
	}

	op_ima_sim_attr_get_str("curve",100, curve);
	curve[100]='\0';
	
	if(myStringDebug)
		{
	sprintf(myString,"I am  %d: curve %sis to be used",(int)my_address,curve);
	op_prg_odb_print_major(myString,OPC_NIL);
	}
	
	//create data output file
	if(myDataFileGenerationFlag == 1)
	{
		if(myStringDebug)
		{
			sprintf(myString,"I am  %d: interval %f is to be used",(int)my_address,TXOPinterval);
			op_prg_odb_print_major(myString,OPC_NIL);
		}
		if(pruning_flag == 1)
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\%d_%s_%s_traceFile_node_%d_pf%d_pp%2.2f_TI%1.2f.txt",nodes_no,curve,tempBnadwidth_allocation_method,(int)my_address,(int)pruning_flag,(float)pruning_percent,(float)TXOPinterval);
		else
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\%d_%s_%s_traceFile_node_%d_pf%d_TI%1.2f_BS%d.txt",nodes_no,curve,tempBnadwidth_allocation_method,(int)my_address,(int)pruning_flag,(float)TXOPinterval,(int)hld_max_size/1000);
		
		//Loren
		op_prg_odb_print_major(MyExcecutionTracename,OPC_NIL);
		
		MyExcecutionTrace = fopen(MyExcecutionTracename,"w");
		fclose(MyExcecutionTrace);
	}
	
	
	/* Load the appropriate physical layer characteristics.					*/	
	op_ima_obj_attr_get (params_attr_objid, "Physical Characteristics", &phy_char_flag);
	

	/* Obtain the receiver valid packet power threshold value used by the	*/
	/* statwires from the receiver into the MAC module.						*/
	op_ima_obj_attr_get (params_attr_objid, "Packet Reception-Power Threshold", &rx_power_threshold_dbm);
	
	
	/* Convert the power threshold (receiver sensitivity) value from dBm to	*/
	/* Watts.																*/
	rx_power_threshold = pow (10.0, rx_power_threshold_dbm / 10.0) / 1000.0;
	
	
	/* Get the transmission power value in Watts.							*/
	op_ima_obj_attr_get (params_attr_objid, "Transmit Power", &tx_power);	

	/* Make sure that the configured data rate is compatible with the		*/
	/* physical layer technology.											*/
	data_rate_11b = (data_tx_rate < 6000000.0 || data_tx_rate == 11000000.0) ? OPC_TRUE : OPC_FALSE;
	if ((phy_char_flag == WlanC_OFDM_11a && data_rate_11b) || 
		(phy_char_flag != WlanC_OFDM_11a && phy_char_flag != WlanC_ERP_OFDM_11g && !data_rate_11b)) 
		{
		/* Mismatching data rate <-> physical layer technology. Write a 	*/
		/* simulation log message.											*/
		op_prg_log_entry_write (config_log_handle,
			"ERROR:\n"
			" The WLAN data rate %.1f Mbps configured \n"
			" for this node cannot be supported with \n"
			" the specified physical layer technology.\n"
			"\n"	
			"REMEDIAL ACTION:\n"
			" The operational data rate is set to\n"
			" %.1f Mbps to be compatible with the\n"
			" physical layer configuration.\n"
			"\n"	
			"SUGGESTION:\n"
			" Ensure that the \"Wireless LAN Parameters ->\n"
			" Physical Characteristics\" attribute is set\n"
			" properly to support the configured WLAN data\n"
			" rate according to the corresponding WLAN\n"
			" standard.\n", data_tx_rate / 1000000.0, 
			((phy_char_flag == WlanC_OFDM_11a) ? WLANC_11a_MIN_MANDATORY_DRATE : WLANC_11b_MIN_MANDATORY_DRATE) / 1000000.0);
		
		/* Set the data rate to the minimum data rate of the specified		*/
		/* physical layer technology.										*/
		data_tx_rate = (phy_char_flag == WlanC_OFDM_11a) ? WLANC_11a_MIN_MANDATORY_DRATE : WLANC_11b_MIN_MANDATORY_DRATE;
		//Loren
		//sprintf(myString,"I am 16");
		//op_prg_odb_print_major(myString,OPC_NIL);
		}
		
	/* Initialize our current data transmission rate with the configured	*/
	/* value.																*/
	operational_speed = data_tx_rate;

	/* Based on physical characteristics settings set appropriate values to	*/
	/* the variables.														*/
	switch (phy_char_flag)
		{
		case WlanC_Frequency_Hopping:
			{
			/* Slot duration in terms of seconds.							*/
			slot_time = 50E-06;

			/* Short interframe gap in terms of seconds.					*/
			sifs_time = 28E-06;
			
			/* PLCP overheads, which include the preamble and header, in	*/
			/* terms of seconds.											*/
			plcp_overhead_control = WLANC_PLCP_OVERHEAD_FHSS;
			plcp_overhead_data    = WLANC_PLCP_OVERHEAD_FHSS;
			
			/* Minimum contention window size for selecting backoff slots.	*/
			phy_cw_min = 15;

			/* Maximum contention window size for selecting backoff slots.	*/
			phy_cw_max = 1023;
			
			/* Set the PHY standard as 11b for the technologies specified	*/
			/* in 802.11 and 802.11b.										*/
			phy_type = WlanC_11b_PHY;
			break;
			}

		case WlanC_Direct_Sequence:
			{
			/* Slot duration in terms of seconds.							*/
			slot_time = 20E-06;

			/* Short interframe gap in terms of seconds.					*/
			sifs_time = 10E-06;

			/* PLCP overheads, which include the preamble and header, in	*/
			/* terms of seconds.											*/
			plcp_overhead_control = WLANC_PLCP_OVERHEAD_DSSS_LONG;
			plcp_overhead_data    = WLANC_PLCP_OVERHEAD_DSSS_LONG;
			
			/* Minimum contention window size for selecting backoff slots.	*/
			phy_cw_min = 31;

			/* Maximum contention window size for selecting backoff slots.	*/
			phy_cw_max = 1023;
			
			/* Set the PHY standard as 11b for the technologies specified	*/
			/* in 802.11 and 802.11b.										*/
			phy_type = WlanC_11b_PHY;
			
			max_operational_speed = 11000000;
			//max_operational_speed = 1000000;//set to minimum
			//max_operational_speed = 5500000;
			break;
			}

		case WlanC_Infra_Red:
			{
			/* Slot duration in terms of seconds.							*/
			slot_time = 8E-06;

			/* Short interframe gap in terms of seconds (this is changed	*/
			/* from 7 usec (IEEE 802.11 1997 Edition) to 10 usec (IEEE		*/
			/* 802.11 1999 Edition).										*/
			sifs_time = 10E-06;

			/* PLCP overheads, which include the preamble and header, in	*/
			/* terms of seconds. Infra-red supports transmission of parts	*/
			/* of the PLCP header at the regular data transmission rate,	*/
			/* which can be higher than mandatory lowest data rate.			*/
			plcp_overhead_control = WLANC_PLCP_OVERHEAD_IR_1MBPS;
			plcp_overhead_data    = (data_tx_rate == 1000000.0) ? WLANC_PLCP_OVERHEAD_IR_1MBPS : WLANC_PLCP_OVERHEAD_IR_2MBPS;
	  
			/* Minimum contention window size for selecting backoff slots.	*/
			phy_cw_min = 63;

			/* Maximum contention window size for selecting backoff slots.	*/
			phy_cw_max = 1023;
			
			/* Set the PHY standard as 11b for the technologies specified	*/
			/* in 802.11 and 802.11b.										*/
			phy_type = WlanC_11b_PHY;
			break;
			}

		case WlanC_OFDM_11a:
			{
			/* Slot duration in terms of seconds.							*/
			slot_time = 9E-06;

			/* Short interframe gap in terms of seconds.					*/
			sifs_time = 16E-06;

			/* PLCP overheads, which include the preamble and header, in	*/
			/* terms of seconds. For OFDM (11a), these overheads don't		*/
			/* include the bits of the PLCP header fields "SERVICE", "Tail"	*/
			/* and "Pad". The overhead of these fields will be computed		*/
			/* when the size of the MAC layer's packet (MPDU) is known.		*/
			plcp_overhead_control = WLANC_PLCP_OVERHEAD_OFDM;
			plcp_overhead_data    = WLANC_PLCP_OVERHEAD_OFDM;
	  
			/* Minimum contention window size for selecting backoff slots.	*/
			phy_cw_min = 15;

			/* Maximum contention window size for selecting backoff slots.	*/
			phy_cw_max = 1023;
			
			/* Set the PHY standard.										*/
			phy_type = WlanC_11a_PHY;
			
			max_operational_speed = 54000000;
			//max_operational_speed = 6000000;//set to minimum
			//max_operational_speed = 24000000;//set to average
			break;
			}

		case WlanC_ERP_OFDM_11g:
			{			
			/* Set the slot time to 9E-6 seconds (short) initially. We will	*/
			/* increase it to 20 usec (long) if we detect that we operate	*/
			/* in an IBSS or in a BSS that also has non-ERP STAs associated.*/
			slot_time = 9E-06;

			/* Short interframe gap in terms of seconds.					*/
			sifs_time = 10E-06;

			/* PLCP overheads, which include the preamble and header, in	*/
			/* terms of seconds. Assume ERP-OFDM preamble. We will adjust	*/
			/* the overhead amount if regular long or short DSSS preambles	*/
			/* are used.													*/
			plcp_overhead_control = WLANC_PLCP_OVERHEAD_OFDM;
			plcp_overhead_data    = WLANC_PLCP_OVERHEAD_OFDM;
			
			/* Minimum contention window size for selecting backoff slots.	*/
			/* Initially we pick the lower CWmin and increase it to 31 if	*/
			/* we operate in an IBSS containing some non-ERP STAs or if we	*/
			/* are associated with a non-ERP AP.							*/
			phy_cw_min = 15;

			/* Maximum contention window size for selecting backoff slots.	*/
			phy_cw_max = 1023;
			
			/* Set the PHY standard.										*/
			phy_type = WlanC_11g_PHY;
			
			//max_operational_speed = 54000000;//set to max
			//max_operational_speed = 6000000;//set to minimum
			max_operational_speed = 54000000;//set to average
			break;
			}
			
		default:
			{
			wlan_error_print ("Unexpected Physical Layer Characteristic encountered.", OPC_NIL, OPC_NIL);
			break;
			}
		}

	/* Initialize the state variables whose values are based on whether		*/
	/* this MAC is operating with 802.11a, 802.11/802.11b or 802.11g PHY.	*/
	if (phy_type == WlanC_11a_PHY)
		{
		/* Set the data rate (in bps) used for the transmission of control	*/
		/* frames. Pick the highest mandatory data rate that is equal to or	*/
		/* lower than the data rate specified for data transmissions.		*/
		for (i = 0; data_tx_rate < WLANC_11a_MANDATORY_DRATE_ARRAY [i]; i++);
		control_data_rate = WLANC_11a_MANDATORY_DRATE_ARRAY [i];
		
		/* Initialize the state variables related to channelization, which	*/
		/* are mainly used during roaming (handover) procedures.			*/
		channel_count       = WLANC_11a_OPER_CHNL_COUNT;
		first_chan_min_freq = WLANC_11a_FIRST_CHNL_MIN_FREQ;
		channel_bandwidth   = WLANC_11a_CHNL_BANDWIDTH;
		channel_spacing     = WLANC_11a_CHNL_SPACING;
		}
	else
		{
		/* The MAC is operating in either 802.11/802.11b or 802.11g mode.	*/
		
		/* Initialize the state variables related to channelization, which	*/
		/* are mainly used during roaming (handover) procedures.			*/
		channel_count       = WLANC_11b_OPER_CHNL_COUNT;
		first_chan_min_freq = WLANC_11b_FIRST_CHNL_MIN_FREQ;
		channel_bandwidth   = WLANC_11b_CHNL_BANDWIDTH;
		channel_spacing     = WLANC_11b_CHNL_SPACING;
		
		/* Set the data rate (in bps) used for the transmission of control	*/
		/* frames.															*/
		if (phy_type == WlanC_11g_PHY)
			{
			/* Choose the highest mandatory data rate that is equal to or	*/
			/* lower than the data rate specified for data transmissions.	*/
			for (i = 0; data_tx_rate < WLANC_11g_MANDATORY_DRATE_ARRAY [i]; i++);
			control_data_rate = WLANC_11g_MANDATORY_DRATE_ARRAY [i];
			}
		else
			{
			/* Choose the lowest 802.11/11b mandatory data rate.			*/
			control_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
			}
		}

	/* Allocating memory for the flags used in this process model. 			*/
	wlan_flags = (WlanT_Mac_Flags *) op_prg_mem_alloc (sizeof (WlanT_Mac_Flags));
	//Loren
	//sprintf(myString,"I am 18");
	//op_prg_odb_print_major(myString,OPC_NIL);
	/* Initially resetting all the flags.									*/
	wlan_flags->rts_sent		   	= OPC_FALSE;
	wlan_flags->rcvd_bad_packet		= OPC_FALSE;
	wlan_flags->bad_packet_dropped	= OPC_FALSE;
	wlan_flags->receiver_busy		= OPC_FALSE;
	wlan_flags->phy_pkt_expected	= OPC_FALSE;
	wlan_flags->transmitter_busy	= OPC_FALSE;
	wlan_flags->gateway_flag		= OPC_FALSE;
	wlan_flags->bridge_flag			= OPC_FALSE;
	wlan_flags->wait_eifs_dur		= OPC_FALSE;
	wlan_flags->immediate_xmt		= OPC_FALSE;
	wlan_flags->forced_bk_end  	    = OPC_FALSE;
	wlan_flags->nav_updated			= OPC_FALSE;

	wlan_flags->tx_beacon			= OPC_FALSE;

	wlan_flags->non_erp_present		= OPC_FALSE;
	wlan_flags->wait_signal_ext		= OPC_FALSE;
	wlan_flags->rcvd_bad_cts 		= OPC_FALSE;
	wlan_flags->edca_params_updated	= OPC_FALSE;
	wlan_flags->txop_on				= OPC_FALSE;
	wlan_flags->not_first_in_txop	= OPC_FALSE;
	wlan_flags->scanning			= OPC_FALSE;

	/* Similarly allocate memory for the AC specific bitmap flags and		*/
	/* initialize them by resetting all the bits.							*/
	wlan_ac_flags = (WlanT_AC_Bit_Flags *) op_prg_mem_alloc (sizeof (WlanT_AC_Bit_Flags));
	wlan_ac_flags->cw_required      = 0;
	wlan_ac_flags->frsize_req_rts   = 0;
	wlan_ac_flags->std_cwmin 	    = 0;
	wlan_ac_flags->std_cwmax 	    = 0;
	wlan_ac_flags->stats_registered = 0;
	
	/* Set the flag corresponding to optional 802.11g protection mechanism	*/
	/* "CTS-to-self" based on user's configuration.							*/
	op_ima_obj_attr_get (params_attr_objid, "CTS-to-self Option", &cts_to_self_flag);
	wlan_flags->cts_to_self = (cts_to_self_flag == OPC_BOOLINT_ENABLED) ? OPC_TRUE : OPC_FALSE;

	/* If the BSS IDs are auto-assigned then add the BSS ID into the 		*/
	/* physical layer technology specific BSS ID list, which is later going	*/
	/* to be used while selecting channels for BSSs.						*/
	if (bss_id_type == WlanC_Entire_Subnet)
		{
		wlan_bss_id_list_manage (bss_id, phy_type, "add");
		}

	/* By default stations are configured for IBSS unless an Access Point	*/
	/* is found, then the network will have an infrastructure BSS			*/
	/* configuration.														*/
	bss_flag = OPC_FALSE;

	/* Compute the values of various interframe spacing parameters based on	*/
	/* the timing relations specified in section 9.2.10 of the IEEE 802.11-	*/
	/* 1999 standard.														*/
	
	/* Computing DIFS interval which is interframe gap between successive	*/
	/* frame transmissions.													*/
	difs_time = sifs_time + 2 * slot_time;

	/* Compute the EIFS duration, which is DIFS + SIFS + "transmission time	*/
	/* of an ACK frame". While computing the the ACK transmission time, use	*/
	/* the lowest mandatory data rate of the PHY as stated in the standard. */
	if (phy_type == WlanC_11a_PHY)
		eifs_time = difs_time + sifs_time + TXTIME_CTRL_DR (WLANC_ACK_LENGTH, WLANC_11a_MIN_MANDATORY_DRATE);
	else
		eifs_time = difs_time + sifs_time + TXTIME_CTRL_DR (WLANC_ACK_LENGTH, WLANC_11b_MIN_MANDATORY_DRATE);
	
	/* Initialize segmentation and reassembly buffers.						*/
	defragmentation_list_ptr 	 = op_prg_list_create ();
	common_rsmbuf_ptr        	 = op_sar_buf_create (OPC_SAR_BUF_TYPE_REASSEMBLY, OPC_SAR_BUF_OPT_DEFAULT);
	mac_client_reassembly_buffer = op_sar_buf_create (OPC_SAR_BUF_TYPE_REASSEMBLY, OPC_SAR_BUF_OPT_DEFAULT);
	
	/* Set a discard timer for the reassembly buffer of the MAC client		*/
	/* packets. Note that this is to reassemble the MSDUs that are segments	*/
	/* themselves, not to reassemble the MSDUs that are fragmented as a		*/
	/* result of being larger than the configured WLAN fragmentation		*/
	/* threshold. Hence, set the duration of the discard timer to the twice	*/
	/* of the maximum receive lifetime of the MSDU fragments.				*/
	op_sar_buf_options_set (mac_client_reassembly_buffer, OPC_SAR_BUF_OPT_FLUSH_TIMED, 2.0 * max_receive_lifetime);
	
	/* Registering local statistics.										*/
	packet_load_handle				= op_stat_reg ("Wireless Lan.Load (packets/sec)", 				                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_load_handle				= op_stat_reg ("Wireless Lan.Load (bits/sec)", 					                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	hl_packets_rcvd					= op_stat_reg ("Wireless Lan.Queue Size (packets)", 		                     	 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	data_traffic_sent_handle 		= op_stat_reg ("Wireless Lan.Data Traffic Sent (packets/sec)", 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);	
	data_traffic_rcvd_handle		= op_stat_reg ("Wireless Lan.Data Traffic Rcvd (packets/sec)", 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	data_traffic_sent_handle_inbits	= op_stat_reg ("Wireless Lan.Data Traffic Sent (bits/sec)", 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	data_traffic_rcvd_handle_inbits	= op_stat_reg ("Wireless Lan.Data Traffic Rcvd (bits/sec)", 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ctrl_traffic_sent_handle	 	= op_stat_reg ("Wireless Lan.Control Traffic Sent (packets/sec)",                    OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ctrl_traffic_rcvd_handle		= op_stat_reg ("Wireless Lan.Control Traffic Rcvd (packets/sec)",                    OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	ctrl_traffic_sent_handle_inbits	= op_stat_reg ("Wireless Lan.Control Traffic Sent (bits/sec)",                       OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ctrl_traffic_rcvd_handle_inbits	= op_stat_reg ("Wireless Lan.Control Traffic Rcvd (bits/sec)", 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	mgmt_traffic_sent_handle	 	= op_stat_reg ("Wireless Lan.Management Traffic Sent (packets/sec)",                 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	mgmt_traffic_rcvd_handle		= op_stat_reg ("Wireless Lan.Management Traffic Rcvd (packets/sec)",                 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	mgmt_traffic_sent_handle_inbits	= op_stat_reg ("Wireless Lan.Management Traffic Sent (bits/sec)",                    OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	mgmt_traffic_rcvd_handle_inbits	= op_stat_reg ("Wireless Lan.Management Traffic Rcvd (bits/sec)", 	                 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	buffer_drop_pkts_handle       	= op_stat_reg ("Wireless Lan.Data Dropped (Buffer Overflow) (packets/sec)",          OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	buffer_drop_bits_handle       	= op_stat_reg ("Wireless Lan.Data Dropped (Buffer Overflow) (bits/sec)",             OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	retx_drop_pkts_handle       	= op_stat_reg ("Wireless Lan.Data Dropped (Retry Threshold Exceeded) (packets/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	retx_drop_bits_handle       	= op_stat_reg ("Wireless Lan.Data Dropped (Retry Threshold Exceeded) (bits/sec)",    OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	mgmt_retx_drop_pkts_handle      = op_stat_reg ("Wireless Lan.Management Traffic Dropped (packets/sec)", 			 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	mgmt_retx_drop_bits_handle      = op_stat_reg ("Wireless Lan.Management Traffic Dropped (bits/sec)",    			 OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	retrans_handle					= op_stat_reg ("Wireless Lan.Retransmission Attempts (packets)",                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
	media_access_delay				= op_stat_reg ("Wireless Lan.Media Access Delay (sec)", 		                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ete_delay_handle				= op_stat_reg ("Wireless Lan.Delay (sec)", 					 	                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	throughput_handle				= op_stat_reg ("Wireless Lan.Throughput (bits/sec)", 			                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ap_conn_handle					= op_stat_reg ("Wireless Lan.AP Connectivity",		 			                     OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	/* Registering global statistics.										*/
	global_ete_delay_handle 		= op_stat_reg ("Wireless LAN.Delay (sec)", 	  		                              OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_load_handle 				= op_stat_reg ("Wireless LAN.Load (bits/sec)", 		                              OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_throughput_handle 		= op_stat_reg ("Wireless LAN.Throughput (bits/sec)",                              OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_buffer_drop_handle       = op_stat_reg ("Wireless LAN.Data Dropped (Buffer Overflow) (bits/sec)",          OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_retx_drop_handle         = op_stat_reg ("Wireless LAN.Data Dropped (Retry Threshold Exceeded) (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_mac_delay_handle			= op_stat_reg ("Wireless LAN.Media Access Delay (sec)",                           OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	global_retrans_handle	  		= op_stat_reg ("Wireless LAN.Retransmission Attempts (packets)",                  OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);

	/* Register the "Network Load" dimensioned global statistic managed		*/
	/* using the oms_dim_stat_support package. Use the BSS ID as the key	*/
	/* for the dimension of the statistic reserved for our BSS.				*/
	sprintf (stat_info, "%d", bss_id);
	global_network_load_handle = Oms_Dim_Stat_Reg (my_objid, "Wireless LAN", "Network Load (bits/sec)", stat_info, OPC_STAT_GLOBAL);
	
	/* Initialize receiver idle timer and NAV duration. Set		*/
	/* them to an arbitrary negative number whose absolute		*/
	/* value is sufficiently large from any possible AIFS +		*/
	/* duration so that the very first packet arriving to a		*/
	/* WLAN MAC in the network is transmitted without a backoff.*/ 
	rcv_idle_time = -1.0; 
	nav_duration  = -1.0;

	/* Similarly set the TBTT to negative beacon interval.		*/
	beacon_tx_time = -beacon_int;
	
	
	stateReport_tx_time = -stateReport_int; //(mohammad) initialize the first stateReport transmittion time.
	
	/* Initialize NAV reset event handle.						*/
	nav_reset_evh = invalid_evh;
	
	/* Initializing the sum of sizes of the packets in the		*/
	/* higher layer queue.										*/
	if(LorenDebugFlag)
	{
		printf("initializing total_hlpk_size to zero (0).\n");
	}
	total_hlpk_size = 0;

	/* Initializing frame response to send to none.				*/
	fresp_to_send = WlanC_None;

	/* Initializing expected frame type to none.				*/
	expected_frame_type = WlanC_None;
	
	/* Initialize the sequence number counter used for			*/
	/* broadcast frames, MMPDUs and non-QoS data frames.		*/
	common_seq_count = 0;
	
	/* Reset the variable that indicates the AC with the 		*/
	/* shortest AIFSN + back-off.								*/
	backoff_ac = WlanC_AC_None;
	
	/* Set the variable that holds the current simulation time.	*/
	current_time = op_sim_time ();
		
	/* Set the flag indicating debugging mode.					*/
	debug_mode = op_sim_debug ();
	
	/* If running in debugging mode, initialize the variable	*/
	/* the name of the current state of the MAC.				*/
	if (debug_mode)
		strcpy (current_state_name, "INIT");
	
	/* Data arrived from higher layer is queued in the buffer. Pool memory is used for		*/
	/* allocating data structure for the higher layer packet and the random destination		*/
	/* for the packet. This structure is then inserted in the higher layer arrival queue.	*/
	hld_pmh = op_prg_pmo_define ("WLAN HCF MAC HL Data Info", sizeof (WlanT_HCF_Hld_Info), 32);

	/* Obtaining transmitter objid for accessing channel data rate attribute.	*/
	tx_objid = op_topo_assoc (my_objid, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX, 0);

	/* If no receiver is attach then generate error message and abort the simulation.	*/
	if (tx_objid == OPC_OBJID_INVALID)
		{
		wlan_error_print ("No transmitter attached to this MAC process", OPC_NIL, OPC_NIL);	
		}

	/* Obtaining number of channels available.									*/
	op_ima_obj_attr_get (tx_objid, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RATXCH);
	
	/* Check for error conditions. The transmitter is expected to have a single	*/
	/* channel.																	*/
	if (num_chann > 1)
		wlan_error_print ("The transmitter of the surrounding node has too many channels. This MAC",
						  "is implemented to use a single channel for all supported data rates.",
						  "Possibly, the new MAC process model is deployed in an old node model.");
	else if (num_chann == 0)
		wlan_error_print ("No channel is available for transmission.", OPC_NIL, OPC_NIL);
		
	/* Set the transmitter's transmission power.								*/	
	txch_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_set (txch_objid, "power", tx_power);

	/* Free the transmitter channel state information set at the rxgroup		*/
	/* pipeline stage.															*/
	temp_ptr = (void *) op_ima_obj_state_get (txch_objid);
	op_prg_mem_free (temp_ptr);	
	
	/* Reset the channel state. */
	op_ima_obj_state_set (txch_objid, OPC_NIL);

	/* Obtaining receiver's objid for accessing channel data rate attribute.	*/
	rx_objid = op_topo_assoc (my_objid, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX, 0);

	/* If no receiver is attach then generate error message and abort the		*/
	/* simulation.																*/
	if (rx_objid == OPC_OBJID_INVALID)
		{
		wlan_error_print ("No receiver attached to this MAC process", OPC_NIL, OPC_NIL);	
		}

	/* Obtaining number of channels available.									*/
	op_ima_obj_attr_get (rx_objid, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RARXCH);
	
	/* Check for error conditions. The receiver is expected to have a single	*/
	/* channel.																	*/
	if (num_chann > 1)
		wlan_error_print ("The receiver of the surrounding node has too many channels. This MAC",
						  "is implemented to use a single channel for all supported data rates.",
						  "Possibly, the new MAC process model is deployed in an old node model.");
	else if (num_chann == 0)
		wlan_error_print ("No channel is available for reception.", OPC_NIL, OPC_NIL);

	/* Free the receiver channel state information set at the rxgroup stage.	*/
	rxch_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RARXCH, 0);
	temp_ptr = (void *) op_ima_obj_state_get (rxch_objid);
	op_prg_mem_free (temp_ptr);
	
	/* Reset the channel state. */
	op_ima_obj_state_set (rxch_objid, OPC_NIL);
		
	/* Initialize the roaming related information.								*/
	roam_state_ptr = (WlanT_Roam_State_Info *) op_prg_mem_alloc (sizeof (WlanT_Roam_State_Info));
	roam_state_ptr->ap_reliability = 1.0;
	roam_state_ptr->scan_mode      = OPC_FALSE;
	roam_state_ptr->current_bss_id = bss_id;
	roam_state_ptr->scan_type      = WlanC_Scan_Type_Beacon;

	/* Initially, set roaming based on the attribute. In the next state, if it	*/
	/* is determined that this is an ad-hoc network or this MAC is actually an	*/
	/* AP, then roaming will be disabled.										*/
	op_ima_obj_attr_get (params_attr_objid, "Roaming Capability", &roaming_cap_flag);
	roam_state_ptr->enable_roaming = (roaming_cap_flag == OPC_BOOLINT_ENABLED) ? OPC_TRUE : OPC_FALSE;

	/* Initialize the receiver channel state information.						*/
	rx_state_info_ptr = (WlanT_Rx_State_Info *) op_prg_mem_alloc (sizeof (WlanT_Rx_State_Info));
	rx_state_info_ptr->state_info_id 	        = WLANC_RXCH_STATE_ID;
	rx_state_info_ptr->rx_power_thresh          = rx_power_threshold;
	rx_state_info_ptr->rx_end_time              = 0.0;
	rx_state_info_ptr->roaming_info_ptr         = roam_state_ptr;
	rx_state_info_ptr->phy_tech			        = phy_type;
	rx_state_info_ptr->routed_bgutil_state_ptr	= OPC_NIL;
	rx_state_info_ptr->port_name_ptr       	    = OPC_NIL;
	rx_state_info_ptr->node_name_ptr     	    = OPC_NIL;
   	rx_state_info_ptr->data_rate            	= data_tx_rate;
   	rx_state_info_ptr->congestion_area          = OPC_FALSE;
	rx_state_info_ptr->wlan_pk_rx_end_time		= 0.0;
	rx_state_info_ptr->jammer_rx_end_time		= 0.0;
	rx_state_info_ptr->busy_due_to_jammer		= OPC_FALSE;
	
	/* Find out the objid of the packet stream from the receiver into the MAC	*/
	/* module, which is also stored in receiver channel state information.		*/
	rx_state_info_ptr->mac_strm_objid   = op_topo_assoc (rx_objid, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_STRM, 0);
	
	/* Set the new "state" information of the receiver channel.					*/
	op_ima_obj_state_set (rxch_objid, rx_state_info_ptr);
	
	/* Also overwrite the high threshold trigger attribute values of the		*/
	/* statwires that come into the MAC from the radio receiver by using the	*/
	/* reception power threshold. First determine the total count of incoming	*/
	/* statwires.																*/
	num_statwires = op_topo_assoc_count (my_objid, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE);
	for (i = 0; i < num_statwires; i++)
		{
		/* Access the next statwire. Skip it if it is coming from the			*/
		/* transmitter.															*/
		statwire_objid = op_topo_assoc (my_objid, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE, i);
		op_ima_obj_attr_get (statwire_objid, "high threshold trigger", &threshold);
		
		/* If the trigger is not disabled then the statwire is from the			*/
		/* receiver. Overwrite the attribute value unless they are already same.*/
		if (threshold != OPC_BOOLDBL_DISABLED && threshold != rx_power_threshold)
			op_ima_obj_attr_set (statwire_objid, "high threshold trigger", rx_power_threshold);			
		}
			
	/* Create an ICI to be used during the communication with LLC.				*/
	llc_iciptr = op_ici_create ("wlan_mac_ind");
	if (llc_iciptr == OPC_NIL)
		{
		wlan_error_print ("Unable to create ICI for communication with LLC.", OPC_NIL, OPC_NIL);
		}

	/* Create the mutex that will be used to serialize calling of prg_mapping	*/
	/* functions, which read/write global model related mapping information,	*/
	/* under multi-threaded execution with multiple CPUs.						*/
	mapping_info_mutex = op_prg_mt_mutex_create (OPC_MT_MUTEX_READER_WRITER, 0, "WLAN Mapping Info Mutex");

	/* Unless already done by another WLAN MAC process model, initialize the	*/
	/* global variables that hold the indices of the fields of the WLAN packet	*/
	/* formats.																	*/
	if (WLANC_DATA_TYPE_FD == OPC_FIELD_INDEX_INVALID)
		wlan_pk_field_indices_initialize ();
	
	/* Start parsing HCF related parameters and populating corresponding state	*/
	/* variables.																*/
	
	/* Get the objid of the "Access Category Parameters" compound attribute.	*/
	op_ima_obj_attr_get (params_attr_objid, "HCF Parameters", &comp_attr_objid);
	hcf_params_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
	op_ima_obj_attr_get (hcf_params_objid, "EDCA Parameters", &comp_attr_objid);
	params_attr_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
	op_ima_obj_attr_get (params_attr_objid, "Access Category Parameters", &own_ac_edca_params_objid);

	/* Populate our EDCA Parameter Set data structures using the configuration	*/
	/* of the corresponding attribute.											*/
	wlan_hcf_edca_parameter_set_read (own_ac_edca_params_objid);
	
	/* If we are an AP then check whether we need to advertise the EDCA			*/
	/* parameters to be used in our BSS.										*/
	if (ap_flag == OPC_BOOLINT_ENABLED)
		{
		op_ima_obj_attr_get (hcf_params_objid, "AP Specific Parameters", &comp_attr_objid);
		params_attr_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
		op_ima_obj_attr_get (params_attr_objid, "Parameters Advertised in BSS", &comp_attr_objid);
		params_attr_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
		op_ima_obj_attr_get (params_attr_objid, "EDCA Parameter Set Distribution", &advertise_edca_params);
		if (advertise_edca_params == OPC_BOOLINT_ENABLED)
			{
			/* Read the EDCA parameter set configuration to be advertised for 	*/
			/* the BSS.															*/
			op_ima_obj_attr_get (params_attr_objid, "EDCA Parameter Set", &comp_attr_objid);
			wlan_hcf_bss_edca_parameter_set_read (comp_attr_objid);
			
			/* If we are not sending period beacons then send certain number of	*/
			/* beacons as specified by the user to advertise the EDCA			*/
			/* parameters. Use remote interrupt instead of self, since self		*/
			/* interrupts with the code WlanC_Beacon_Tx_Time are used for		*/
			/* periodic beacons.												*/
			if (BEACON_TX_EFFICIENCY_ENABLED)
				op_intrpt_schedule_remote (beacon_int, WlanC_Beacon_Tx_Time, my_objid);
			}
		else
			bss_edca_params_arr = OPC_NIL;
		}
	else
		bss_edca_params_arr = OPC_NIL;
	
	/* Initialize the state variables maintained separately for each AC.		*/
	for (i = 0; i < WLANC_HCF_AC_COUNT; i++)
		{
		/* Create the higher layer packet queues and initialize the queue		*/
		/* status array.														*/
		hlpk_lptr_arr [i]       = op_prg_list_create ();
		ac_queue_status_arr [i] = WlanC_AC_None;
		
		/* Create the fragmentation buffer.										*/
		fragmentation_buffer_arr [i] = op_sar_buf_create (OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_PK_BNDRY);
		
		/* Initialize the number of slots needed for backoff.					*/
		deference_info_arr [i].backoff_slots = BACKOFF_SLOTS_UNSET;

		/* Initialize the packet pointer that holds the last transmitted		*/
		/* packets to be used for retransmissions when necessary.				*/
		mpdu_retx_copy_arr [i] = OPC_NIL;		
		}
	
	/* Initialize the additional cell in the queue status array.				*/
	ac_queue_status_arr [WLANC_HCF_AC_COUNT] = WlanC_AC_None;
	
	/* If we are an AP, perform AP specific initialization.						*/
	if (ap_flag == OPC_BOOLINT_ENABLED)
		{
		/* Register outbound traffic specific voice AC statistics, which will	*/
		/* be updated by this AP MAC while sending management frames like		*/
		/* beacons.																*/
		wlan_hcf_ac_statistics_register (WlanC_AC_VO, OPC_TRUE);
		
		/* Create the list that will store the addresses of disassociating STAs	*/
		/* when needed.															*/
		disassociating_sta_lptr = op_prg_list_create ();
		}

	/* Parse the attributes that define traffic class configuration.			*/
	wlan_hcf_tc_parameters_read (hcf_params_objid);
	
	/* Register the print functions for structure type packet fields that are	*/
	/* populated only by QSTAs.													*/
	wlan_hcf_ptr_fields_print_functions_set ();
	
	FOUT;
	}

static void
wlan_hcf_transceiver_channel_init (void)
	{
	Objid		mac_params_comp_attr_objid;
	Objid		params_attr_objid;
	Objid		chann_params_comp_attr_objid;
	Objid		subchann_params_attr_objid;	
	int			bss_index;
	int			found_channel_num;
	double		bandwidth_mhz;
	double		frequency;
	char		err_msg1 [256];

	/** This function determines the WLAN channel that the surrounding	**/
	/** node will use and configures the transceiver with the			**/
	/** corresponding minimum frequency and bandwidth values.			**/
	FIN (wlan_hcf_transceiver_channel_init (void));
	
	/* Get a handle to node's WLAN parameters.							*/
	op_ima_obj_attr_get (my_objid, "Wireless LAN Parameters", &mac_params_comp_attr_objid);
    params_attr_objid = op_topo_child (mac_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);

	/* Get the provided channel configuration.							*/
	op_ima_obj_attr_get (params_attr_objid, "Channel Settings", &chann_params_comp_attr_objid);
	subchann_params_attr_objid = op_topo_child (chann_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
	op_ima_obj_attr_get (subchann_params_attr_objid, "Bandwidth", &bandwidth_mhz);	
	op_ima_obj_attr_get (subchann_params_attr_objid, "Min Frequency", &frequency);	

	/* Check whether the bandwidth is specified using a special value.	*/
	if (bandwidth_mhz == WLANC_PHY_BASED_BW_USED)
		{
		/* Set the bandwidth to the standard value of used physical		*/
		/* layer technology.											*/
		bandwidth_mhz = (phy_char_flag == WlanC_OFDM_11a) ? WLANC_11a_CHNL_BANDWIDTH : WLANC_11b_CHNL_BANDWIDTH;
		}
	
	/* Determine the channel number we are going to use.				*/ 
	if (frequency == WLANC_BSS_BASED_FREQ_USED)
		{
		/* The channel will be selected based on node's BSS ID. Check	*/
		/* whether the BSS IDs are auto-assigned or not.				*/
		if (bss_id_type == WlanC_Entire_Subnet)
			{
			/* BSS IDs are auto assigned and their are set to node's	*/
			/* subnet ID. Use BSS index for channel selection.			*/
			bss_index = wlan_bss_id_list_manage (bss_id, phy_type, "get_index");
			}
		else
			{
			/* BSS IDs are explicitly assigned. Use the BSS ID as the	*/
			/* BSS index.												*/
			bss_index = bss_id;
			}
		
		/* Assign channels from 1 through 11 (North America) with a gap */
		/* of 5 channels in between. The sequence will look like 1, 6,  */
		/* 11, 5, 10, 4, 9,... The channel will be picked as a function */
		/* BSS ID, that is mapped to a BSS index. Note that only		*/
		/* channels that are 5 channels apart are non-overlapping.		*/
		/* Assume that BSS indices run serially: 0, 1, 2, ... 			*/
		/* WLANC_CHANNEL_COUNT = 11, and								*/
		/* WLANC_CH_STEP_FOR_NO_OVERLAP = ceil (22.0/5.0) = 5			*/
		/*																*/
		/* Follow the same logic in case of 802.11a operation, where	*/
		/* WLANC_CHANNEL_COUNT = 12, and								*/
		/* WLANC_CH_STEP_FOR_NO_OVERLAP = ceil (20.0/20.0) = 1 (i.e.,	*/
		/* in 802.11a, the adjacent WLAN channels don't overlap.)		*/
		channel_num = (WLANC_CH_STEP_FOR_NO_OVERLAP * bss_index) % channel_count + 1;

		/* Get the minimum frequency that corresponds to the selected	*/
		/* channel.														*/
		frequency = wlan_min_freq_for_chan (channel_num, phy_type);
		}
	else
		{
		/* The frequency band that will be used by this node is			*/
		/* explicitly specified. Validate it and determine its channel	*/
		/* number. 														*/
		
		/* In 802.11/11b/11g networks, for a standard, acceptable		*/
		/* channel, the bandwidth has to be 22 MHz, and the minimum		*/
		/* frequency between 2401 and 2451 MHz, inclusive, with			*/
		/* intervals of 5 MHz (i.e. the roaming feature is currently	*/
		/* supported only within first 11 channels. These numbers refer	*/
		/* to the values of the constants used below as specified in	*/
		/* the standard).												*/
		if (phy_char_flag != WlanC_OFDM_11a  && bandwidth_mhz == channel_bandwidth && frequency >= first_chan_min_freq && 
			frequency == ceil (frequency)    && (frequency - first_chan_min_freq) / channel_spacing < channel_count && 
			(int) (frequency - first_chan_min_freq) % (int) channel_spacing == 0)
			{
			/* The radio band has a valid configuration. Compute its	*/
			/* channel number.											*/
			channel_num = (int) ((frequency - first_chan_min_freq) / channel_spacing + 1);
			}
		
		/* In case of 802.11a, search the array of the standard channel	*/
		/* to check the validity of the specified channel band.			*/
		else if (phy_char_flag == WlanC_OFDM_11a && bandwidth_mhz == channel_bandwidth && 
				 wlan_11a_channel_is_regular (frequency, &found_channel_num))
			{
			channel_num = found_channel_num;
			}
		
		/* Invalid (irregular) channel bands are acceptable if the node	*/
		/* is not expected to roam.										*/
		else if (!roam_state_ptr->enable_roaming)
			{
			/* When the roaming is disabled, the value of the state		*/
			/* variable channel_num is not used by regular MACs. For	*/
			/* APs, this means that the APs with irregular channel		*/
			/* bandwidths cannot support roaming WLAN MACs, since they	*/
			/* will not be able to discover such an AP during scanning.	*/
			channel_num = 0;
			}
			
		else
			{
			/* Terminate the simulation with an error message.			*/
			sprintf (err_msg1, "bandwidth must be %.1f MHz for 802.11a networks, and %.1f MHz for 802.11/11b/11g networks.",
					 WLANC_11a_CHNL_BANDWIDTH, WLANC_11b_CHNL_BANDWIDTH);
			wlan_error_print ("Cannot support WLAN roaming with configured radio channel settings. Roaming is supported", 
							  "only for the operation channels specified in 802.11a and 802.11/11b/11g standards. Channel", err_msg1);
			}
		}
	
	/* Configure the transmitter channel based on selected/assigned		*/
	/* frequency band.													*/
	op_ima_obj_attr_set (txch_objid, "bandwidth", bandwidth_mhz * 1000.0);
	op_ima_obj_attr_set (txch_objid, "min frequency", frequency);
	
	/* Similarly configure the receiver channel.						*/
	op_ima_obj_attr_set (rxch_objid, "bandwidth", bandwidth_mhz * 1000.0);
	op_ima_obj_attr_set (rxch_objid, "min frequency", frequency);
			
	FOUT;
	}

static void
wlan_hcf_edca_parameter_set_read (Objid edca_param_set_comp_objid)
	{
	Objid					edca_param_set_objid;
	int						ac_index;
	
	/** This function reads the EDCA Parameters configured for all four	**/
	/** access categories and populates the fields of the internal		**/
	/** arrays that store the values of those parameters.				**/
	FIN (wlan_hcf_edca_parameter_set_read (edca_param_set_comp_objid));
	
	/* Get the objid of the EDCA Parameter set configuration.			*/
	edca_param_set_objid = op_topo_child (edca_param_set_comp_objid, OPC_OBJTYPE_GENERIC, 0);
	
	/* Loop over the number of access categories and parse the			*/
	/* parameters of each category.										*/
	for (ac_index = 0; ac_index < WLANC_HCF_AC_COUNT; ac_index++)
		wlan_hcf_edca_ac_parameter_set_read (edca_param_set_objid, (WlanT_HCF_Access_Category) ac_index);
	
	FOUT;
	}

static void
wlan_hcf_edca_ac_parameter_set_read (Objid ac_edca_params_set_objid, WlanT_HCF_Access_Category ac)
	{
	Objid		comp_attr_objid, ac_edca_params_objid;
	int			txop_limit;
	
	/** This function parses EDCA Parameter Set configuration of the	**/
	/** given AC from the corresponding compound attribute, the ID of	**/
	/** whose parent object is provided.								**/	 
	FIN (wlan_hcf_edca_ac_parameter_set_read (ac_edca_params_set_objid, ac));

	/* Get the objid of the AC specific EDCA Parameters configuration.	*/
	op_ima_obj_attr_get (ac_edca_params_set_objid, WLANC_AC_NAME_ARRAY [ac], &comp_attr_objid);
	ac_edca_params_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
		
	/* Read the CWmin value. Pay attention to special values.			*/
	op_ima_obj_attr_get (ac_edca_params_objid, "CWmin", &(cwmin_arr [ac]));
	if (cwmin_arr [ac] == STANDARD_DEFAULT)
		{
		/* Default value specified in the standard is used.				*/
		if (ac == WlanC_AC_VO)
			cwmin_arr [ac] = (phy_cw_min + 1) / 4 - 1;
		else if (ac == WlanC_AC_VI)
			cwmin_arr [ac] = (phy_cw_min + 1) / 2 - 1;
		else
			cwmin_arr [ac] = phy_cw_min;
		
		/* Set the bit flag, so that we adjust the actual CWmin if the	*/
		/* PHY CWmin value changes (e.g., an 11g associates	with a		*/
		/* non-ERP AP).													*/
		wlan_ac_flags->std_cwmin |= WLANC_AC_BITMAP_ARRAY [ac];
		}
	
	/* Read the CWmax value. Pay attention to special values.			*/
	op_ima_obj_attr_get (ac_edca_params_objid, "CWmax", &(cwmax_arr [ac]));
	if (cwmax_arr [ac] == STANDARD_DEFAULT || cwmax_arr [ac] == STANDARD_DEFAULT_QAP)
		{
		/* Set the bit flag, so that we adjust the actual CWmax if the	*/
		/* PHY CWmin value changes.										*/
		if (ac > WlanC_AC_BE || cwmax_arr [ac] == STANDARD_DEFAULT_QAP)
			wlan_ac_flags->std_cwmax |= WLANC_AC_BITMAP_ARRAY [ac];
		
		/* Default value specified in the standard is used.				*/
		if (ac == WlanC_AC_VO)
			cwmax_arr [ac] = (phy_cw_min + 1) / 2 - 1;
		else if (ac == WlanC_AC_VI)
			cwmax_arr [ac] = phy_cw_min;
		else if (ac == WlanC_AC_BE)
			cwmax_arr [ac] = (cwmax_arr [ac] == STANDARD_DEFAULT) ? phy_cw_max : (4 * (phy_cw_min + 1) - 1);
		else
			cwmax_arr [ac] = phy_cw_max;
		}
	
	/* Make sure that CWmax is not smaller than CWmin.					*/
	if (cwmax_arr [ac] < cwmin_arr [ac])
		wlan_error_print ("Improper configuration of CWmin and CWmax parameters for the access category:",
						WLANC_AC_NAME_ARRAY [ac], "CWmin cannot be greater than CWmax.");
	
	/* Initially set the contention window size to CWmin.				*/
	cw_arr [ac] = cwmin_arr [ac];
	
	/* Read the AIFSN value.											*/
	op_ima_obj_attr_get (ac_edca_params_objid, "AIFSN", &(aifsn_arr [ac]));
	
	/* Make sure that AIFSN is not 1 for a non-AP QSTA.					*/
	if (aifsn_arr [ac] == 1 && ap_flag == OPC_BOOLINT_DISABLED)
		wlan_error_print ("Improper configuration of AIFSN parameters for the access category:",
						WLANC_AC_NAME_ARRAY [ac], "AIFSN cannot be 1 for WLAN MACs that are not access points.");
	
	/* Compute the AC's AIFS using its AIFSN.							*/
	aifs_arr [ac] = (double) aifsn_arr [ac] * slot_time + sifs_time;
	
	/* Get the objid of the first row of the "TXOP Limits" attribute.	*/
	op_ima_obj_attr_get (ac_edca_params_objid, "TXOP Limits", &comp_attr_objid);
	ac_edca_params_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
	
	/* Based on the PHY used by this MAC, read the corresponding TXOP	*/
	/* limit value.														*/
	if (phy_char_flag == WlanC_ERP_OFDM_11g || phy_char_flag == WlanC_OFDM_11a)
		op_ima_obj_attr_get (ac_edca_params_objid, "Extended Rate and OFDM", &txop_limit);
	else if (phy_char_flag == WlanC_Direct_Sequence)
		op_ima_obj_attr_get (ac_edca_params_objid, "DS-CCK", &txop_limit);
	else
		op_ima_obj_attr_get (ac_edca_params_objid, "FHSS and IR", &txop_limit);
	
	/* Convert the txop_limit value from microseconds to seconds.		*/
	txop_limit_arr [ac] = (double) txop_limit / 1000000;

	FOUT;
	}

static void
wlan_hcf_bss_edca_parameter_set_read (Objid edca_param_set_comp_objid)
	{
	Objid		comp_attr_objid, edca_param_set_objid, ac_edca_params_objid;
	int			ac_index;
	
	/** This function is called only by QAPs and if the QAP is			**/
	/** configured to advertise EDCA Parameter set within its BSS. This	**/
	/** function reads the EDCA Parameters configured for all four		**/
	/** access categories for the AP to advertise to its BSS, and		**/
	/** stores the information in an internal data structure, whose		**/
	/** copies will be inserted into the beacons sent by this AP.		**/
	FIN (wlan_hcf_bss_edca_parameter_set_read (edca_param_set_comp_objid));
	
	/* Allocate memory for the array that will contain the EDCA			*/
	/* Parameter Set for each access category to be advertised in our	*/
	/* BSS.																*/
	bss_edca_params_arr = (WlanT_AC_EDCA_Param_Rec *) op_prg_mem_alloc (sizeof (WlanT_AC_EDCA_Param_Rec) * WLANC_HCF_AC_COUNT);
	
	/* Get the objid of the EDCA Parameter set configuration.			*/
	edca_param_set_objid = op_topo_child (edca_param_set_comp_objid, OPC_OBJTYPE_GENERIC, 0);
	
	/* Loop over the number of access categories and parse the			*/
	/* parameters of each category.										*/
	for (ac_index = 0; ac_index < WLANC_HCF_AC_COUNT; ac_index++)
		{
		/* Get the objid of the AC specific EDCA Parameters				*/
		/* configuration.												*/
		op_ima_obj_attr_get (edca_param_set_objid, WLANC_AC_NAME_ARRAY [ac_index], &comp_attr_objid);
		ac_edca_params_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
		
		/* Read the CWmin value. Pay attention to special values.		*/
		op_ima_obj_attr_get (ac_edca_params_objid, "CWmin", &(bss_edca_params_arr [ac_index].cwmin));
		if (bss_edca_params_arr [ac_index].cwmin == STANDARD_DEFAULT)
			{
			/* Default value specified in the standard is used.			*/
			if (ac_index == WlanC_AC_VO)
				bss_edca_params_arr [ac_index].cwmin = (phy_cw_min + 1) / 4 - 1;
			else if (ac_index == WlanC_AC_VI)
				bss_edca_params_arr [ac_index].cwmin = (phy_cw_min + 1) / 2 - 1;
			else
				bss_edca_params_arr [ac_index].cwmin = phy_cw_min;
			}

		/* Read the CWmax value. Pay attention to special values.		*/
		op_ima_obj_attr_get (ac_edca_params_objid, "CWmax", &(bss_edca_params_arr [ac_index].cwmax));
		if (bss_edca_params_arr [ac_index].cwmax == STANDARD_DEFAULT)
			{
			/* Default value specified in the standard is used.			*/
			if (ac_index == WlanC_AC_VO)
				bss_edca_params_arr [ac_index].cwmax = (phy_cw_min + 1) / 2 - 1;
			else if (ac_index == WlanC_AC_VI)
				bss_edca_params_arr [ac_index].cwmax = phy_cw_min;
			else
				bss_edca_params_arr [ac_index].cwmax = phy_cw_max;
			}
		
		/* Make sure that CWmax is not smaller than CWmin.				*/
		if (bss_edca_params_arr [ac_index].cwmax < bss_edca_params_arr [ac_index].cwmin)
			wlan_error_print ("Improper configuration of CWmin and CWmax parameters for advertisement by AP in BSS for the access category:",
				WLANC_AC_NAME_ARRAY [ac_index], "CWmin cannot be greater than CWmax.");
		
		/* Read the AIFSN value.										*/
		op_ima_obj_attr_get (ac_edca_params_objid, "AIFSN", &(bss_edca_params_arr [ac_index].aifsn));
		
		/* Get the objid of the first row of the "TXOP Limits"			*/
		/* attribute.													*/
		op_ima_obj_attr_get (ac_edca_params_objid, "TXOP Limits", &comp_attr_objid);
		ac_edca_params_objid = op_topo_child (comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
		
		/* Based on the PHY used by this MAC, read the corresponding	*/
		/* TXOP limit value.											*/
		if (phy_char_flag == WlanC_ERP_OFDM_11g || phy_char_flag == WlanC_OFDM_11a)
			op_ima_obj_attr_get (ac_edca_params_objid, "Extended Rate and OFDM", &(bss_edca_params_arr [ac_index].txop_limit));
		else if (phy_char_flag == WlanC_Direct_Sequence)
			op_ima_obj_attr_get (ac_edca_params_objid, "DS-CCK", &(bss_edca_params_arr [ac_index].txop_limit));
		else
			op_ima_obj_attr_get (ac_edca_params_objid, "FHSS and IR", &(bss_edca_params_arr [ac_index].txop_limit));
		}
	
	FOUT;
	}

static void
wlan_hcf_tc_parameters_read (Objid hcf_params_objid)
	{
	int		toggle_attr_value;
	Objid					tc_comp_attr_objid, tid_objid, tid_ba_comp_objid, tid_ba_config_objid;
	int						i, tid;
	
	/** This function reads the values of "Traffic Category"			**/
	/** configuration related attributes and populates the information	**/
	/** record kept	internally for each traffic class.					**/
	FIN (wlan_hcf_tc_parameters_read (Objid hcf_params_objid));
	
	/* Check whether the MAC supports block acknowledgements.			*/
	op_ima_obj_attr_get (hcf_params_objid, "Block ACK Capability", &toggle_attr_value);
	wlan_flags->ba_support = (toggle_attr_value == OPC_BOOLINT_ENABLED) ? OPC_TRUE : OPC_FALSE;
	
	/* Initialize the total size of active reordering buffers.			*/
	total_ba_reorder_buf_size = -1;
	
	/* Obtain the configuration of each traffic class.					*/
	op_ima_obj_attr_get (hcf_params_objid, "Traffic Category Parameters", &tc_comp_attr_objid);
	for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
		{
		/* Get a handle to the current TC and obtain its TID. Note that	*/
		/* the rows of the compound attributes is expected NOT to be	*/
		/* sorted on TID value.											*/
		tid_objid = op_topo_child (tc_comp_attr_objid, OPC_OBJTYPE_GENERIC, i);
		op_ima_obj_attr_get (tid_objid, "TID", &tid);
	
		/* Determine the service class of the current TID. 				*/
		op_ima_obj_attr_get (tid_objid, "Service Class", &(tc_config_arr [tid].ack_policy));
		
		/* If the MAC supports block ACKs and if the service class is	*/
		/* is not "QoSNoACK" then check whether use of block ACK is		*/
		/* requested for the current TID.								*/
		if (wlan_flags->ba_support == OPC_TRUE && tc_config_arr [tid].ack_policy == WlanC_Normal_ACK)
			{
			op_ima_obj_attr_get (tid_objid, "Block ACK Usage", &tid_ba_comp_objid);
			tid_ba_config_objid = op_topo_child (tid_ba_comp_objid, OPC_OBJTYPE_GENERIC, 0);
			op_ima_obj_attr_get (tid_ba_config_objid, "Block ACK Initiation", &toggle_attr_value);
			
			/* If block ACK's are enabled for the TC, update the ACK	*/
			/* policy and read the block ACK parameter values.			*/
			if (toggle_attr_value == OPC_BOOLINT_ENABLED)
				{
				tc_config_arr [tid].ack_policy = WlanC_Block_ACK;
				op_ima_obj_attr_get (tid_ba_config_objid, "Policy", &toggle_attr_value);
				tc_config_arr [tid].ba_policy = (toggle_attr_value == OPC_BOOLINT_DISABLED) ? WlanC_Immediate_BA : WlanC_Delayed_BA;
				op_ima_obj_attr_get (tid_ba_config_objid, "Requested Block Size", &(tc_config_arr [tid].ba_block_size));
				op_ima_obj_attr_get (tid_ba_config_objid, "Inactivity Timeout Value", &(tc_config_arr [tid].ba_timeout_value));
				}
			}
		}
		
	FOUT;
	}

static WlanT_HCF_Access_Category
wlan_hcf_higher_layer_data_arrival (void)
	{
	Packet*						hld_pkptr;
	OpT_Packet_Size				data_size, frag_size;
	OpT_Int64					dest_addr; 
	int							protocol_type;
	int							up;
	WlanT_HCF_Access_Category	ac;
	Ici*						ici_ptr;
	WlanT_HCF_Peer_Info*		dest_info_ptr = PRGC_NIL;
	const IpT_Dgram_Fields*		ip_header_fields_ptr;
	
	/*
	int myDatasize;
	int frameN, packetN, packetStatus,FrameSizeInPackets,imageLineNumber,q,i;
	*/
	
	/** Queue the packet as it arrives from higher layer. Also, store	**/
	/** the destination address of the packet in the queue and the		**/
	/** arrival time. Return the access category of the higher layer	**/
	/** packet if it is successfully queued, otherwise return			**/
	/** WlanC_AC_None.													**/
	FIN (wlan_hcf_higher_layer_data_arrival (void));

	/* Get packet from the incoming stream from higher layer and obtain	*/
	/* the packet size.*/
	
	//printf("Entered higher layer data arrival.\n");
	hld_pkptr = op_pk_get (instrm_from_mac_if);	
	//printf("got packet hld_pkptr.\n");
	
	/* If we are in a bridge/switch node, then we don't accept any		*/
	/* higher layer packet unless we are AP enabled.					*/
	if ((wlan_flags->bridge_flag == OPC_TRUE) && (ap_flag == OPC_BOOLINT_DISABLED))
		{
		//printf("first if statement taken, about to destroy packet.\n");
		op_pk_destroy (hld_pkptr);
		//printf("destroyed packet in first if.\n");
		FRET (WlanC_AC_None);
		}
	//printf("about to get ici_ptr.\n");
	
	/* Read ICI parameters at the stream interrupt.						*/
	ici_ptr = op_intrpt_ici ();
	//printf("got ici_ptr about to get dest_addr.\n");
	
	/* Get the destination address from the ICI.						*/
	op_ici_attr_get_int64 (ici_ptr, "dest_addr", &dest_addr);
	//printf("got dest_addr, about to get protocol_type.\n");
	
	/* Get the protocol information of the higher layer data from ICI.	*/
	op_ici_attr_get_int32 (ici_ptr, "protocol_type", &protocol_type);
	//printf("got protocol_type, about to do second if statement.\n");
	
	/* Check for an AP bridge whether the destined station exists in	*/
	/* the BSS or not. If not then no need to broadcast the packet.		*/
	if (wlan_flags->bridge_flag == OPC_TRUE && ap_flag == OPC_BOOLINT_ENABLED)
		{
		/* If the destination station doesn't exist in the BSS then no	*/
		/* need to broadcast the packet.								*/
		//printf("took second if, is dest >= 0.\n");
		if (dest_addr >= 0)
			{
			printf("dest >= 0, get dest_info_ptr.\n");
			dest_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(dest_addr));
			printf("got dest_info_ptr.\n");
			if (dest_info_ptr == PRGC_NIL)
				{
				//printf("about to do second destroy packet.\n");
				op_pk_destroy (hld_pkptr);	
				//printf("did second destroy packet.\n");
				FRET (WlanC_AC_None);	
				}
			}
		}
	//printf("about to get data size of packet.\n");
	
	/* Get the size of the packet arrived from higher layer.			*/
	data_size = op_pk_total_size_get (hld_pkptr);
	//printf("got size of packet.\n");
	
	/*//read data recorded by the app regarding data size 
	
		if(opencvDebugFlag)
			{
			op_pk_fd_get (hld_pkptr, 1, &frameN);
			op_pk_fd_get (hld_pkptr, 2, &packetN);
			op_pk_fd_get (hld_pkptr, 3, &packetStatus);
			op_pk_fd_get (hld_pkptr, 4, &FrameSizeInPackets);
			if(current_time > 21)
				{
				op_pk_fd_get (hld_pkptr, 5, &imageLineNumber);
				op_pk_fd_get (hld_pkptr, 6, & q);
				}
			op_pk_fd_get (hld_pkptr, 7, &myDatasize);
			
			
			opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
			fprintf(opencvDebugFile,"MAC %d:frameN = %d\tpacketN=%d\tFrameSizeInPackets=%d\tpacketStatus=%d\tcurrent_time=%f\timageLineNumber=%d\tq=%d\tmyDatasize=%d\n"
				,(int)my_address,(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)packetStatus,(float)current_time,imageLineNumber,q,myDatasize);
			fclose(opencvDebugFile);
			}
	*/
	
	
	
	/* Find out the UP information. If the higher layer packet is an	*/
	/* IP packet, then retrieve the information from the IP header,		*/
	/* otherwise obtain it from the ICI.								*/
	if (wlan_flags->nqsta_operation == OPC_FALSE)
		{
		if (protocol_type == OMSC_PROTOCOL_TYPE_IP)
			{
			/* Obtain the UP information from the ToS field of the IP	*/
			/* header. Shift the number to right by 5 bits to skip the	*/
			/* DSCP	bits.												*/
			op_pk_nfd_access_read_only_ptr (hld_pkptr, "fields", (const void **) &ip_header_fields_ptr);
			up = (ip_header_fields_ptr->tos >> 5);
			}
		else if (op_ici_attr_exists (ici_ptr, "type_of_service"))
			op_ici_attr_get_int32 (ici_ptr, "type_of_service", &up);
		else
			/* For higher layer packets that don't carry any ToS		*/
			/* information, assume their UP 0 (best effort).			*/
			up = 0;
		
		/* Make sure we have a valid user priority value.				*/
		if (up < MIN_UP_VALUE || up > MAX_UP_VALUE)
			wlan_error_print ("Incorrect UP (user priority) value associated with the higher layer packet.", "", "");

		/* Determine the AC corresponding to the packet's UP.			*/
		ac = WLANC_UP_TO_AC_MAPPING_ARRAY [up];
		}
	else
		{
		/* Since we belong to an nQBSS, we will use the DCF access		*/
		/* methods. Use the "best effort" AC to buffer the higher layer	*/
		/* packet.														*/
		ac = WlanC_AC_BE;
		
		/* If there is a UP information within the ICI of the event,	*/
		/* then obtain that information. Although we belong to an nQBSS	*/
		/* currently, at the time when we transmit this higher layer 	*/
		/* packet, we may be in a QBSS and need that information.		*/
		if (op_ici_attr_exists (ici_ptr, "type_of_service"))
			op_ici_attr_get_int32 (ici_ptr, "type_of_service", &up);
		else
			up = WLANC_nQSTA_DATA_UP;
		}	
	
	//printf("point 1.\n");
	
	/* If this is the very first higher layer packet of this AC, then	*/
	/* register the outgoing traffic related statistics of this AC.		*/
	if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [ac]))		
		wlan_hcf_ac_statistics_register (ac, OPC_TRUE);
	
	/* Update all the load statistics, local and global, general and	*/
	/* AC specific.														*/
	op_stat_write (packet_load_handle, 1.0);
	op_stat_write (packet_load_handle, 0.0);
	op_stat_write (bits_load_handle,   (double) data_size);
    op_stat_write (bits_load_handle,   0.0);
	
	data_packet_loaded_in_the_last_stateReport_int_count++;
	
	total_data_sent += data_size;
	
	my_load_sum += data_size;
	//my_load = data_size/(op_sim_time()-last_my_load_calculated_time);
	//last_my_load_calculated_time = op_sim_time();
	
	op_stat_write (global_load_handle, (double) data_size);
    op_stat_write (global_load_handle, 0.0);
	
	op_stat_write (ac_load_pkts_shndl_arr [ac], 1.0);
	op_stat_write (ac_load_pkts_shndl_arr [ac], 0.0);
	op_stat_write (ac_load_bits_shndl_arr [ac], (double) data_size);
    op_stat_write (ac_load_bits_shndl_arr [ac], 0.0);
	op_stat_write (ac_gb_load_shndl_arr [ac],   (double) data_size);
    op_stat_write (ac_gb_load_shndl_arr [ac],   0.0);
	
	//printf("point 2.\n");
	
	/* Determine the size of the MPDUs of the MSDU.						*/
	if ((data_size > frag_threshold) && (frag_threshold != -1))
	{	
		//printf("point 2a.\n");
		frag_size = frag_threshold;
	}
	else
	{
		//printf("point 2b.\n");
		frag_size = data_size;
	}
	//printf("point 2c.\n");
	
	/* Destroy packet if it is more than max msdu length or its size	*/
	/* zero. Also, if the size of the higher layer queue will exceed	*/
	/* its maximum after the insertion of this packet, then discard the	*/
	/* arrived packet. The higher layer is responsible for the			*/
	/* retransmission of this packet.		*/
	
	
	if ((data_size > WLANC_MAXMSDU_LENGTH && accept_large_packets == OPC_BOOLINT_DISABLED) ||
		frag_size > WLANC_MAXMSDU_LENGTH || data_size == 0 || total_hlpk_size + data_size > hld_max_size)
		{
		printf ("data_size = %d, WLANC_MAXMSDU_LENGTH = %d, accept_large_packets = %d, OPC_BOOLINT_DISABLED = %d, frag_size = %d, total_hlpk_size = %d, hld_max_size = %d\n", (int)data_size, (int)WLANC_MAXMSDU_LENGTH, (int)accept_large_packets,
			(int)OPC_BOOLINT_DISABLED, (int)frag_size, (int)total_hlpk_size, (int)hld_max_size);
		//printf("point 2d.\n");
		/* Drop the higher layer packet.	*/
		
		//op_sim_end ("Trying to debug stuff.", "", "", "");
		wlan_hcf_hl_packet_drop (hld_pkptr, data_size, ac);
		//printf("point 2e.\n");
		FRET (WlanC_AC_None); 
		}
	//printf("point 2f.\n");
	
	/* Stamp the packet with the current time. This information will	*/
	/* remain unchanged even if the packet is copied for				*/
	/* retransmissions, and	eventually it will be used by the			*/
	/* destination MAC to compute the end-to-end delay.					*/
	op_pk_stamp (hld_pkptr);
	//printf("point 2g.\n");
	
	/* Enqueue the packet for transmission.								*/	
	wlan_hcf_hlpk_enqueue (hld_pkptr, ac, dest_addr, my_address, up, protocol_type, data_size, dest_info_ptr);
	//printf("point 3.\n");
	
	/* Return the access category of the enqueued higher layer packet.	*/
	FRET (ac);
	}

static void
wlan_hcf_ac_statistics_register (WlanT_HCF_Access_Category ac, Boolean outbound_traf_stats)
	{
	static short	globals_annotated = 0;
	
	/** This function registers the per-AC-dimensioned WLAN statistics	**/
	/** for the given AC. These statistics are divided into two	logical	**/
	/** groups: inbound and outbound traffic statistics. The second		**/
	/** argument specifies the statistics of which group need to be		**/
	/** registered. It also annotates the statistics with the name of	**/
	/** the access category.											**/
	FIN (wlan_hcf_ac_statistics_register (ac, outbound_traf_stats));
	
	/* Are we registering the statistics for inbound or outbound		*/
	/* traffic?															*/
	if (outbound_traf_stats == OPC_TRUE)
		{
		/* Register local and global statistics related to outgoing		*/
		/* traffic for the given access category.						*/
		ac_load_bits_shndl_arr [ac]           = op_stat_reg ("WLAN (Per HCF Access Category).Load (bits/sec)",                                       ac, OPC_STAT_LOCAL);
		ac_load_pkts_shndl_arr [ac]           = op_stat_reg ("WLAN (Per HCF Access Category).Load (packets/sec)",                                    ac, OPC_STAT_LOCAL);
		ac_queue_size_shndl_arr [ac]          = op_stat_reg ("WLAN (Per HCF Access Category).AC Queue Size (packets)",                               ac, OPC_STAT_LOCAL);
		ac_backoff_slots_shndl_arr [ac]	  	  = op_stat_reg ("WLAN (Per HCF Access Category).Backoff Slots (slots)",	   							 ac, OPC_STAT_LOCAL);
		ac_access_delay_shndl_arr [ac]        = op_stat_reg ("WLAN (Per HCF Access Category).Media Access Delay (sec)",                              ac, OPC_STAT_LOCAL);
		ac_dropped_buffer_bits_shndl_arr [ac] = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Buffer Overflow) (bits/sec)",             ac, OPC_STAT_LOCAL);
		ac_dropped_buffer_pkts_shndl_arr [ac] = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Buffer Overflow) (packets/sec)",          ac, OPC_STAT_LOCAL);
		ac_dropped_retx_bits_shndl_arr [ac]   = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Retry Threshold Exceeded) (bits/sec)",    ac, OPC_STAT_LOCAL);
		ac_dropped_retx_pkts_shndl_arr [ac]   = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Retry Threshold Exceeded) (packets/sec)", ac, OPC_STAT_LOCAL);
		ac_gb_load_shndl_arr [ac]             = op_stat_reg ("WLAN (Per HCF Access Category).Load (bits/sec)",                                       ac, OPC_STAT_GLOBAL);
		ac_gb_access_delay_shndl_arr [ac]     = op_stat_reg ("WLAN (Per HCF Access Category).Media Access Delay (sec)",                              ac, OPC_STAT_GLOBAL);
		ac_gb_dropped_buffer_shndl_arr [ac]   = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Buffer Overflow) (bits/sec)",             ac, OPC_STAT_GLOBAL);
		ac_gb_dropped_retx_shndl_arr [ac]     = op_stat_reg ("WLAN (Per HCF Access Category).Data Dropped (Retry Threshold Exceeded) (bits/sec)",    ac, OPC_STAT_GLOBAL);
		
		/* Annotate the statistic names with the name of the access		*/
		/* category.													*/
		op_stat_annotate (ac_load_bits_shndl_arr [ac],           WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_load_pkts_shndl_arr [ac],           WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_queue_size_shndl_arr [ac],          WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_backoff_slots_shndl_arr [ac], 		 WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_access_delay_shndl_arr [ac],        WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_dropped_buffer_bits_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_dropped_buffer_pkts_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_dropped_retx_bits_shndl_arr [ac],   WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_dropped_retx_pkts_shndl_arr [ac],   WLANC_AC_NAME_ARRAY [ac]);
		
		/* No need to annotate the global statistics multiple times.	*/
		if (!(globals_annotated & WLANC_AC_BITMAP_ARRAY [ac]))
			{
			op_stat_annotate (ac_gb_load_shndl_arr [ac],           WLANC_AC_NAME_ARRAY [ac]);
			op_stat_annotate (ac_gb_access_delay_shndl_arr [ac],   WLANC_AC_NAME_ARRAY [ac]);
			op_stat_annotate (ac_gb_dropped_buffer_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);
			op_stat_annotate (ac_gb_dropped_retx_shndl_arr [ac],   WLANC_AC_NAME_ARRAY [ac]);

			/* Set the flag to prevent redundant repetitions.			*/
			globals_annotated |= WLANC_AC_BITMAP_ARRAY [ac];
			}
		
		/* Internal collision count statistic is not collected for the	*/
		/* voice AC.													*/
		if (ac != WlanC_AC_VO)
			{
			ac_internal_coll_shndl_arr [ac]  = op_stat_reg ("WLAN (Per HCF Access Category).Internal Collision Count", ac, OPC_STAT_LOCAL);
			op_stat_annotate (ac_internal_coll_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);
			}
		
		/* Set the flag that indicates that outbound statistics are		*/
		/* registered for this access category.							*/
		wlan_ac_flags->stats_registered |= WLANC_AC_BITMAP_ARRAY [ac];
		}
	else
		{
		/* Register local and global statistics related to incoming		*/
		/* traffic for the given access category.						*/
		ac_delay_shndl_arr [ac]         = op_stat_reg ("WLAN (Per HCF Access Category).Delay (sec)",           ac, OPC_STAT_LOCAL);
		ac_throughput_shndl_arr [ac]    = op_stat_reg ("WLAN (Per HCF Access Category).Throughput (bits/sec)", ac, OPC_STAT_LOCAL);
		ac_gb_delay_shndl_arr [ac]      = op_stat_reg ("WLAN (Per HCF Access Category).Delay (sec)",           ac, OPC_STAT_GLOBAL);
		ac_gb_throughput_shndl_arr [ac] = op_stat_reg ("WLAN (Per HCF Access Category).Throughput (bits/sec)", ac, OPC_STAT_GLOBAL);
		
		/* Annotate the statistic names with the name of the access		*/
		/* category.													*/
		op_stat_annotate (ac_delay_shndl_arr [ac],      WLANC_AC_NAME_ARRAY [ac]);
		op_stat_annotate (ac_throughput_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);

		
		/* No need to annotate the global statistics multiple times.	*/
		if (!(globals_annotated & (WLANC_AC_BITMAP_ARRAY [ac] << WLANC_HCF_AC_COUNT)))
			{
			op_stat_annotate (ac_gb_delay_shndl_arr [ac],      WLANC_AC_NAME_ARRAY [ac]);
			op_stat_annotate (ac_gb_throughput_shndl_arr [ac], WLANC_AC_NAME_ARRAY [ac]);

			/* Set the flag to prevent redundant repetitions.			*/
			globals_annotated |= (WLANC_AC_BITMAP_ARRAY [ac] << WLANC_HCF_AC_COUNT);
			}

		/* Set the flag that indicates that inbound statistics are		*/
		/* registered for this access category.							*/
		wlan_ac_flags->stats_registered |= (WLANC_AC_BITMAP_ARRAY [ac] << WLANC_HCF_AC_COUNT);
		}

	FOUT;
	}

static void
wlan_hcf_hl_packet_drop (Packet* hld_pkptr, OpT_Packet_Size data_size, WlanT_HCF_Access_Category ac)
	{
	int		large_packet_bit = 0x1;
	int		full_buffer_bit  = 0x2;

	/** This function drops the higher layer packets or packets **/
	/** received by the AP and need to be forwarded within the	**/
	/** BSS that can be accepted because of full buffer or		**/
	/** large size of the packet. It also writes an appropriate	**/
	/** log message to report the rejection unless the same log	**/
	/** message is already written before, and updates the		**/
	/** related dropped higher layer data statistics.			**/
	FIN (wlan_hcf_hl_packet_drop (hld_pkptr, data_size, ac));
	
	/* Write an appropriate simulation log message unless the	*/
	/* same message is written before.							*/
	
	//Loren: Debugging
	if(LorenDebugFlag)
	{
		printf("entered higher layer packet drop function.\n");
	}
	
	if (drop_pkt_entry_log_flag < full_buffer_bit + large_packet_bit)
		{
		
		//Loren: Debugging
		if(LorenDebugFlag)
		{
			printf("entered higher layer packet drop first if statement.\n");
		}
		
		if (total_hlpk_size + data_size > hld_max_size && !(drop_pkt_entry_log_flag & full_buffer_bit))
			{
			
			//Loren: Debugging
			if(LorenDebugFlag)
			{
				printf("entered higher layer packet drop second if statement.\n");
			}	
				
			/* Writing log message for dropped packets.			*/
			op_prg_log_entry_write (drop_pkt_log_handle, 
				"SYMPTOM(S):\n"
				" Wireless LAN MAC layer discarded some packets due to\n "
			    " insufficient buffer capacity. \n"
				"\n"
			    " This may lead to: \n"
  			    " - application data loss.\n"
			    " - higher layer packet retransmission.\n"
			    "\n"
			    " REMEDIAL ACTION(S): \n"
			    " 1. Reduce network load. \n"
			    " 2. Use a higher wireless LAN data rate. \n"
			    " 3. Increase buffer capacity\n");
			drop_pkt_entry_log_flag += full_buffer_bit;
			}
			
		else if (total_hlpk_size + data_size <= hld_max_size && data_size > 0 && !(drop_pkt_entry_log_flag & large_packet_bit))
			{
			
			//Loren: Debugging
			if(LorenDebugFlag)
			{
				printf("entered higher layer packet drop else if statement.\n");
			}
			
			/* Writing log message for dropped packets due to	*/
			/* packet size.										*/
			op_prg_log_entry_write (drop_pkt_log_handle, 
				"SYMPTOM(S):\n"
			    " Wireless LAN MAC layer discarded some packets due to \n"
			    " their large sizes. This is an expected protocol \n"
				" behavior. \n"	
				"\n"
			    " This may lead to: \n"
  			    " - application data loss.\n"
			    " - higher layer packet retransmission.\n"
			    "\n"
			    " SUGGESTION(S): \n"
			    " 1. Set the higher layer packet size to \n"
				"    be smaller than max MSDU size (2304 bytes). \n"
			    " 2. Enable fragmentation threshold and large packet \n"
				"    processing. \n");
			drop_pkt_entry_log_flag += large_packet_bit;
			}
		}
	
	//Loren: debugging
	if(LorenDebugFlag)
	{
		printf("entered higher layer packet drop function, about to print packet.\n");
		op_pk_print(hld_pkptr);
		printf("entered higher layer packet drop function, about to destroy packet.\n");
	}
		
	/* Destroy the dropped packet.								*/
	op_pk_format(hld_pkptr, fmt_name);
	if(LorenDebugFlag)
	{
		printf("I am  %d: hld_pkptr is of type %s\n",(int)my_address, fmt_name);
	}
	
	if(strcmp(fmt_name, "my_rtp_pkt") != 0)
	{
		op_pk_destroy (hld_pkptr);
	}
	
	else
	{	
		op_prg_mem_free(hld_pkptr); 
	}
	
	//Loren: Debugging
	if(LorenDebugFlag)
	{
		printf("entered higher layer packet drop function, destroyed packet.\n");	
	}
	
	/* Update local and global, general and AC specific			*/
	/* statistics that keep track of the dropped data traffic	*/
	/* due to full buffer or large size of the data packet.		*/
	op_stat_write (buffer_drop_pkts_handle,               1.0);
	op_stat_write (buffer_drop_pkts_handle,               0.0);
	op_stat_write (buffer_drop_bits_handle,               (double) data_size);
	op_stat_write (buffer_drop_bits_handle,               0.0);
	
	//my_droppedB = data_size/(op_sim_time()-last_my_droppedB_calculated_time);
	//last_my_droppedB_calculated_time = op_sim_time();
	my_droppedB_sum += data_size;
	data_packet_droppedB_in_the_last_stateReport_int_count ++;
	
	op_stat_write (global_buffer_drop_handle,             (double) data_size);
	op_stat_write (global_buffer_drop_handle,             0.0);
	op_stat_write (ac_dropped_buffer_pkts_shndl_arr [ac], 1.0);
	op_stat_write (ac_dropped_buffer_pkts_shndl_arr [ac], 0.0);
	op_stat_write (ac_dropped_buffer_bits_shndl_arr [ac], (double) data_size);
	op_stat_write (ac_dropped_buffer_bits_shndl_arr [ac], 0.0);
	op_stat_write (ac_gb_dropped_buffer_shndl_arr [ac],   (double) data_size);
	op_stat_write (ac_gb_dropped_buffer_shndl_arr [ac],   0.0);
	
	//Loren: Debugging
	if(LorenDebugFlag)
	{
		printf("exiting higher layer packet drop function.\n");
	}
	
	FOUT;
	}


static void
wlan_hcf_hlpk_enqueue (Packet* hld_pkptr, WlanT_HCF_Access_Category ac, OpT_Int64 dest_addr, OpT_Int64 orig_addr, int up, int protocol_type,
					   OpT_Packet_Size data_size, WlanT_HCF_Peer_Info* dest_info_ptr)
	{
	char						msg_string [128];
	char						msg_string1 [128];
	WlanT_HCF_Hld_Info*			hld_ptr;
	WlanT_HCF_BA_State*			dest_tid_ba_info_ptr;
	WlanT_HCF_Access_Category	temp_ac;
	int							i;
	
	/** Insert the given higher layer packet into the queue of the		**/
	/** corresponding access category based on the user priority (UP)	**/
	/** associated with the packet.										**/
	FIN (wlan_hcf_hlpk_enqueue (hld_pkptr, ac, dest_addr, orig_addr, up, protocol_type, data_size, dest_info_ptr));

	/* Allocating pool memory to the higher layer data structure type. 	*/	
	hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);

	/* Generate error message and abort simulation if no memory left	*/
	/* for data received from higher layer.								*/
	if (hld_ptr == OPC_NIL)
		{
		wlan_error_print ("No more memory left to assign for data received from higher layer", OPC_NIL, OPC_NIL);
		}

	/* Updating higher layer data structure fields.						*/
	hld_ptr->pkptr         = hld_pkptr;
	hld_ptr->dest_addr     = dest_addr;
	hld_ptr->orig_addr     = orig_addr;
	hld_ptr->up 	       = (OpT_uInt8) up;
	hld_ptr->protocol_type = protocol_type;
	hld_ptr->ba_retx       = OPC_FALSE;
	hld_ptr->size	       = data_size;
	hld_ptr->time_rcvd     = current_time;
	
	/* Store a handle to the record of packet's immediate destination	*/
	/* in packet's record for quick access during the life time of this	*/
	/* higher layer data in this MAC. This information may have been	*/
	/* provided by the calling code.									*/
	if (dest_info_ptr == PRGC_NIL)
		{
		if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
			hld_ptr->addr1_info_ptr = ap_peer_info_ptr;
		else if (dest_addr < 0)
			hld_ptr->addr1_info_ptr = PRGC_NIL;
		else 
			hld_ptr->addr1_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(hld_ptr->dest_addr));
		}
	else
		hld_ptr->addr1_info_ptr = dest_info_ptr;

	/* Based on the capabilities of the immediate destination (QSTA or	*/
	/* nQSTA) transmit the higher layer packet as a QoS Data frame or	*/
	/* as a regular Data frame. For broadcast packets, for the moment,	*/
	/* assume that we will send them as QoS Data frames. We will choose	*/
	/* the type at the time of transmission based on the presence of	*/
	/* nQSTAs in the BSS at that moment. If no record exists, because	*/
	/* the destination MAC is not in our BSS, use a QoS	Data frame for	*/
	/* transmission.													*/
	hld_ptr->type = (hld_ptr->addr1_info_ptr == PRGC_NIL || hld_ptr->addr1_info_ptr->is_qsta == OPC_TRUE) ? WlanC_QoS_Data : WlanC_Data;

	/* Decide the ACK policy to be used for this higher layer packet.	*/
	/* No acknowledgement is expected for broadcast packets.			*/
	if (dest_addr < 0 && wlan_flags->ad_hoc_or_ap == OPC_TRUE)
		hld_ptr->ack_policy = WlanC_No_ACK;
	
	/* Unicast legacy data frames has to be acknowledged.				*/
	else if (hld_ptr->type == WlanC_Data)
		hld_ptr->ack_policy = WlanC_Normal_ACK;
	
	/* Check the ACK policy for packet's UP. If it is block ACK then we	*/
	/* need to check existence of a block ACK agreement with the		*/
	/* destination.														*/
	else if (tc_config_arr [up].ack_policy != WlanC_Block_ACK)
		hld_ptr->ack_policy = tc_config_arr [up].ack_policy;
	
	else
		{
		/* The TC configuration of packet's UP requires use of block	*/
		/* ACKs when possible. Check whether we have a block ACK		*/
		/* agreement with the destination. 								*/
		if (hld_ptr->addr1_info_ptr->ba_support == OPC_TRUE)
			{
			/* Get our BA record for this peer and TID. This function	*/
			/* will create the record if it doesn't exist.				*/
			dest_tid_ba_info_ptr = wlan_hcf_ba_state_info_get (hld_ptr->addr1_info_ptr, 
															   (hld_ptr->addr1_info_ptr == ap_peer_info_ptr) ? ap_mac_address : dest_addr, (OpT_uInt8) up);
			
			/* Send an ADDBA request if this is the first of packet of	*/
			/* the data flow.											*/
			if (dest_tid_ba_info_ptr->status == WlanC_BA_Uninitiated)
				{
				dest_tid_ba_info_ptr->status = WlanC_BA_Requested;
				wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_ADDBA_Request, up, dest_tid_ba_info_ptr->peer_addr, 
														   hld_ptr->addr1_info_ptr->tid_seq_counter_arr [up], OPC_TRUE);
				
				/* Until an agreement, use normal ACK.					*/
				hld_ptr->ack_policy = WlanC_Normal_ACK;
				}
			
			/* Request block ACK if an agreement is in place.			*/	
			else if (dest_tid_ba_info_ptr->status == WlanC_BA_Established)
				{
				hld_ptr->ack_policy = WlanC_Block_ACK;
				dest_tid_ba_info_ptr->queued_msdu_count++;
				}
			else
				{
				/* Already sent an ADDBA, still waiting for a response	*/
				/* (or could not establish BA agreement with the peer	*/
				/* despite various trials). Continue using normal ACK.	*/
				hld_ptr->ack_policy = WlanC_Normal_ACK;
				}
			}
		else
			/* Destination is not block ACK capable.					*/
			hld_ptr->ack_policy = WlanC_Normal_ACK;
		}
	
	/* Insert the packet into the higher layer queue of its AC.			*/
	op_prg_list_insert (hlpk_lptr_arr [ac], hld_ptr, OPC_LISTPOS_TAIL);	
	
	/* Adjust the total size and number of all data packets in all AC	*/
	/* queues.															*/
	if(LorenDebugFlag)
	{
		printf("Total_hlpk_num before increment #1 = %d, total_hlpk_size before increment #1 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
	}
	total_hlpk_num++;
	total_hlpk_size += data_size;
	if(LorenDebugFlag)
	{
		printf("Total_hlpk_num after increment #1 = %d, total_hlpk_size before increment #1 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
	}

	/* Update the queue size statistic.									*/
	op_stat_write (hl_packets_rcvd, (double) total_hlpk_num);
	
	/* Also update the size information of AC's queue under the			*/
	/* corresponding statistic.											*/
	op_stat_write (ac_queue_size_shndl_arr [ac], (double) op_prg_list_size (hlpk_lptr_arr [ac]));
	
	/* Queued packets are also recorded under the network load			*/
	/* statistic.														*/
	Oms_Dim_Stat_Write (global_network_load_handle, (double) data_size);
	Oms_Dim_Stat_Write (global_network_load_handle, 0.0);
	
	/* Printing out information to ODB.									*/
	if (wlan_trace_active == OPC_TRUE)
		{
		sprintf (msg_string,  "Received the packet with ID " OPC_PACKET_ID_FMT " belonging to the access category %s for", 
							  op_pk_id (hld_ptr->pkptr), WLANC_AC_NAME_ARRAY [ac]);
		sprintf	(msg_string1, "transmission. The outbound data queue size for this AC is %d packet(s).", 
							  op_prg_list_size (hlpk_lptr_arr [ac])); 	
		op_prg_odb_print_major (msg_string, msg_string1, OPC_NIL);
		}

	/* If the queue was empty then update its status in the queue		*/
	/* status array.													*/
	if (op_prg_list_size (hlpk_lptr_arr [ac]) == 1 && !(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [ac]))
		{
		/* Insert the category into the list of the categories with		*/
		/* non-empty queues. Make sure that the list remains sorted.	*/
		for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
			{
			if (ac > ac_queue_status_arr [i])
				{
				temp_ac = ac;
				ac = ac_queue_status_arr [i];
				ac_queue_status_arr [i] = temp_ac;
				}
			}
		ac_queue_status_arr [i] = ac;
		}
		
	FOUT;
	}

static OpT_Packet_Size
wlan_hcf_hlpk_dequeue (WlanT_HCF_Access_Category ac, int queue_pos)
	{
	if(LorenDebugFlag)
	{
		printf("Entered hlpk dequeue.\n");
	}
	WlanT_HCF_Hld_Info*	hld_ptr;
	OpT_Packet_Size		ret_value;

	/** This function removes the higher layer packet entry at the		**/
	/** given position from the queue of the given access category.		**/
	/** This function is typically called for the entry at the head of	**/
	/** the queue, when the higher layer packet is completely			**/
	/** transmitted	and its ACK is received (if required), or if the	**/
	/** packet is unsuccessfully transmitted "retry limit" times. APs	**/
	/** may also call this functions to dequeue entries that are not	**/
	/** at the head of the queue, to remove the frames from the 		**/
	/** transmission buffer that are destined to an STA that has just	**/
	/** disassociated from AP's BSS. The function returns the size of	**/
	/** the dequeued packet.											**/
	FIN (wlan_hcf_hlpk_dequeue (ac, queue_pos));
	
	/* Remove the information record of the higher layer packet from	*/
	/* the queue of the given access category. Note that the packet		*/
	/* itself is not in the queue, just the record is in the queue. The	*/
	/* packet is removed during the transmission process for			*/
	/* fragmentation and transmission.									*/
	hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [ac], queue_pos);

	/* Decrease the buffer usage by queued higher layer packets. In		*/
	/* case of MPDUs transmitted as a part of a block when block-ACK	*/
	/* policy is in use, don't subtract their sizes from buffer usage,	*/
	/* since they are actually still kept in the retransmission buffer	*/
	/* and fully removed from the MAC only when	the corresponding BA is	*/
	/* received.														*/
	if (hld_ptr->ack_policy != WlanC_Block_ACK)
		{
		if(LorenDebugFlag)
		{
		printf("total_hlpk_size before decrement #1 = %d\n", (int)total_hlpk_size);
		}
		total_hlpk_size -= hld_ptr->size;
		if(LorenDebugFlag)
		{
		printf("total_hlpk_size after decrement #1 = %d\n", (int)total_hlpk_size);
		}
		}

	/* Decrement the number of queued packets and update the queue size	*/
	/* statistic.														*/
	total_hlpk_num--;
	op_stat_write (hl_packets_rcvd, (double) total_hlpk_num);
	
	/* Also update the size information of AC's queue under the			*/
	/* corresponding statistic.											*/
	op_stat_write (ac_queue_size_shndl_arr [ac], (double) op_prg_list_size (hlpk_lptr_arr [ac]));
	
	/* If the entry is still holding a packet, destroy the packet.		*/
	if (hld_ptr->pkptr != OPC_NIL)
		op_pk_destroy (hld_ptr->pkptr);
	
	/* Store the return value and destroy the record.					*/
	ret_value = hld_ptr->size;
	op_prg_mem_free (hld_ptr);
	
	/* Return the size of the dequeued packet.							*/	
	FRET (ret_value);
	}

static void
wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanT_Act_Mgmt_Category category, WlanT_Act_Mgmt_Action action, int tid, OpT_Int64 dest_addr, 
										   int start_seq_num, Boolean ba_initiator)
	{
	Packet*				mmpdu_ptr;
	WlanT_ADDBA_Fields*	addba_info_ptr;
	WlanT_DELBA_Fields*	delba_info_ptr;
	OpT_Packet_Size		frame_size;
	char				msg_string [128];

	/** This function creates an action MMPDU for the given category,	**/
	/** action, destination address and TID, and enqueues it for		**/
	/** transmission.													**/
	FIN (wlan_hcf_action_mmpdu_prepare_and_enqueue (category, action, tid, dest_addr, start_seq_num, ba_initiator));
	
	/* Create the action MMPDU frame and set its category, action and	*/
	/* TID fields.														*/
	mmpdu_ptr = op_pk_create_fmt ("wlan_action_mmpdu_body");
	op_pk_fd_set_int32 (mmpdu_ptr, WLANC_ACT_MGMT_CAT_ACT_FD, (category << WLANC_MMPDU_ACTION_FD_SIZE) + action, OPC_FIELD_SIZE_UNCHANGED);
	op_pk_fd_set_int32 (mmpdu_ptr, WLANC_ACT_MGMT_TID_FD, tid, OPC_FIELD_SIZE_UNCHANGED);
	
	/* Set the action specific parameters.								*/
	switch (action)
		{
		case WlanC_Action_ADDBA_Request:
			{
			/* Set the ADDBA request specific fields.					*/ 
			addba_info_ptr = (WlanT_ADDBA_Fields *) op_prg_mem_alloc (sizeof (WlanT_ADDBA_Fields));
			addba_info_ptr->policy        = tc_config_arr [tid].ba_policy;
			addba_info_ptr->block_size    = tc_config_arr [tid].ba_block_size;
			addba_info_ptr->timeout_value = tc_config_arr [tid].ba_timeout_value;
			
			/* Set the starting sequence control to the current value	*/
			/* of the sequence number counter we have for this peer and	*/
			/* TID, provided by the calling code. It is OK if the MPDUs	*/
			/* that will be the first ones using block-ACK policy have	*/
			/* sequence numbers higher than	this.						*/
			addba_info_ptr->starting_seq_num = start_seq_num;
			
			/* Insert the structure into the packet.					*/
			op_pk_fd_set_ptr (mmpdu_ptr, WLANC_ACT_MGMT_PARAMS_FD, addba_info_ptr, OPC_FIELD_SIZE_UNCHANGED,	
						      op_prg_mem_copy_create, op_prg_mem_free, sizeof (WlanT_ADDBA_Fields));
			frame_size = WLANC_ACT_MGMT_ADDBA_SIZE;
						
			/* Write an ODB message if enabled.							*/
			if (wlan_trace_active)
				{
				sprintf (msg_string,  "Enqueuing ADDBA request message for STA "OPC_INT64_FMT", TID %d.", dest_addr, tid); 
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			break;
			}
			
		case WlanC_Action_ADDBA_Response:
			{
			/* Set local variable to the total size of ADDBA response.	*/
			frame_size = WLANC_ACT_MGMT_ADDBA_SIZE;
						
			/* Write an ODB message if enabled.							*/
			if (wlan_trace_active)
				{
				sprintf (msg_string, "Enqueuing ADDBA response to received request from STA "OPC_INT64_FMT" for TID %d.\n", dest_addr, tid); 
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			break;
			}
			
		case WlanC_Action_DELBA:
			{
			/* Set the DELBA specific fields.							*/ 
			delba_info_ptr = (WlanT_DELBA_Fields *) op_prg_mem_alloc (sizeof (WlanT_DELBA_Fields));
			delba_info_ptr->initiator = ba_initiator;        
			
			/* Insert the structure into the packet.					*/
			op_pk_fd_set_ptr (mmpdu_ptr, WLANC_ACT_MGMT_PARAMS_FD, delba_info_ptr, OPC_FIELD_SIZE_UNCHANGED,	
						      op_prg_mem_copy_create, op_prg_mem_free, sizeof (WlanT_DELBA_Fields));
			frame_size = WLANC_ACT_MGMT_DELBA_SIZE;
						
			/* Write an ODB message if enabled.							*/
			if (wlan_trace_active)
				{
				sprintf (msg_string,  "Enqueuing DELBA message as %s for STA "OPC_INT64_FMT", TID %d.\n", (ba_initiator == OPC_TRUE) ? "originator" : "recipient", dest_addr, tid); 
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			break;
			}			
		}	
	
	/* Make sure the size of the frame is modeled correctly.			*/
	op_pk_total_size_set (mmpdu_ptr, frame_size);
	
	/* Enqueue the packet in the queue of voice access category.		*/
	wlan_hcf_mmpdu_enqueue (mmpdu_ptr, dest_addr, frame_size, WlanC_Action, 
							(((category << WLANC_MMPDU_ACTION_FD_SIZE) + action) << WLANC_MMPDU_TID_FD_SIZE) + tid);
	
	FOUT;
	}

static void
wlan_hcf_mmpdu_enqueue (Packet* mmpdu_pkptr, OpT_Int64 dest_addr, OpT_Packet_Size size, WlanT_Mac_Frame_Type frame_type, unsigned int cat_action_tid)
	{
	WlanT_HCF_Hld_Info*			hld_ptr;
	WlanT_HCF_Hld_Info*			cur_hld_ptr;
	List*						voice_ac_hlpk_lptr;
	int							voice_ac_list_size, i;
	Boolean						found;
	WlanT_HCF_Access_Category	new_ac, temp_ac;
		
	/** This function enqueues an entry in the Voice AC transmission	**/
	/** queue for the MMPDU, whose frame body and type, size and 		**/
	/** destination information are provided.							**/
	FIN (wlan_hcf_mmpdu_enqueue (mmpdu_pkptr, dest_addr, size, frame_type, cat_action_tid));

	/* Allocating pool memory to the higher layer data structure type. 	*/	
	hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);

	/* Generate error message and abort simulation if no memory left	*/
	/* for data received from higher layer.								*/
	if (hld_ptr == OPC_NIL)
		{
		wlan_error_print ("No more memory left to assign for data received from higher layer", OPC_NIL, OPC_NIL);
		}

	/* Updating higher layer data structure fields.						*/
	hld_ptr->pkptr      	  	  = mmpdu_pkptr;
	hld_ptr->dest_addr  	  	  = dest_addr;
	hld_ptr->orig_addr			  = bss_id;
	hld_ptr->up 	    	  	  = MAX_UP_VALUE;
	hld_ptr->mmpdu_cat_action_tid = cat_action_tid;
	hld_ptr->size	    	  	  = size;
	hld_ptr->time_rcvd  	  	  = current_time;
	hld_ptr->type       	  	  = frame_type;
	hld_ptr->ack_policy 	  	  = WlanC_Normal_ACK;	
	hld_ptr->ba_retx    	  	  = OPC_FALSE;
	if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
		hld_ptr->addr1_info_ptr = ap_peer_info_ptr;
	else 
		hld_ptr->addr1_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(dest_addr));
	
	/* Insert the frame in the queue of voice AC. First check whether	*/
	/* it is empty.														*/
	voice_ac_hlpk_lptr = hlpk_lptr_arr [WlanC_AC_VO];
	voice_ac_list_size = op_prg_list_size (voice_ac_hlpk_lptr);
	if (voice_ac_list_size == 0)
		{
		/* Insert the entry into the queue.								*/
		op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, OPC_LISTPOS_HEAD);
			
		/* Also update the queue status array if necessary.				*/
		if(!(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]))
			{
			/* Insert voice to the top of the list of contending ACs.	*/
			/* Make sure that the list remains sorted.					*/
			for (i = 0, new_ac = WlanC_AC_VO; ac_queue_status_arr [i] != WlanC_AC_None; i++)
				{
				temp_ac = new_ac;
				new_ac = ac_queue_status_arr [i];						
				ac_queue_status_arr [i] = temp_ac;
				}
			ac_queue_status_arr [i] = new_ac;
			}
		
		/* If we are currently contending for the medium (deferring in	*/
		/* the "IFS and BACKOFF" state), then add the voice AC to the	*/
		/* set of contending ACs.										*/
		if (backoff_ac != WlanC_AC_None && op_ev_valid (deference_info_arr [backoff_ac].deference_end_evh) &&
			op_ev_pending (deference_info_arr [backoff_ac].deference_end_evh))
			wlan_hcf_new_ac_to_contention_add (WlanC_AC_VO);
		
		/* Unless we have already done it before, register Voice AC		*/
		/* statistics for outbound traffic, which will be updated while	*/
		/* sending management frames.									*/
		if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]))
			wlan_hcf_ac_statistics_register (WlanC_AC_VO, OPC_TRUE);
		}
	else
		{
		/* The queue is non-empty. We will insert this management frame	*/
		/* to the head of the queue but behind any  frames that are		*/
		/* already being transmitted, and any BAR/BA control frames and	*/
		/* management frames that are already in the queue. First find	*/
		/* the lowest queue index after excluding frames being			*/
		/* transmitted.													*/
		i = wlan_hcf_ac_queue_transmission_status_check (voice_ac_hlpk_lptr, WlanC_AC_VO);
		
		/* Now skip control/management frames already queued, if any.	*/
		for (found = OPC_FALSE; i < voice_ac_list_size && found == OPC_FALSE;)
			{
			/* Access the record of the current queued frame.			*/
			cur_hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (voice_ac_hlpk_lptr, i);

			/* Skip the frames if they are control and management		*/
			/* frames. If it is	not a data frame, then it must be a 	*/
			/* control or management frame.								*/	
			if (!(cur_hld_ptr->type & WLANC_DATA_TYPE_BIT))
				i++;
			else
				found = OPC_TRUE;
			}
		
		/* Insert the packet into the queue at the computed index.		*/
		op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, i);
		}		
	
	/* Adjust the total size and number of all data packets in all AC	*/
	if(LorenDebugFlag)
	{
		printf("Total_hlpk_num before increment #2 = %d, total_hlpk_size before increment #2 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
	}
	total_hlpk_num++;
	total_hlpk_size += size;
	if(LorenDebugFlag)
	{
		printf("Total_hlpk_num after increment #2 = %d, total_hlpk_size before increment #2 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
	}

	/* Update the queue size statistic.									*/
	op_stat_write (hl_packets_rcvd, (double) total_hlpk_num);
	
	/* Also update the size information of AC's queue under the			*/
	/* corresponding statistic											*/
	op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) ++voice_ac_list_size);
	
	FOUT;
	}

static void
wlan_hcf_new_ac_to_contention_add (WlanT_HCF_Access_Category new_ac)
	{
	int		new_ac_total_slots, winner_ac_total_slots;
	double	new_ac_backoff_end;
	
	/** This function handles the addition of a new AC to the list of	**/
	/** contending ACs of the surrounding MAC. It terminates the		**/
	/** deference and proceeds with the transmission if the new AC is	**/
	/** allowed for an immediate transmission. Otherwise, it			**/
	/** reschedules the "end of deference" interrupt if the new AC		**/
	/** turns out to have the shortest "AIFSN + back-off" period.		**/
	FIN (wlan_hcf_new_ac_to_contention_add (new_ac));
	
	/* Check whether any CW-backoff is scheduled for the new AC.		*/
	if (wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [new_ac])
		{
		/* Is the CW-backoff of this AC is over, or still ongoing?		*/
		new_ac_backoff_end = bk_medium_idle_time + sifs_time + slot_time * (aifsn_arr [new_ac] + deference_info_arr [new_ac].backoff_slots);
		if (new_ac_backoff_end < current_time)
			{
			/* The CW-backoff is actually over. The AC can start its	*/
			/* transmission immediately.								*/
			wlan_flags->immediate_xmt = OPC_TRUE;
			cur_tx_ac = new_ac;
			
			/* Suspend the ongoing backoffs.							*/
			op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
			
			/* Reset the backoff slot count and CW-required bit of the	*/
			/* AC.														*/
			deference_info_arr [cur_tx_ac].backoff_slots = BACKOFF_SLOTS_UNSET;
			wlan_ac_flags->cw_required ^= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
			
			/* Compute the remaining backoff slots for other contending	*/
			/* ACs.														*/
			wlan_hcf_suspended_backoff_remaining_slots_compute (cur_tx_ac);
			}
		else
			{
			/* Convert the still ongoing CW-backoff of this AC to a		*/
			/* regular backoff.											*/
			deference_info_arr [new_ac].type = WlanC_Backoff_Elapsed;
			
			/* If this new AC becomes the new winner among the active	*/
			/* ACs, then reschedule the end of backoff interrupt.		*/
			if (deference_info_arr [backoff_ac].type == WlanC_CW_Elapsed || new_ac_backoff_end < intrpt_time ||
				(new_ac_backoff_end - intrpt_time < PRECISION_RECOVERY && new_ac >= backoff_ac)) /* i.e., new_ac_backoff_end == intrpt_time && new_ac >= backoff_ac */
				{
				/* The new AC is the new winner. Reschedule the			*/
				/* interrupt.											*/
				op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
				backoff_ac = new_ac;
				intrpt_time = new_ac_backoff_end;
				deference_info_arr [backoff_ac].deference_end_evh = op_intrpt_schedule_self (intrpt_time, WlanC_Backoff_Elapsed);
				}
			}
		}
	else
		{
		/* Check whether immediate transmission is possible.			*/
		if (current_time - MEDIUM_IDLE_TIME > aifs_arr [new_ac])
			{
			/* Immediate transmission is allowed.						*/
			wlan_flags->immediate_xmt = OPC_TRUE;
			cur_tx_ac = new_ac;
			
			/* Suspend the ongoing backoffs.							*/
			op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
			
			/* Compute the remaining backoff slots for each AC.			*/
			wlan_hcf_suspended_backoff_remaining_slots_compute (cur_tx_ac);
			}
		else
			{
			/* Immediate transmission was not possible. Then add this	*/
			/* new AC to the set of contending ACs by starting a		*/
			/* backoff process for it, too. Pick a random number of		*/
			/* slots for its backoff and set the type of the backoff to	*/
			/* regular backoff.											*/
			deference_info_arr [new_ac].backoff_slots = (int) floor (op_dist_uniform (cw_arr [new_ac] + 1));
			deference_info_arr [new_ac].type          = WlanC_Backoff_Elapsed;
			
			/* Is the currently scheduled backoff interrupt for a		*/
			/* CW-backoff or regular backoff?							*/
			if (deference_info_arr [backoff_ac].type == WlanC_CW_Elapsed)
				{
				/* Cancel the current interrupt, since it is for a		*/
				/* CW-backoff and reschedule it for the regular backoff	*/
				/* of the new AC.										*/
				op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
				backoff_ac = new_ac;
				intrpt_time = bk_medium_idle_time + sifs_time + slot_time * (aifsn_arr [backoff_ac] + deference_info_arr [backoff_ac].backoff_slots);
				deference_info_arr [backoff_ac].deference_end_evh = op_intrpt_schedule_self (intrpt_time, WlanC_Backoff_Elapsed);
				}
			else
				{
				/* Compare the shortest backoff before the new AC with	*/
				/* the backoff of the new AC.							*/
				new_ac_total_slots    = aifsn_arr [new_ac] + deference_info_arr [new_ac].backoff_slots;
				winner_ac_total_slots = aifsn_arr [backoff_ac]  + deference_info_arr [backoff_ac].backoff_slots;
				
				/* Is the new one also the new winner?					*/
				if (new_ac_total_slots < winner_ac_total_slots ||
					(new_ac_total_slots == winner_ac_total_slots && new_ac > backoff_ac))
					{
					/* The new AC is the new winner. Reschedule the		*/
					/* interrupt.										*/
					op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
					backoff_ac = new_ac;
					intrpt_time = bk_medium_idle_time + sifs_time + slot_time * new_ac_total_slots;
					deference_info_arr [backoff_ac].deference_end_evh = op_intrpt_schedule_self (intrpt_time, WlanC_Backoff_Elapsed);
					}
				}
			}
		}
	
	FOUT;
	}

static void
wlan_hcf_suspended_backoff_remaining_slots_compute (WlanT_HCF_Access_Category ac_to_skip)
	{
	int 						slots_left, slots_completed, ac_slots_completed;
	int 						i, j;
	WlanT_HCF_Access_Category	ac;
	
	/** This function is called to compute the remaining slots for each	**/
	/** access category to complete their backoff period, when the		**/
	/** backoff period is suspended due to internal or external events.	**/
	/** If any, the computation is not performed for the given access	**/
	/** category.														**/	
	FIN (wlan_hcf_suspended_backoff_remaining_slots_compute (ac_to_skip));
	
	/* Compute the number of slots left for the delivery of the			*/
	/* interrupt.														*/
	slots_left = (int) ceil ((intrpt_time - current_time - PRECISION_RECOVERY) / slot_time);
		
	/* Find out the number of slots completed since the medium became	*/
	/* idle.															*/
	slots_completed = deference_info_arr [backoff_ac].backoff_slots + aifsn_arr [backoff_ac] - slots_left;
		
	/* For each contending AC compute the number of remaining slots for	*/
	/* its backoff period.												*/
	for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
		{
		/* Make sure this is not the AC that needs to be skipped.		*/
		ac = ac_queue_status_arr [i];
		if (ac != ac_to_skip)
			{
			ac_slots_completed = slots_completed - aifsn_arr [ac];
		
			/* If the remaining backoffs are negative or zero, then		*/
			/* this AC has empty queue and performing a CW-backoff.		*/
			if (ac_slots_completed >= deference_info_arr [ac].backoff_slots)
				{
				/* CW-backoff is complete. Reset the slot count.		*/
				deference_info_arr [ac].backoff_slots = BACKOFF_SLOTS_UNSET;
			
				/* Reset the bit of this AC in the cw_required flag.	*/
				wlan_ac_flags->cw_required ^= WLANC_AC_BITMAP_ARRAY [ac];
			
				/* Update the queue status array.						*/
				for (j = i; ac_queue_status_arr [j] != WlanC_AC_None; j++)
					ac_queue_status_arr [j] = ac_queue_status_arr [j + 1];
			
				/* Adjust the loop index for the next iteration since	*/
				/* we have removed one entry from the queue status		*/
				/* array.												*/
				i--;
				}
		
			/* The AC didn't complete any backoff slots if the medium	*/
			/* became busy during the AIFS period.						*/
			else if (ac_slots_completed > 0)
				deference_info_arr [ac].backoff_slots -= ac_slots_completed;
			}
		}

	FOUT;
	}

static void
wlan_hcf_ba_control_enqueue (WlanT_Mac_Frame_Type type, OpT_Int64 dest_addr, OpT_uInt8 up, WlanT_HCF_Access_Category ac)
	{
	WlanT_HCF_Hld_Info*			hld_ptr;
	WlanT_HCF_Hld_Info*			queued_hld_ptr;
	int							ac_queue_size, queue_index;
	int							i;
	WlanT_HCF_Access_Category	new_ac, temp_ac;
	char						msg_string [256];
	
	/** This function is called to enqueue entries for BAR or BA frames **/
	/** in the transmission buffer of the given AC for the given		**/
	/** destination and TID (user priority).							**/
	FIN (wlan_hcf_ba_control_enqueue (type, tid, ac));
	
	/* Create a queue entry for the control message.					*/
	hld_ptr = wlan_hcf_ba_control_queue_entry_create (type, dest_addr, up);	
	
	/* Update the buffer usage information and queue size statistic.	*/
	if(LorenDebugFlag)
	{
		printf("total_hlpk_size before increment #3 = %d\n", (int)total_hlpk_size);
	}
	total_hlpk_size += hld_ptr->size;
	if(LorenDebugFlag)
	{
		printf("total_hlpk_size after increment #3 = %d\n", (int)total_hlpk_size);
	}
	
	total_hlpk_num++;
	op_stat_write (hl_packets_rcvd, (double) total_hlpk_num);

	/* Insert the entry into the queue of the given access category.	*/
	/* In case of block-ACK request, the AC's queue is non-empty		*/
	/* (because at least the last MSDU of the block is in the queue).	*/
	/* Simply make the BAR next one in the queue following the last		*/
	/* MSDU of the block.												*/
	if (type == WlanC_BAR)
		{
		op_prg_list_insert (hlpk_lptr_arr [ac], hld_ptr, 1);
		
		/* Record the AC's new queue size.								*/
		op_stat_write (ac_queue_size_shndl_arr [ac], (double) op_prg_list_size (hlpk_lptr_arr [ac]));
		}
	else
		{
		/* Insert the BA entry into the transmission buffer. First 		*/
		/* check the size of the buffer.								*/
		ac_queue_size = op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]);
		if (ac_queue_size == 0)
			{
			/* Queue is empty. Insert the entry into the queue.			*/
			op_prg_list_insert (hlpk_lptr_arr [WlanC_AC_VO], hld_ptr, OPC_LISTPOS_HEAD);
			
			/* Also update the queue status array if necessary.			*/
			if(!(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]))
				{
				/* Insert voice to the top of the list of contending	*/
				/* ACs. Make sure that the list remains sorted.			*/
				for (i = 0, new_ac = WlanC_AC_VO; ac_queue_status_arr [i] != WlanC_AC_None; i++)
					{
					temp_ac = new_ac;
					new_ac = ac_queue_status_arr [i];						
					ac_queue_status_arr [i] = temp_ac;
					}
				ac_queue_status_arr [i] = new_ac;
				}
			}
		else
			{
			/* The queue is non-empty. Check whether there is any		*/
			/* packet that is being transmitted or reserved for the		*/
			/* next transmission of TXOP.								*/
			queue_index = wlan_hcf_ac_queue_transmission_status_check (hlpk_lptr_arr [WlanC_AC_VO], WlanC_AC_VO);
			
			/* If queued, beacon and other BAs have priority over this	*/
			/* new BA.													*/
			for (; queue_index < ac_queue_size; queue_index++)
				{
				queued_hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_VO], queue_index);
				if (queued_hld_ptr->type != WlanC_Beac && queued_hld_ptr->type != WlanC_BA)
					{
					break;
					}
				}
			
			/* Insert the entry into the queue.							*/
			op_prg_list_insert (hlpk_lptr_arr [WlanC_AC_VO], hld_ptr, queue_index);
			}

		/* Record the AC's new queue size.								*/
		op_stat_write (ac_queue_size_shndl_arr [ac], (double) ++ac_queue_size);
		}
	
	/* Write an ODB message if enabled.									*/
	if (wlan_trace_active)
		{
		sprintf (msg_string, "Enqueuing a %s frame for MAC address = "OPC_INT64_FMT" and TID = %d.", (type == WlanC_BAR) ? "BAR" : "BA", dest_addr, up);
		op_prg_odb_print_major (msg_string, OPC_NIL);
		}
	
	FOUT;
	}

static WlanT_HCF_Hld_Info*
wlan_hcf_ba_control_queue_entry_create (WlanT_Mac_Frame_Type type, OpT_Int64 peer_addr, OpT_uInt8 tid)
	{
	WlanT_HCF_Hld_Info*	bacqe_ptr;

	/** This function creates transmission queue entries for BAR and BA **/
	/** frames to be enqueued for the given destination and TID.		**/
	FIN (wlan_hcf_ba_control_queue_entry_create (type, peer_addr, tid));
	
	/* Allocate memory for the queue entry.								*/	
	bacqe_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);
		
	/* Generate error message and abort simulation if no memory left.	*/
	if (bacqe_ptr == OPC_NIL)
		wlan_error_print ("No more memory left to assign for data received from higher layer", OPC_NIL, OPC_NIL);
		
	/* Set the fields needed for the BA control messages.				*/
	bacqe_ptr->pkptr      = OPC_NIL;
	bacqe_ptr->type       = type;
	bacqe_ptr->dest_addr  = peer_addr;
	bacqe_ptr->up         = tid;
	bacqe_ptr->time_rcvd  = current_time;
	bacqe_ptr->size       = (type == WlanC_BAR) ? WLANC_BAR_LENGTH : WLANC_BA_LENGTH;
	bacqe_ptr->ack_policy = WlanC_Normal_ACK;
	bacqe_ptr->ba_retx    = OPC_FALSE;
	if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
		bacqe_ptr->addr1_info_ptr = ap_peer_info_ptr;
	else 
		bacqe_ptr->addr1_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(peer_addr));

	/* Return the created entry.										*/
	FRET (bacqe_ptr);
	}

static int
wlan_hcf_ac_queue_transmission_status_check (List* ac_hlpk_lptr, WlanT_HCF_Access_Category ac)
	{
	WlanT_HCF_Hld_Info*	head_hld_ptr;
	
	/** This function checks the transmission status of the first two	**/
	/** packets at the head of the given AC transmission queue and		**/
	/** returns the lowest index starting where high priority packets,	**/
	/** like MMPDUs, can be inserted into the queue.					**/
	FIN (wlan_hcf_ac_queue_transmission_status_check (ac_hlpk_lptr, ac));
	
	/* Access the record of the packet at the head of the queue.		*/
	head_hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_hlpk_lptr, OPC_LISTPOS_HEAD);
	if ((head_hld_ptr->pkptr != OPC_NIL || 
		 ((head_hld_ptr->type & WLANC_CONTROL_TYPE_BIT) && expected_frame_type == WlanC_None && src_arr [ac] + lrc_arr [ac] == 0)) && 
		fresp_to_send != WlanC_QoS_Data)
		{
		/* The transmission process of the first packet of the queue	*/
		/* didn't start, yet. New packet can be inserted to the head.	*/
		FRET (0);
		}
	else if (fresp_to_send == WlanC_QoS_Data)
		{
		/* The AC is in the middle of a TXOP burst such that it is just	*/
		/* completed a transmission and reserved the channel for the	*/
		/* next one. Hence, make the new packet	second in the queue.	*/
		FRET (1);
		}
	else if ((wlan_flags->transmitter_busy == OPC_TRUE || expected_frame_type == WlanC_Ack || expected_frame_type == WlanC_BA) && 
			 wlan_flags->txop_on == OPC_TRUE)
		{
		/* The AC is in the middle of a TXOP burst such that it is		*/
		/* transmitting the first packet and reserved the channel for	*/
		/* the next one. Hence, make the new packet	third in the queue.	*/
		FRET (2);
		}
	else 
		{
		/* The head packet is being transmitted, but no reservation is	*/
		/* made for the second packet. Hence, make the new packet		*/
		/* second in the queue.											*/
		FRET (1);
		}
	
	/* This line won't be reached.										*/
	FRET (OPC_LISTPOS_HEAD);
	}	

static void 
wlan_hcf_frame_transmit (void)
	{
	char						msg_string  [128];
	char						msg_string1 [128];
	WlanT_HCF_Hld_Info*			hld_ptr;
	
	/** Main procedure to invoke function for preparing and transmitting	**/
	/** the appropriate frames.			     								**/
	FIN (wlan_hcf_frame_transmit (void));
	
	/* If the receiver is busy due to a wlan packet reception, then set the bad_packet_dropped flag	*/
	/* So that if another reception starts during our transmission before this current reception	*/
	/* ends, we don't set the rcvd_bad_packet flag incorrectly to drop next delivered packet, since	*/
	/* there won't be such a packet																	*/
	if ((wlan_flags->receiver_busy) && (rx_state_info_ptr->wlan_pk_rx_end_time >= current_time))
		wlan_flags->bad_packet_dropped = OPC_TRUE;

	/* Send the expected response if we have an CTS, ACK or block ACK to	*/
	/* send.																*/
	if (fresp_to_send == WlanC_Ack || fresp_to_send == WlanC_Cts || fresp_to_send == WlanC_BA)
		{
		/* Third argument of the function call is not important for the		*/
		/* ACK or CTS case.													*/
		wlan_hcf_control_frame_send (fresp_to_send, response_sta_addr, OPC_NIL);
		FOUT;
		}

	/* Get the information record of the higher layer packet that is going	*/
	/* to be transmitted or retransmitted.									*/
	hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [cur_tx_ac], OPC_LISTPOS_HEAD);
	
	/* Store the type of the frame to which the ongoing transmission		*/
	/* sequence belongs.													*/
	txframe_type = hld_ptr->type;
	
	/* Lower our data transmission rate, if it is an 11g data rate and we	*/
	/* are either an AP or a STA in an IBSS, and there are non-ERP STAs in	*/
	/* our BSS and our destination is one of them, so that it can decode	*/
	/* our message.															*/
	if (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present && wlan_flags->ad_hoc_or_ap &&
		data_tx_rate > 5500000.0 && data_tx_rate != 11000000.0)
		{
		/* Check whether the destination is 11g capable. Use an 11b data	*/
		/* rate if this is a broadcast transmission since at least one		*/
		/* presence of non-ERP STA(s) in the BSS. If the destination is		*/
		/* unknown, use 11g data rate not to waste time.					*/
		if (hld_ptr->dest_addr < 0 || (hld_ptr->addr1_info_ptr != PRGC_NIL && hld_ptr->addr1_info_ptr->is_erp == OPC_FALSE))
			{
			/* Pick the highest 11b data rate that is lower than our		*/
			/* regular 11g data rate.										*/
			operational_speed = (data_tx_rate > 11000000.0) ? 11000000.0 : 5500000.0;
			}
		else
			operational_speed = data_tx_rate;
		}

	/* First check whether this is retransmission of an MPDU that is not	*/
	/* acknowledged in received block-ACK message.							*/
	if (hld_ptr->ba_retx == OPC_TRUE)
		{
		/* The packet is already an MPDU, which is actually a fragment.		*/
		num_fragments_arr [cur_tx_ac]  = 1;
		remainder_size_arr [cur_tx_ac] = hld_ptr->size;
		
		/* Store it as AC's retransmission copy unless we have done it		*/
		/* already while sending its proceeding RTS.						*/
		if (mpdu_retx_copy_arr [cur_tx_ac] == OPC_NIL)
			{
			mpdu_retx_copy_arr [cur_tx_ac] = hld_ptr->pkptr;
			hld_ptr->pkptr                 = OPC_NIL;
			}
		
		/* If this is the first data transmission of current TXOP then we	*/
		/* have to start with an RTS/CTS exchange as required by the		*/
		/* standard for data transmission with block-ACK policy. "Response	*/
		/* to send" would have been set to QoS Data if we are within an		*/
		/* ongoing TXOP.													*/ 
		if (fresp_to_send == WlanC_QoS_Data)
			wlan_hcf_data_frame_send (hld_ptr);
		else
			wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
		
		FOUT;
		}
	
	/* If it is a retransmission then check which type of frame needs to be	*/
	/* retransmitted and then prepare and transmit that frame. If the retry	*/
	/* counts are incremented until this point only due to internal			*/
	/* collisions and then treat this transmission like an initial 			*/
	/* transmission rather than a retransmission.							*/
	else if ((src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac] > 0) &&
		(mpdu_retx_copy_arr [cur_tx_ac] != OPC_NIL || op_sar_buf_size (fragmentation_buffer_arr [cur_tx_ac]) != 0))
		{
		/* If the last frame unsuccessfully transmitted was an RTS or a 	*/
		/* CTS-to-self then transmit it again.								*/
		if ((last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || last_tx_frtype_arr [cur_tx_ac] == WlanC_Cts) && wlan_flags->rts_sent == OPC_FALSE)
			{
			wlan_hcf_control_frame_send (last_tx_frtype_arr [cur_tx_ac], hld_ptr->dest_addr, hld_ptr);
			}

		/* If our last transmission was a data packet, then it means it was	*/
		/* not acknowledged. Restart the transmission process. Do the same	*/
		/* if we are resuming our retransmission after sending a beacon		*/
		/* frame.															*/
		else if (last_tx_frtype_arr [cur_tx_ac] == WlanC_QoS_Data)
			{			
			/* Check whether we need to start the retransmission with an	*/
			/* RTS message.													*/
			if ((wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]) && wlan_flags->rts_sent == OPC_FALSE)
				{
				/* Retransmit the RTS frame to again contend for the data .	*/
				wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);		
				}
				
			/* If this is a unicast frame not requiring an ACK,	since it is	*/
			/* also the first frame of the TXOP, start with	an RTS/CTS		*/
			/* exchange as required by the standard.						*/
			else if (hld_ptr->ack_policy != WlanC_Normal_ACK && (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE))
				wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
			
			/* If we are an ERP-STA, and we are not going to use an			*/
			/* 802.11/11b data rate for the transmission data, and there	*/
			/* are non-ERP STAs in the BSS, then we need to "use protection"*/
			/* by sending an RTS or CTS-to-self message.					*/
			else if (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present && 
				     (operational_speed > 5500000.0 && operational_speed != 11000000.0))
				{
				/* Use the "CTS-to-self" approach if the option is enabled.	*/
				/* Even it is enabled, switch using RTS/CTS for protection,	*/
				/* if our previous trials have failed as suggested in the	*/
				/* 802.11g standard (section 9.2.11), since the BSS can be	*/
				/* suffering from hidden node problem.						*/
				if (wlan_flags->cts_to_self && src_arr [cur_tx_ac] < 2)
					wlan_hcf_control_frame_send (WlanC_Cts, hld_ptr->dest_addr, hld_ptr);
					
				/* Otherwise initiate a RTS/CTS exchange as the protection	*/
				/* mechanism.												*/
				else
					wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
				}
			
			/* Just retransmit the data packet if no protection is needed.	*/
			else
				{
				wlan_hcf_data_frame_send (hld_ptr);
				}
			}
		else
			{
			/* We have received the expected CTS for our last RTS. Continue	*/
			/* the sequence with the data frame.							*/
			wlan_hcf_data_frame_send (hld_ptr);
			}
		
		FOUT;
		}

	/* This is not a retransmission. Check whether we are starting a	*/
	/* new transmission sequence or not.								*/
	else if (op_sar_buf_size (fragmentation_buffer_arr [cur_tx_ac]) == 0)
		{
		/* Send a beacon if the entry that is at the head of the queue	*/
		/* is for a beacon.												*/
		if (hld_ptr->type == WlanC_Beac)
			{
			wlan_hcf_beacon_send ();
			FOUT;
			}
		
		/* Send a stateReport backet if the entry that is at the head of the queue	*/
		/* is for a state report.
		*/
		
		if(myStringDebug)
		{
		sprintf(myString,"I am  %d:before wlan_hcf_stateReport_send",(int)my_address);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
		
		if (hld_ptr->type == WlanC_StateReport)
			{
			wlan_hcf_stateReport_send ();
			FOUT;
			}
		
		if(myStringDebug)
		{
		sprintf(myString,"I am  %d:after wlan_hcf_stateReport_send ",(int)my_address);
		op_prg_odb_print_major(myString,OPC_NIL);
		}

		/* This is a new MSDU, MMPDU, BAR or BA. Assign the next		*/
		/* sequence number and increment the sequence number counter.	*/
		/* Sequence numbers	of QoS data frames with unicast address1	*/
		/* fields are assigned using recipient and TID specific			*/
		/* counters.													*/
		if (hld_ptr->type == WlanC_QoS_Data && hld_ptr->addr1_info_ptr != PRGC_NIL)
			{
			/* Assign the sequence number and increment the counter.*/
			pkt_seq_cntl_arr [cur_tx_ac] = hld_ptr->addr1_info_ptr->tid_seq_counter_arr [hld_ptr->up] << WLANC_FRAG_NUM_SIZE;
			hld_ptr->addr1_info_ptr->tid_seq_counter_arr [hld_ptr->up] = ((hld_ptr->addr1_info_ptr->tid_seq_counter_arr [hld_ptr->up]) + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
			}
		else
			{
			/* Use the common counter.									*/
			pkt_seq_cntl_arr [cur_tx_ac] = common_seq_count << WLANC_FRAG_NUM_SIZE; 
			common_seq_count = (common_seq_count + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
			}		
		
		/* Packet needs to be fragmented if it is more than				*/
		/* fragmentation threshold, provided fragmentation is enabled.	*/
		/* Packets that won't be acknowledged (broadcast or unicast		*/
		/* with "No ACK" acknowledgement policy) are not fragmented		*/
		/* regardless of their sizes. BAR and BA messages are also not	*/
		/* fragmented.													*/
		if (frag_threshold != -1                && hld_ptr->size > frag_threshold && 
			hld_ptr->ack_policy != WlanC_No_ACK && (hld_ptr->type & WLANC_CONTROL_TYPE_BIT) == 0)
			{
			/* Determine number of fragments for the packet and the		*/
			/* size of the last fragment.								*/							
			num_fragments_arr [cur_tx_ac]  = (int) (hld_ptr->size / frag_threshold);
			remainder_size_arr [cur_tx_ac] = hld_ptr->size - (num_fragments_arr [cur_tx_ac] * frag_threshold);

			/* If the remainder size is non zero it means that the last	*/
			/* fragment is fractional but since the number of fragments	*/
			/* is a whole number we need to transmit one additional		*/
			/* fragment to ensure that all of the data bits will be		*/
			/* transmitted.												*/
			if (remainder_size_arr [cur_tx_ac] != 0)
				num_fragments_arr [cur_tx_ac] += 1;									 
			else
				/* Special case: data size is a multiple of the			*/
				/* fragment size, so all the fragments will be the same	*/
				/* size. To be consistent with other cases,	set			*/
				/* remainder_size to the size of the last fragment.		*/
				remainder_size_arr [cur_tx_ac] = frag_threshold;
			}
		else
			{			
			/* If no fragments needed then number of packets to be		*/
			/* transmitted is set to 1.									*/								
			num_fragments_arr [cur_tx_ac]  = 1;
			remainder_size_arr [cur_tx_ac] = hld_ptr->size;
			}

		/* Make sure that fragment count is not more than 16.			*/
		if (num_fragments_arr [cur_tx_ac] > 16)
			wlan_error_print ("Too many fragments are needed for higher layer packet! Maximum 16",
							  "fragments are allowed per MSDU or MMPDU. Disable \"Large Packet Processing\"",
							  "and/or increase the fragmentation threshold (must be at least 256 bytes).");
		
		if ((hld_ptr->type & WLANC_CONTROL_TYPE_BIT) == 0)
			{
			/* Storing Data packet id for debugging purposes.			*/			
			served_pk_id_arr [cur_tx_ac] = op_pk_id (hld_ptr->pkptr);		
			
			/* Insert packet to fragmentation buffer. We will keep the	*/
			/* record of the packet in the queue until the transmission	*/
			/* procedure of the packet is complete.						*/
			op_sar_segbuf_pk_insert (fragmentation_buffer_arr [cur_tx_ac], hld_ptr->pkptr, 0);
			hld_ptr->pkptr = OPC_NIL;
		
			/* Printing out information to ODB.							*/
			if (wlan_trace_active == OPC_TRUE)
				{
				sprintf (msg_string, "Data/management packet " OPC_PACKET_ID_FMT " is removed from higher layer buffer of the AC %s.", 
					served_pk_id_arr [cur_tx_ac], WLANC_AC_NAME_ARRAY [cur_tx_ac]);
				sprintf	(msg_string1, "The queuing delay for data packet " OPC_PACKET_ID_FMT " is %.6f seconds.", 	
					served_pk_id_arr [cur_tx_ac], current_time - hld_ptr->time_rcvd);	
				op_prg_odb_print_major (msg_string, msg_string1, OPC_NIL);
				}
			}
		
		/* No RTS or protection is needed, if we are going to start the	*/
		/* transmission of a new higher layer packet within our ongoing	*/
		/* TXOP, and this is not the initial frame of the TXOP. If this	*/
		/* is the case then fresp_to_send have been set to QoS Data.	*/
		if (fresp_to_send == WlanC_QoS_Data)
			{
			/* Even though we won't use RTS, set the frsize_req_rts		*/
			/* flag correctly in case we need to retransmit the packet.	*/
			if (rts_threshold == -1 || (hld_ptr->dest_addr < 0 && wlan_flags->ad_hoc_or_ap == OPC_TRUE) || 
				(hld_ptr->size + MPDU_HEADER_SIZE (hld_ptr->type)) < rts_threshold)
				wlan_ac_flags->frsize_req_rts &= ~(WLANC_AC_BITMAP_ARRAY [cur_tx_ac]);
			else
				wlan_ac_flags->frsize_req_rts |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
			
			/* Send a data frame as the next frame.						*/
			wlan_hcf_data_frame_send (hld_ptr);
			FOUT;
			}
		
		/* Send RTS if RTS is enabled and packet size is more than RTS	*/
		/* threshold. No RTS message is sent for broadcast packets		*/
		/* regardless of their sizes.									*/
		else if (rts_threshold != -1 && (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE) && 
				 (hld_ptr->size + MPDU_HEADER_SIZE (hld_ptr->type)) > rts_threshold)			
			{
			/* Set the flag indicating that an RTS is needed for the	*/
			/* current frame due to its size.							*/
			wlan_ac_flags->frsize_req_rts |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
			
			/* Prepare RTS frame for transmission.						*/
			wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
			
			/* Break the routine as RTS is already prepared.			*/
			FOUT;
			}
			
		/* If this is a unicast frame not requiring an ACK, since it is	*/
		/* also the first frame of the TXOP, start with	an RTS/CTS		*/
		/* exchange as specified in the standard.						*/
		else if (hld_ptr->ack_policy != WlanC_Normal_ACK && (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE))
			{
			wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
			wlan_ac_flags->frsize_req_rts &= ~(WLANC_AC_BITMAP_ARRAY [cur_tx_ac]); 
			}
		
		else
			{
			/* Reset the flag indicating an RTS was not necessary due	*/
			/* to current frame size.									*/
			wlan_ac_flags->frsize_req_rts &= ~(WLANC_AC_BITMAP_ARRAY [cur_tx_ac]);
			
			/* If we are an ERP-STA, and we are not going to use an		*/
			/* 802.11/11b data rate for the transmission data, and		*/
			/* there are non-ERP STAs in the BSS, then we need to "use	*/
			/* protection" by sending an RTS or	CTS-to-self message.	*/
			if (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present &&
				(operational_speed > 5500000.0 && operational_speed != 11000000.0))
				{
				/* Use the "CTS-to-self" approach and send a CTS		*/
				/* message with	destination address set to our own		*/
				/* address, if CTS-to-self option is enabled or the		*/
				/* data packet is a broadcast packet.					*/
				if (wlan_flags->cts_to_self || hld_ptr->dest_addr < 0)
					wlan_hcf_control_frame_send (WlanC_Cts, hld_ptr->dest_addr, hld_ptr);
				
				/* Otherwise initiate a RTS/CTS exchange as the			*/
				/* protection mechanism.								*/
				else
					wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
				
				/* Exit the function.									*/
				FOUT;
				}
			else
				{
				/* We start the frame sequence with the data frame.		*/
				wlan_hcf_data_frame_send (hld_ptr);
				FOUT;
				}
			}
		}		
	
	/* If type of the response frame is set to data frame while the			*/
	/* segmentation buffer is not empty, then this either transmission of	*/
	/* the first fragment of a higher layer packet after successful			*/
	/* reception of a CTS message, or transmission of a fragment of a		*/
	/* higher layer packet after successful reception of an ACK for the		*/
	/* previous fragment.													*/
	else if (fresp_to_send == WlanC_QoS_Data)
		wlan_hcf_data_frame_send (hld_ptr);
	else
		{
		/* If we come to this point, then this means that this is the		*/
		/* transmission of a fragment of a MSDU/MMPDU such that it is not	*/
		/* the first fragment of that higher layer packet, though all the	*/
		/* previous fragments are transmitted in the previous TXOP and this	*/
		/* transmission will be the first transmission of the current TXOP.	*/

		/* Start the transmission with an RTS if the total size of the		*/
		/* remaining fragments of the MSDU/MMPDU is larger than the RTS		*/
		/* threshold.														*/
		if (rts_threshold != -1 && 
			((num_fragments_arr [cur_tx_ac] - 1) * frag_threshold + remainder_size_arr [cur_tx_ac] + MPDU_HEADER_SIZE (hld_ptr->type)) > 
			rts_threshold)
			{
			/* Set the flag indicating that an RTS is needed for the		*/
			/* current frame due to its size.								*/
			wlan_ac_flags->frsize_req_rts |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
			
			/* Prepare RTS frame for transmission.							*/
			wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
			
			/* Break the routine as RTS is already prepared.				*/
			FOUT;
			}
			
		else
			{
			/* Reset the flag indicating an RTS was not necessary due to	*/
			/* current frame size.											*/
			wlan_ac_flags->frsize_req_rts &= ~(WLANC_AC_BITMAP_ARRAY [cur_tx_ac]);
			
			/* If we are an ERP-STA, and we are not going to use an			*/
			/* 802.11/11b data rate for the transmission data, and there	*/
			/* are non-ERP STAs in the BSS, then we need to "use			*/
			/* protection" by sending an RTS or	CTS-to-self message.		*/
			if (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present &&
				(operational_speed > 5500000.0 && operational_speed != 11000000.0))
				{
				/* Use the "CTS-to-self" approach and send a CTS message	*/
				/* with destination address set to our own address, if		*/
				/* CTS-to-self option is enabled.							*/
				if (wlan_flags->cts_to_self || hld_ptr->dest_addr < 0)
					wlan_hcf_control_frame_send (WlanC_Cts, hld_ptr->dest_addr, hld_ptr);
				
				/* Otherwise initiate a RTS/CTS exchange as the protection	*/
				/* mechanism.												*/
				else
					wlan_hcf_control_frame_send (WlanC_Rts, hld_ptr->dest_addr, hld_ptr);
				
				/* Exit the function.										*/
				FOUT;
				}
			else
				{
				/* We start the frame sequence with the data frame.			*/
				wlan_hcf_data_frame_send (hld_ptr);
				FOUT;
				}
			}
		}
	
	FOUT;
	}

static double		
wlan_hcf_non_11b_plcp_overhead_compute (OpT_Packet_Size mpdu_length, double data_rate)
	{
	/** This function is called by MACs that operate either in 11a or in	**/
	/** 11g mode. The function decides on the type of PLCP preamble/header	**/
	/** and	accordingly computes the total size of the PLCP overhead in		**/
	/** bits for the transmission whose MPDU length and data rate are		**/
	/** provided. The function returns this computed overhead.				**/
	FIN (wlan_hcf_non_11b_plcp_overhead_compute (mpdu_length, data_rate));
	
	/* Use the OFDM preamble if we are using an OFDM data rate.				*/
	if (data_rate > 5500000.0 && data_rate != 11000000.0)
		{
		/* Compute and the return the OFDM PLCP overhead.					*/
		FRET (wlan_hcf_plcp_overhead_ofdm_compute (mpdu_length, data_rate));
		}
	
	/* Use the short preamble if the data rate is higher than 1 Mbps and	*/
	/* there are no non-ERP STAs in our (I)BSS (we assume that non-ERP STAs	*/
	/* don't support short preambles).										*/
	else if (data_rate != 1000000.0 && wlan_flags->non_erp_present == OPC_FALSE)
		{
		FRET (WLANC_PLCP_OVERHEAD_DSSS_SHORT);
		}
	
	/* Otherwise use the long preamble.										*/
	else
		{
		FRET (WLANC_PLCP_OVERHEAD_DSSS_LONG);
		}
	}

static double		
wlan_hcf_plcp_overhead_ofdm_compute (OpT_Packet_Size mpdu_length, double data_rate)
	{
	int		N_dbps, data_size, padding;
	
	/** This function computes and returns the total PLCP overhead			**/
	/** (preamble + header) in seconds for the given MPDU length and data	**/
	/** rate for a transmission that will use the OFDM technology specified	**/
	/** in the 802.11a standard.											**/ 
	FIN (wlan_hcf_plcp_overhead_ofdm_compute (mpdu_length, data_rate));
	
	/* Compute the number of padding bits. First find out the total size we	*/
	/* are trying to achieve.												*/
	N_dbps    = (int) (data_rate * 4.0 / 1.0E06);
	data_size = N_dbps * (int) ceil ((double)(mpdu_length + WLANC_SERVICE_AND_TAIL_SIZE) / N_dbps);
	
	/* The size of the padding is the difference between the actual size	*/
	/* and the target size.													*/
	padding = data_size - ((int) mpdu_length + WLANC_SERVICE_AND_TAIL_SIZE);
	
	/* Compute and return the total PLCP overhead by adding the overhad of	*/
	/* SERVICE, Tail and Padding bits to the rest of the PLCP delay.		*/
	if (data_rate == control_data_rate)
		{
		FRET (plcp_overhead_control + (WLANC_SERVICE_AND_TAIL_SIZE + padding) / data_rate);
		}
	else
		{
		FRET (plcp_overhead_data + (WLANC_SERVICE_AND_TAIL_SIZE + padding) / data_rate);
		}
	}
		

static void 
wlan_hcf_control_frame_send (WlanT_Mac_Frame_Type frame_type, OpT_Int64 dest_addr, WlanT_HCF_Hld_Info* hld_ptr)
	{
	OpT_Packet_Size					tx_datapacket_size;
	WlanT_Mac_Frame_Type			type;
	double							tx_data_rate;
	double							duration;
	double							total_pk_size;
	double							tx_end_time, tx_delay;
	double							total_frame_size, bulk_size;
	WlanT_Control_Header_Fields*	pk_chstruct_ptr;
	Packet*							wlan_transmit_frame_ptr;
	WlanT_HCF_BA_State*				peer_tid_ba_info_ptr;
	char							msg_string [128];
	
	/** This function is called to create control frames, populate the		**/
	/** fields in their frame headers and finally to send them to the		**/
	/** receiver. The type of the control frame and the destination address	**/
	/** are provided as the function arguments.								**/
	FIN (wlan_hcf_control_frame_send (frame_type, dest_addr, hld_ptr));

	/* First initialize the transmission data rate to the lowest supported	*/
	/* data rate, which is the data rate used for control frames.			*/
	tx_data_rate = control_data_rate;
	
	if (frame_type == WlanC_Ack)			
		{	
		/* Preparing acknowledgement frame in response to the data frame	*/
		/* received from the remote stations.								*/
		
		/* Since an ACK is a control response frame, adjust its				*/
		/* transmission rate based on the data rate of the data frame we	*/
		/* are ACKing, if operating in an 11a or all-11g BSS. Otherwise use	*/
		/* 1 Mbps, the mandatory PHY rate of 802.11/11b.					*/
		if (phy_type == WlanC_11a_PHY || (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present == OPC_FALSE))
			tx_data_rate = wlan_ctrl_response_drate_determine (rcvd_frame_drate);
		
		/* Creating ACK packet format type.									*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_control");

		/* Adjust the packet size if necessary to model the PLCP overhead	*/
		/* accurately, which is physical layer technology dependent. The	*/
		/* default value is set for infra-red technology.					*/
		if (phy_char_flag != WlanC_Infra_Red)
			{
			bulk_size = PLCP_OVERHEAD_CTRL (WLANC_ACK_LENGTH) * tx_data_rate - WLANC_DEFAULT_PLCP_OVERHEAD;
			op_pk_bulk_size_set (wlan_transmit_frame_ptr, (OpT_Packet_Size) bulk_size);
			}

		/* Setting ack frame fields.										*/
		pk_chstruct_ptr = wlan_pk_chstruct_create ();
   		
		type = WlanC_Ack;   		
		pk_chstruct_ptr->retry = duplicate_entry;

		/* If there are more fragments to transmit then broadcast the		*/
		/* remaining duration for which	the station will be using			*/
		/* the channel.														*/
		duration = last_rcvd_duration - (sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH));		
		pk_chstruct_ptr->duration = duration;

		/* Destination station address.										*/
		pk_chstruct_ptr->rx_addr = dest_addr;

		/* Setting ACK type.												*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_TYPE_FD, type, OPC_FIELD_SIZE_UNCHANGED);
			
		/* Setting the accept field to true, meaning the frame is a good	*/
		/* frame.															*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);

		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED, 
						  wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));

		/* Place the transmission data rate and physical layer			*/
		/* technology information into the packet.						*/
		wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
	
		/* Since no frame is expected, the expected frame type field */
		/* to nil.                                                   */
		expected_frame_type = WlanC_None;	
	
		/* Once Ack is transmitted in response to Data frame then set the frame		*/
		/* response indicator to none frame as the response is already generated	*/
		fresp_to_send = WlanC_None;			

		/* Printing out information to ODB.	*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("ACK is being transmitted for the packet received.", OPC_NIL);
			}

		/* Get the total packet size for statistic recording at the end.	*/
		total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
		}
	
	else if (frame_type == WlanC_Rts)
		{		
		/* Creating RTS packet format type.									*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_control");

		/* Initializing RTS frame fields.									*/
		pk_chstruct_ptr = wlan_pk_chstruct_create ();
		
		/* Type of frame */
	   	type = WlanC_Rts;   						

		/* if in the infrastructure BSS network then the immediate recipient for the transmitting	*/
		/* station will always be an Access point. Otherwise the frame is directly sent to the 		*/
		/* final destination.																		*/
    	if ((bss_flag == OPC_TRUE) && (ap_flag == OPC_BOOLINT_DISABLED))
			{
			/* If Infrastructure BSS then the immediate destination will be Access point, which 	*/
			/* then forward the frame to the appropriate destination.								*/
			pk_chstruct_ptr->rx_addr = ap_mac_address;
			}
		else
			{
			/* Otherwise set the final destination address.	*/				   
			pk_chstruct_ptr->rx_addr = dest_addr;
			}

		/* Source station address.	*/
		pk_chstruct_ptr->tx_addr = my_address;

		/* Setting the Rts frame type.	*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_TYPE_FD, type, OPC_FIELD_SIZE_UNCHANGED);

		/* Setting the accept field to true, meaning the frame is a good frame.	*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
				
		/* Setting the variable which keeps track of the last transmitted frame that needs response.	*/
		last_tx_frtype_arr [cur_tx_ac] = WlanC_Rts;
					
		/* Determining the size of the first data fragment or frame that need */
		/* to be transmitted following the RTS transmission.				  */				
		if (num_fragments_arr [cur_tx_ac] > 1)
			{
			/* If there are more than one fragment to transmit then the */
			/* data segment of the first data frame will be the size of */
			/* fragmentation threshold. The total packet size will be   */
			/* data plus the overhead.									*/
			tx_datapacket_size = frag_threshold + MPDU_HEADER_SIZE (hld_ptr->type);
			}
		else
			/* If there is one data frame to transmit then the          */
			/* data segment of the first data frame will be the size of */
			/* the remainder computed earlier. The total packet size    */
			/* will be data plus the overhead.							*/
			{
			tx_datapacket_size = remainder_size_arr [cur_tx_ac] + MPDU_HEADER_SIZE (hld_ptr->type);
			}

		/* Station is reserving channel bandwidth by using RTS frame, so    */
		/* in RTS the station will broadcast the duration it needs to send  */ 		 		
		/* one data frame and receive ACK for it. The total duration is the */
		/* the time required to transmit one data frame, plus one CTS frame */
		/* plus one ACK frame, and plus three SIFS intervals. Don't			*/
		/* consider the ACK and its SIFS if an ACK is not needed for the	*/
		/* QoS data transmission.											*/
		if ((hld_ptr->type & WLANC_CONTROL_TYPE_BIT) == 0)
			{
			if (hld_ptr->ack_policy == WlanC_Normal_ACK)
				duration =  TXTIME_CTRL (WLANC_CTS_LENGTH) + TXTIME_DATA (tx_datapacket_size) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 3 * sifs_time;
			else
				duration =  TXTIME_CTRL (WLANC_CTS_LENGTH) + TXTIME_DATA (tx_datapacket_size) + 2 * sifs_time;
			}
		else
			{
			/* This RTS is either for a BAR or for a delayed BA. The		*/
			/* response of a BAR is either a BA or an ACK, depending on our	*/
			/* ACK policy of packet's TID. The response of a delayed BA is	*/
			/* an ACK.														*/
			if (hld_ptr->type == WlanC_BAR)
				{
				if (tc_config_arr [hld_ptr->up].ba_policy == WlanC_Immediate_BA)
					duration = TXTIME_CTRL (WLANC_CTS_LENGTH) + TXTIME_DATA (WLANC_BAR_LENGTH) + TXTIME_DATA (WLANC_BA_LENGTH) + 3 * sifs_time;
				else
					duration = TXTIME_CTRL (WLANC_CTS_LENGTH) + TXTIME_DATA (WLANC_BAR_LENGTH) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 3 * sifs_time;
				}
			else
				duration = TXTIME_CTRL (WLANC_CTS_LENGTH) + TXTIME_DATA (WLANC_BA_LENGTH) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 3 * sifs_time;
			}
		
		/* Set the computed duration into the packet header field.			*/
		pk_chstruct_ptr->duration = duration;
				
		/* Setting RTS frame fields.										*/
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED, 
				          wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));				
				
		/* Place the transmission data rate and physical layer technology	*/
		/* information into the packet.										*/
		wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
	
		/* Adjust the packet size to accurately model the RTS message and	*/
		/* the PLCP overhead, which is physical layer technology dependent.	*/
		/* The default value for PLCP overhead is set for infra-red			*/
		/* technology.														*/
		if (phy_char_flag != WlanC_Infra_Red)
			total_frame_size = PLCP_OVERHEAD_CTRL (WLANC_RTS_LENGTH) * control_data_rate + WLANC_RTS_LENGTH;
		else
			total_frame_size = WLANC_DEFAULT_PLCP_OVERHEAD + WLANC_RTS_LENGTH;
		op_pk_total_size_set (wlan_transmit_frame_ptr, (OpT_Packet_Size) total_frame_size);
		
		/* CTS is expected in response to RTS.								*/						
		expected_frame_type = WlanC_Cts;

		/* Printing out information to ODB.									*/
		if (wlan_trace_active == OPC_TRUE)
			{
			if (hld_ptr->ba_retx == OPC_TRUE)
				sprintf (msg_string, "RTS is being transmitted for retransmission of a block MPDU.");
			else if (hld_ptr->type & WLANC_DATA_TYPE_BIT)
				sprintf (msg_string, "RTS is being transmitted for data packet " OPC_PACKET_ID_FMT ".", served_pk_id_arr [cur_tx_ac]);
			else
				sprintf (msg_string, "RTS is being transmitted for management, BAR or BA packet.");
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}

		/* Get the total packet size for statistic recording at the end.	*/
		total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
		}
	
	else if (frame_type == WlanC_Cts && fresp_to_send == WlanC_None)
		{
		/* Since we are sending this CTS message not a response, it is a	*/
		/* CTS-to-self message used by ERP STAs (11g stations).				*/
		
		/* Store the type of last transmission. IMPORTANT NOTE: In case of	*/
		/* CTS transmissions, the value of the state variable				*/
		/* last_frametx_type is set to WlanC_Cts ONLY for CTS-to-self		*/
		/* transmissions (i.e. it is not updated for regular CTS messages).	*/
		last_tx_frtype_arr [cur_tx_ac] = frame_type;
		
		/* Create a control message.										*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_control");

		/* Adjust the packet size if necessary to model the PLCP overhead	*/
		/* accurately, which is physical layer technology dependent. The	*/
		/* default value is set for infra-red technology.					*/
		if (phy_char_flag != WlanC_Infra_Red)
			{
			bulk_size = PLCP_OVERHEAD_CTRL (WLANC_CTS_LENGTH) * control_data_rate - WLANC_DEFAULT_PLCP_OVERHEAD;
			op_pk_bulk_size_set (wlan_transmit_frame_ptr, (OpT_Packet_Size) bulk_size);
			}
		
		/* Initializing RTS frame fields.									*/
		pk_chstruct_ptr = wlan_pk_chstruct_create ();

		/* Set the destination address to own address.						*/
		pk_chstruct_ptr->rx_addr = my_address;

		/* Determining the size of the first data fragment or frame that	*/
		/* need to be transmitted following the CTS-to-self transmission.	*/				
		if (num_fragments_arr [cur_tx_ac] > 1)
			{
			/* If there are more than one fragment to transmit then the		*/
			/* data segment of the first data frame will be the size of 	*/
			/* fragmentation threshold. The total packet size will be data	*/
			/* plus the overhead (which is 224 bits).						*/
			tx_datapacket_size = frag_threshold + MPDU_HEADER_SIZE (hld_ptr->type);
			}
		else
			/* If there is one data frame to transmit then the data segment	*/
			/* of the first data frame will be the size of the remainder	*/
			/* computed earlier. The total packet size will be data plus	*/
			/* the overhead (which is 224 bits).							*/
			{
			tx_datapacket_size = remainder_size_arr [cur_tx_ac] + MPDU_HEADER_SIZE (hld_ptr->type);
			}

		/* Compute the duration information that will be used by the		*/
		/* recipient MACs to update their NAVs. The duration must include a */
		/* SIFS time and the transmission time of the data frame that will	*/
		/* follow this control message. Additionally, another SIFS time and	*/
		/* and an ACK transmission time must be included if the data frame	*/
		/* needs to be immediately acknowledged.							*/
		if ((hld_ptr->type & WLANC_CONTROL_TYPE_BIT) == 0)
			{
			if (hld_ptr->ack_policy == WlanC_Normal_ACK)
				duration = TXTIME_DATA (tx_datapacket_size) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 2 * sifs_time;
			else
				duration = TXTIME_DATA (tx_datapacket_size) + sifs_time; 
			}

		else
			{
			/* This CTS-to-self is either for a BAR or for a delayed BA.	*/
			/* The response of a BAR is either a BA or an ACK, depending on	*/
			/* our ACK policy of packet's TID. The response of a delayed BA	*/
			/* is an ACK.													*/
			if (hld_ptr->type == WlanC_BAR)
				{
				if (tc_config_arr [hld_ptr->up].ba_policy == WlanC_Immediate_BA)
					duration = TXTIME_DATA (WLANC_BAR_LENGTH) + TXTIME_DATA (WLANC_BA_LENGTH) + 2 * sifs_time;
				else
					duration = TXTIME_DATA (WLANC_BAR_LENGTH) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 2 * sifs_time;
				}
			else
				duration = TXTIME_DATA (WLANC_BA_LENGTH) + TXTIME_CTRL (WLANC_ACK_LENGTH) + 2 * sifs_time;
			}

		/* Set the computed duration into the packet header field.			*/
		pk_chstruct_ptr->duration = duration;
		
		/* Setting CTS frame type.											*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_TYPE_FD, (int) WlanC_Cts, OPC_FIELD_SIZE_UNCHANGED);

		/* Initialize the "Accept" field.									*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
				
		/* Setting CTS frame fields.										*/
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED, 
						  wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));
		
		/* We expect to receive our own CTS when sending CTS-to-self.		*/
		expected_frame_type = WlanC_Cts;	

		/* Place the transmission data rate and physical layer technology	*/
		/* information into the packet.										*/
		wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
		
		/* Compute the total transmission delay.							*/
		total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
		tx_delay = total_pk_size / tx_data_rate;

		/* Send a copy of the packet to ourselves directly, since we will	*/
		/* not receive a transmission that is made by our own transmitter.	*/
		/* Add a very small delay to the transmission delay to guarantee	*/
		/* that we receive the copy a moment after our transmitter			*/
		/* completes our transmission.										*/
		op_pk_deliver_delayed (op_pk_copy (wlan_transmit_frame_ptr), my_objid, LOW_LAYER_INPUT_STREAM, (tx_delay + WLANC_CTS_TO_SELF_RX_DELAY));
		
		/* Printing out information to ODB.									*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("CTS-to-self is being transmitted.", OPC_NIL);
			}
		}
		
	else if (frame_type == WlanC_Cts)
		{
		/* Preparing CTS frame in response to the received RTS frame.		*/
			
		/* Since an CTS is a control response frame, adjust its				*/
		/* transmission rate based on the data rate of the RTS frame we		*/
		/* are replying, if operating in an 11a or all-11g BSS. Otherwise	*/
		/* use 1 Mbps, the mandatory PHY rate of 802.11/11b.				*/
		if (phy_type == WlanC_11a_PHY || (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present == OPC_FALSE))
			tx_data_rate = rcvd_frame_drate;
		else
			tx_data_rate = control_data_rate;
		
		/* Creating CTS packet format type.									*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_control");

		/* Adjust the packet size if necessary to model the PLCP overhead	*/
		/* accurately, which is physical layer technology dependent. The	*/
		/* default value is set for infra-red technology.					*/
		if (phy_char_flag != WlanC_Infra_Red)
			{
			bulk_size = PLCP_OVERHEAD_CTRL (WLANC_CTS_LENGTH) * tx_data_rate - WLANC_DEFAULT_PLCP_OVERHEAD;
			op_pk_bulk_size_set (wlan_transmit_frame_ptr, (OpT_Packet_Size) bulk_size);
			}

		/* Initializing CTS frame fields.									*/
		pk_chstruct_ptr = wlan_pk_chstruct_create ();
		
		/* Type of frame.													*/
   		type = WlanC_Cts;

		/* Destination station address.										*/
		pk_chstruct_ptr->rx_addr = dest_addr;
			
		/* Station is reserving channel bandwidth by using RTS frame, so    */
		/* in RTS the station will broadcast the duration it needs to send  */ 		 		
		/* one data frame and receive ACK for it, if requested. Just		*/
		/* subtract the	transmission of the CTS frame and SIFS duration		*/
		/* from the	"duration" value received with the RTS message.			*/
		duration = last_rcvd_duration - (sifs_time + TXTIME_CTRL_DR (WLANC_CTS_LENGTH, tx_data_rate));
		pk_chstruct_ptr->duration = duration;

		/* Setting CTS frame type.											*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_TYPE_FD, type, OPC_FIELD_SIZE_UNCHANGED);

		/* Initialize the "Accept" field.									*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
				
		/* Setting CTS frame fields.										*/
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,
						  wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));

		/* Place the transmission data rate and physical layer technology	*/
		/* information into the packet.										*/
		wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
	
		/* Once CTS is transmitted in response to RTS then set the frame	*/
		/* response indicator to none frame as the response is already		*/
		/* generated.														*/
		fresp_to_send = WlanC_None;										
			
		/* No frame is expected once CTS is transmitted.					*/
		expected_frame_type = WlanC_None;	

		/* Printing out information to ODB.									*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("CTS is being transmitted in response to RTS.", OPC_NIL);
			}

		/* Get the total packet size for statistic recording at the end.	*/
		total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
		}
	
	else if (frame_type == WlanC_BA)
		{
		/* This is a block ACK that is sent as a direct response to the		*/
		/* received BAR (i.e., the policy is immediate block ACK).			*/

		/* Create the control frame and its header fields.					*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_control");
		pk_chstruct_ptr = wlan_pk_chstruct_create ();
		
		/* Set the source and destination address information.				*/
		pk_chstruct_ptr->rx_addr = dest_addr;
		pk_chstruct_ptr->tx_addr = my_address;
		
		/* Set the variable that stores the data rate of the current		*/
		/* transmission.													*/
		tx_data_rate = rcvd_frame_drate;

		/* Derive the duration information from the duration value of the	*/
		/* BAR message.														*/
		pk_chstruct_ptr->duration = last_rcvd_duration - sifs_time - TXTIME_DATA_DR (WLANC_BA_LENGTH, tx_data_rate);
		
		/* Get the BA state information for the given destination and TID,	*/
		/* from where we can retrieve BA specific information, like the		*/
		/* status bitmap, to send in our block ACK.							*/
		if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
			peer_tid_ba_info_ptr = ap_peer_info_ptr->ba_state_ptr_arr [rcvd_bar_tid];
		else
			peer_tid_ba_info_ptr = 
				((WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(dest_addr)))->ba_state_ptr_arr [rcvd_bar_tid];

		/* Set the packet fields.											*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_TYPE_FD, WlanC_BA, OPC_FIELD_SIZE_UNCHANGED);
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED, 
				          wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_CNTL_BA_FD, peer_tid_ba_info_ptr->block_ack_fields_ptr, OPC_FIELD_SIZE_UNCHANGED, 
				          op_prg_mem_copy_create, op_prg_mem_free, sizeof (WlanT_BA_Control_Fields));

		/* Reset the block ACK contents kept in the BA state record.		*/
		peer_tid_ba_info_ptr->block_ack_fields_ptr = OPC_NIL;
		
		/* Place the transmission data rate and physical layer technology	*/
		/* information into the packet.										*/
		wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, rcvd_frame_drate, phy_type, phy_char_flag);
	
		/* Determine and set the total size of the packet with PLCP			*/
		/* overhead.														*/
		total_pk_size = (OpT_Packet_Size) (WLANC_BA_LENGTH + PLCP_OVERHEAD_DATA_DR (WLANC_BA_LENGTH, rcvd_frame_drate) * rcvd_frame_drate);
		op_pk_total_size_set (wlan_transmit_frame_ptr, total_pk_size);

		/* Write an ODB trace message if enabled.							*/
		if (wlan_trace_active)
			op_prg_odb_print_major ("Block ACK is being transmitted in response to Block ACK Request.", OPC_NIL);

		/* Reset response frame to send variable.							*/
		fresp_to_send = WlanC_None;
		}
	else
		{
		wlan_error_print ("Transmission request for unexpected frame type.", OPC_NIL, OPC_NIL);
		}
			
	/* Update the control traffic sent statistics.							*/
	op_stat_write (ctrl_traffic_sent_handle_inbits, total_pk_size);
	op_stat_write (ctrl_traffic_sent_handle, 		1.0);
	
	/* Write a value of 0 for the end of transmission.						*/
	tx_end_time = current_time + total_pk_size / tx_data_rate;
	op_stat_write_t (ctrl_traffic_sent_handle_inbits, 0.0, tx_end_time);
	op_stat_write_t (ctrl_traffic_sent_handle, 		  0.0, tx_end_time);
		
	/* Send packet to the transmitter.										*/
	op_pk_send (wlan_transmit_frame_ptr, LOW_LAYER_OUTPUT_STREAM);	
	wlan_flags->transmitter_busy = OPC_TRUE;
	
	/* Set the flag if the current transmission requires signal extension.	*/
	if (phy_char_flag == WlanC_ERP_OFDM_11g && tx_data_rate > 5500000.0 && tx_data_rate != 11000000.0)
		wlan_flags->wait_signal_ext = OPC_TRUE;
	
	FOUT;
	}

static void
wlan_hcf_data_frame_send (WlanT_HCF_Hld_Info* hld_ptr)
	{
	WlanT_Data_Header_Fields*	pk_dhstruct_ptr;
	WlanT_QoS_Control_Fields*	qos_fields_ptr;
	Packet*						wlan_transmit_frame_ptr;
	Packet*						seg_pkptr;
	Packet*						copy_pkptr;//mohammad
	WlanT_HCF_BA_State*			ba_info_ptr;
	WlanT_HCF_Hld_Info**		new_retx_arr;
	OpT_Packet_Size				tx_datapacket_size, header_size;
	int							new_arr_size;
	double						duration, next_frag_dur;
	double						mac_delay;
	double						total_pk_size;
	double						tx_time, tx_end_time;
	double						txop_time_left;
	double						total_plcp_overhead;
	double						bulk_size;
	char						msg_string [256];
	
	int notRetransmission_flag = 0;
	

	/** This function is called to create data frames, populate the fields	**/
	/** of their frame headers and finally to send them to the receiver.	**/
	/** The information record of the MSDU or MMPDU, which the generated	**/
	/** data frame will belong to, is passed with the function call, which	**/
	/** contains information in order to populate the MAC header of the		**/
	/** frame, like	the MAC address of the destination node, etc. Unless	**/
	/** explicitly stated, the comments of the function refer to both MSDUs	**/
	/** and MMPDUs as "data" frames/packets/fragments.						**/
	FIN (wlan_hcf_data_frame_send (hld_ptr));
	
	
	if(myStringDebug)
		{
		sprintf(myString,"I am  %d:send data frame function",(int)my_address, importance);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	
	
	
	
	

	/* If this queued packet is actually a BAR or BA frame rather than a	*/
	/* higher layer data frame then call the appropriate "send" function.	*/
	if (hld_ptr->type & WLANC_CONTROL_TYPE_BIT)
		{
		wlan_hcf_ba_control_frame_send (hld_ptr);
		FOUT;
		}
		
	/* Set the variable which keeps track of the last transmitted frame.	*/
	last_tx_frtype_arr [cur_tx_ac] = WlanC_QoS_Data;
	
	/* Reset the txop_on flag by default. We will set it if we realize that	*/
	/* there will be still sufficient time in our TXOP for another			*/
	/* transmission.														*/
	wlan_flags->txop_on = OPC_FALSE;
	
	/* First check whether this is a retransmitted block MPDU.				*/
	if (hld_ptr->ba_retx == OPC_TRUE)
		{
		/* This is retransmission of an MPDU, failure of whose previous		*/
		/* transmission is learnt from a received block-ACK message. Use	*/
		/* the copy reloaded in the wlan_hcf_frame_transmit() function.		*/
		wlan_transmit_frame_ptr = mpdu_retx_copy_arr [cur_tx_ac];
		
		/* Access the header fields of the frame.							*/
		op_pk_fd_access_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, (void **) &pk_dhstruct_ptr);

		/* Failed block MPDUs are also transmitted with block-ACK policy.	*/
		pk_dhstruct_ptr->duration = 0;
		duration = 0;
		
		/* Hence, no immediate ACK is expected, and no MPDU copy for		*/
		/* immediate retransmission is needed.								*/
		expected_frame_type = WlanC_None;
		mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
		
		/* Reset the retry count and rts_sent flag since we may have 		*/
		/* completed an RTS/CTS frame exchange prior to this transmission,	*/
		/* after updating the retransmission attempts statistics. Add 1 to	*/
		/* the retry count while updating the statistic, since this			*/
		/* transmission itself is a retransmission.							*/
		op_stat_write (retrans_handle,        (double) (src_arr [cur_tx_ac] + 1));
		op_stat_write (global_retrans_handle, (double) (src_arr [cur_tx_ac] + 1));
		src_arr [cur_tx_ac]  = 0;
		wlan_flags->rts_sent = OPC_FALSE;

		/* Write an ODB message if enabled.									*/
		if (wlan_trace_active)
			{
			sprintf (msg_string, "Block MPDU with seq num %d and frag num %d of TID %d is retransmitted.",
					 pk_dhstruct_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE, pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK, hld_ptr->up);
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}
		}

	/* If it is a retransmission of a packet. Obtain the frame from the 	*/
	/* the copy pointer which was stored during the previous transmission.	*/
	else if ((src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac] > 0) && (mpdu_retx_copy_arr [cur_tx_ac] != OPC_NIL))
		{
		/* If it is a retransmission then just transmit the previous frame.	*/			
		wlan_transmit_frame_ptr = op_pk_copy (mpdu_retx_copy_arr [cur_tx_ac]);

		/* Access the header fields of the frame.							*/
		op_pk_fd_access_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, (void **) &pk_dhstruct_ptr);

		/* Set the retry bit since this is a retransmission following an	*/
		/* external collision.												*/
		pk_dhstruct_ptr->retry = OPC_TRUE;
		
		/* Printing out information to ODB.									*/
		if (wlan_trace_active == OPC_TRUE)
			{
			sprintf (msg_string, "Data fragment %d for packet " OPC_PACKET_ID_FMT " is retransmitted.",
					 pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK, served_pk_id_arr [cur_tx_ac]);							
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}					

		/* Calculate NAV duration till the channel will be occupied by 		*/
		/* station. The duration is SIFS time plus the ACK frame time,		*/
		/* which the station needs in response to the data frame (note: no	*/
		/* need to check for broadcast packets, since for broadcast packets	*/
		/* the encapsulating if condition will be never true).				*/
		duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);//hay keef bto7sob leduaration feild value with ack		
			
		/* Since the number of fragments for the last transmitted frame is	*/
		/* already decremented, there will be more fragments to transmit  	*/
		/* if number of fragments is more than zero.					  	*/
		if (num_fragments_arr [cur_tx_ac] != 1)	
			{
			/* If more fragments need to be transmitted then the station 	*/
			/* need to compute the duration until the receipt of the       	*/
			/* the acknowledgement for the next fragment. 224 bits (header	*/
			/* size) is the length of the control fields in the data  		*/
			/* frame and needs to be accounted in the duration calculation.	*/
			if (num_fragments_arr [cur_tx_ac] == 2)
				tx_datapacket_size = remainder_size_arr [cur_tx_ac] + MPDU_HEADER_SIZE (hld_ptr->type);
			else
				tx_datapacket_size = frag_threshold + MPDU_HEADER_SIZE (hld_ptr->type);
			duration = 2 * duration + sifs_time + TXTIME_DATA (tx_datapacket_size);
			}

		/* Set the type of the expected response to "ACK".					*/			
		expected_frame_type = WlanC_Ack;
		}
	
	else
		{
		if (wlan_flags->not_first_in_txop == OPC_FALSE)
				{
				//this is the first frame in the transmission opportunity
				number_of_TXOP_in_calculation_period++;
				TXOP_displasement_total += current_time - last_TXOP_start_time;
				
				TXOP_counter ++;
				
				bits_sent_in_the_last_TXOP = total_bits_sent_in_the_last_TXOP;
				total_bits_sent_in_the_last_TXOP = 0;
				
				op_stat_write (TXOP_displasement_stat,current_time - last_TXOP_start_time);
				last_TXOP_start_time = current_time;
				}
		
		notRetransmission_flag = 1;
		/* Creating transmit data packet type.								*/
		wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_mac");
		
		/* If we are an AP or a STA in an ad-hoc BSS, with nQSTAs in it,	*/
		/* then don't use the frame type "QoS Data" for any broadcast.		*/
		if (hld_ptr->dest_addr < 0 && wlan_flags->ad_hoc_or_ap == OPC_TRUE && my_bss_info_ptr->nqsta_count > 0)	
			hld_ptr->type = WlanC_Data;
		
		/* Add QoS control element to QoS data frames, which is not added	*/
		/* to management or regular data frames.							*/
		if (hld_ptr->type == WlanC_QoS_Data)
			{
			op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_TYPE_FD, WlanC_QoS_Data, OPC_FIELD_SIZE_UNCHANGED);
			
			/* Create, populate and set the QoS Control field.				*/
			qos_fields_ptr = (WlanT_QoS_Control_Fields *) op_prg_mem_alloc (sizeof (WlanT_QoS_Control_Fields));
			qos_fields_ptr->tid        = hld_ptr->up;
			qos_fields_ptr->ack_policy = hld_ptr->ack_policy;
			op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_DATA_QOS_FD, qos_fields_ptr, OPC_FIELD_SIZE_UNCHANGED,	
						      op_prg_mem_copy_create, op_prg_mem_free, sizeof (WlanT_QoS_Control_Fields));
		
			/* Header size is different for QoS data frames because of QoS	*/
			/* control field.												*/
			header_size = WLANC_QOS_MPDU_HEADER_SIZE;
			}
		else
			{
			op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_TYPE_FD, hld_ptr->type, OPC_FIELD_SIZE_UNCHANGED);
			header_size = WLANC_MPDU_HEADER_SIZE;
			}
		
		/* Prepare data frame fields for transmission.						*/		
		pk_dhstruct_ptr = wlan_pk_dhstruct_create ();
		pk_dhstruct_ptr->order = 1;

		/* Set the address information.										*/
		pk_dhstruct_ptr->address1  = hld_ptr->dest_addr;
		pk_dhstruct_ptr->address2  = my_address;
		
		

		/* If this is a data frame forwarded by QAP to one of the STAs in	*/
		/* its BSS, then fromds bit is set, and address3 field of the		*/
		/* header is set to the address of the MAC that is the original		*/
		/* source of the packet.											*/
		if (ap_flag == OPC_BOOLINT_ENABLED)
			{
			pk_dhstruct_ptr->fromds	= 1;
			pk_dhstruct_ptr->address3 = hld_ptr->orig_addr;
			}
		else
			pk_dhstruct_ptr->fromds	= 0;		
		
		/* if in the BSS network the Data frame is going from STA to AP		*/
		/* then tods bit is set.											*/					
		if ((bss_flag == OPC_TRUE) && (ap_flag == OPC_BOOLINT_DISABLED))
			{
			pk_dhstruct_ptr->tods = 1;
			
			/* If Infrastructure BSS then the immediate destination will be	*/
			/* access point, which then forward the frame to the			*/
			/* appropriate destination.										*/
			pk_dhstruct_ptr->address1 = ap_mac_address;
			pk_dhstruct_ptr->address3 = hld_ptr->dest_addr;
			}
		else
			{
			pk_dhstruct_ptr->tods = 0;
			}
		//mohammad
		if(myDebugFlag)
			{
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f I am sending data packet from %d to %d\n",op_sim_time(),my_address,hld_ptr->dest_addr);
			fclose(MyExcecutionTrace);
			
		
			
			}
		
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:I am sending data packet from %d to %d",(int)my_address,(int)my_address,(int)hld_ptr->dest_addr);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		//end mohammad
		
		/* In management frames, address3 conveys the BSSID, which is		*/
		/* stored as orig_addr in their records.							*/
		if (!(hld_ptr->type & WLANC_DATA_TYPE_BIT))
			pk_dhstruct_ptr->address3 = hld_ptr->orig_addr;
		
		/* Store the sequence number of the frame.							*/ 
		pk_dhstruct_ptr->sequence_control = pkt_seq_cntl_arr [cur_tx_ac];

		/* Reset the retry bit.												*/
		pk_dhstruct_ptr->retry = OPC_FALSE;

		/* Store the protocol information of the higher layer data.			*/
		pk_dhstruct_ptr->hl_protocol = hld_ptr->protocol_type;
		
		/* Calculate NAV duration till the channel will be occupied by  	*/
		/* station. The duration is SIFS time plus the ACK frame time   	*/
		/* which the station needs in response to the data frame. For		*/
		/* broadcast packets or unicast packets with "No ACK" policy, the	*/
		/* duration is zero since they are not acknowledged.				*/
		if (hld_ptr->ack_policy == WlanC_Normal_ACK)
			duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
		else
			duration = 0.0;
			
		/* Printing out information to ODB.									*/
		if (wlan_trace_active == OPC_TRUE)
			{
			sprintf (msg_string, "Fragment %d for packet " OPC_PACKET_ID_FMT " is transmitted.", 
					 pkt_seq_cntl_arr [cur_tx_ac] & WLANC_FRAG_NUM_BIT_MASK, served_pk_id_arr [cur_tx_ac]);							
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}

		/* If there is more than one fragment to transmit then remove		*/
		/* fragmentation threshold size length of data from the buffer for	*/
		/* transmission.													*/
		if  (num_fragments_arr [cur_tx_ac] > 1)
			{
			/* Remove next fragment from the fragmentation buffer for 		*/
			/* transmission and set the appropriate fragment number.  		*/
			seg_pkptr = op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [cur_tx_ac], frag_threshold);
			
			/* Indicate in transmission frame that more fragments need to	*/
			/* be sent.														*/
			pk_dhstruct_ptr->more_frag = 1;
				
			/* Since more fragments need to be transmitted then the station	*/
			/* needs to broadcast the time until the receipt of the			*/
			/* acknowledgement for the next fragment. 224 bits (header 		*/
			/* size) is the length of control fields in the data frame and	*/
			/* need to be accounted for in the duration	calculation.		*/
			if (num_fragments_arr [cur_tx_ac] == 2)
				tx_datapacket_size = remainder_size_arr [cur_tx_ac] + header_size;
			else
				tx_datapacket_size = frag_threshold + header_size;
			next_frag_dur = TXTIME_DATA (tx_datapacket_size) + duration + sifs_time;
			
			/* If this is not the first frame of the current TXOP, then we	*/
			/* will send the next fragment only if we have sufficient time	*/
			/* left in our TXOP.											*/
			if (wlan_flags->not_first_in_txop == OPC_FALSE)
				{
								
				duration += next_frag_dur;
				}
			else
				{
				/* This is not the initial frame of the TXOP. Check whether	*/
				/* there is sufficient TXOP time for the next fragment.		*/
				/* Only if the receiver is not busy do we perform the 		*/
				/* following check.											*/
				tx_datapacket_size = frag_threshold + header_size;				
				if ((wlan_flags->receiver_busy == OPC_FALSE) &&
					(txop_limit_arr [cur_tx_ac] - (current_time + TXTIME_DATA (tx_datapacket_size) + duration + next_frag_dur - txop_start_time) >= 0.0))
					{
					/* Next fragment doesn't exceed the TXOP limit.			*/
					duration += next_frag_dur;
				
					/* Set the txop_on flag.								*/
					wlan_flags->txop_on = OPC_TRUE;
					
					/* If enabled, write a ODB trace message.				*/
					if (wlan_trace_active)
						{
						sprintf (msg_string, "Currently %.0f usec, after current transmission %.0f usec, after the tx of next MPDU %.0f usec.\n",
								 (txop_limit_arr [cur_tx_ac] - (current_time - txop_start_time)) * 1000000,
								 (txop_limit_arr [cur_tx_ac] - (current_time + TXTIME_DATA (tx_datapacket_size) + duration - next_frag_dur - txop_start_time)) * 1000000,
								 (txop_limit_arr [cur_tx_ac] - (current_time + TXTIME_DATA (tx_datapacket_size) + duration - txop_start_time)) * 1000000);
						op_prg_odb_print_major ("The MAC will continue transmitting MPDUs in the current TXOP. Remaining TXOP time:", msg_string, OPC_NIL);
						}
					}
				}
			
			/* Increment the sequence control for the next fragment to be	*/
			/* transmitted.													*/
			pkt_seq_cntl_arr [cur_tx_ac] += 1;    	
			}
		else
			{
			/* Remove the last fragment from the fragmentation buffer for	*/
			/* transmission and disable more fragmentation bit.				*/												
			seg_pkptr = op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [cur_tx_ac], remainder_size_arr [cur_tx_ac]);								
				
			/* "More fragments" bit is not set for the last fragment.		*/
			pk_dhstruct_ptr->more_frag = 0;
			}
		
		copy_pkptr = op_pk_copy (seg_pkptr); //mohammad this is to get the data from the packet

		/* Set the duration field.											*/
		pk_dhstruct_ptr->duration  = duration;
			
		/* If we are sending the first fragment of the data fragment for	*/
		/* the first time, then this is the end of media access duration,	*/
		/* hence we must update the media access delay statistics.			*/
		if ((pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK) == 0)
			{
			mac_delay = current_time - hld_ptr->time_rcvd;
			op_stat_write (media_access_delay,                       mac_delay);
			op_stat_write (ac_access_delay_shndl_arr [cur_tx_ac],    mac_delay);
			op_stat_write (global_mac_delay_handle,                  mac_delay);
			op_stat_write (ac_gb_access_delay_shndl_arr [cur_tx_ac], mac_delay);
			}
			
		/* Populate the packet fields.										*/
		op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_ACCEPT_FD, OPC_TRUE, 					 OPC_FIELD_SIZE_UNCHANGED);
		op_pk_fd_set_pkid  (wlan_transmit_frame_ptr, WLANC_DATA_PKID_FD,   served_pk_id_arr [cur_tx_ac], OPC_FIELD_SIZE_UNCHANGED);
		
		/* Insert the header into the packet.								*/
		op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, pk_dhstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,	
				          wlan_pk_dhstruct_copy, wlan_pk_dhstruct_destroy, sizeof (WlanT_Data_Header_Fields));
		
		/* The actual data is placed in the Frame Body field.				*/
		op_pk_fd_set_pkt (wlan_transmit_frame_ptr, WLANC_DATA_BODY_FD, seg_pkptr, OPC_FIELD_SIZE_UNCHANGED);
		
		/* Add some bulk to the packet to model the transmission delay of	*/
		/* PLCP fields accurately which are always transmitted at 1	Mbps	*/
		/* regardless of the actual data rate used for data frames.			*/
		total_plcp_overhead = PLCP_OVERHEAD_DATA ((int) op_pk_total_size_get (wlan_transmit_frame_ptr) - WLANC_DEFAULT_PLCP_OVERHEAD);
		bulk_size           = total_plcp_overhead * operational_speed - WLANC_DEFAULT_PLCP_OVERHEAD;
		op_pk_bulk_size_set (wlan_transmit_frame_ptr, (OpT_Packet_Size) bulk_size);
		
		/* Expect acknowledgement if packet's ACK policy is "normal ACK".	*/
		if (hld_ptr->ack_policy == WlanC_Normal_ACK)
			{
			/* ACK frame is expected in response to data frame.				*/
			expected_frame_type = WlanC_Ack;
			
			/* Make a copy of the packet for possible retransmissions.		*/
			mpdu_retx_copy_arr [cur_tx_ac] = op_pk_copy (wlan_transmit_frame_ptr);
			}
		else
			{
			
			/* No (immediate) ACK is expected in response to data frame.	*/
			expected_frame_type = WlanC_None;
			
			/* Reset the retry count because we won't await an ACK. The		*/
			/* retry count can be non-zero even for a broadcast	frame since	*/
			/* it can be proceeded by a CTS-to-self frame in an	11g WLAN,	*/
			/* which may have been retransmitted. Similarly, RTS-CTS might	*/
			/* be used before a unicast frame with "No/Block ACK" policy.	*/
			/* Update the related local and global statistics if there were	*/
			/* retransmissions.												*/
			if (src_arr [cur_tx_ac] > 0)
				{
				op_stat_write (retrans_handle,        (double) src_arr [cur_tx_ac]);
				op_stat_write (global_retrans_handle, (double) src_arr [cur_tx_ac]);
				src_arr [cur_tx_ac] = 0;
				}
				
			/* Due to possible earlier use of CTS-to-self or RTS/CTS frame	*/
			/* exchange, reset the rts_sent flag.							*/
			wlan_flags->rts_sent = OPC_FALSE;
			
			/* Since no ACK is expected, no immediate retransmission will	*/
			/* happen.														*/
			mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
			
			/* In case of block ACK policy, store a copy of the MPDU in the	*/
			/* block ACK retransmission buffer.								*/
			if (hld_ptr->ack_policy == WlanC_Block_ACK)
				{
				/* Get the block ACK information record.					*/
				ba_info_ptr = hld_ptr->addr1_info_ptr->ba_state_ptr_arr [hld_ptr->up];
				
				/* If the retransmission buffer is full, resize it (this is	*/
				/* very unlikely to happen, and	can happen only if delayed	*/
				/* BA policy is in use).									*/
				if (ba_info_ptr->mpdu_count == ba_info_ptr->retx_arr_size)
					{
					/* Increase the size of the array by half of the block	*/
					/* size.												*/
					new_arr_size = ba_info_ptr->retx_arr_size + (int) ceil ((double) ba_info_ptr->block_size / 2.0);
					new_retx_arr = (WlanT_HCF_Hld_Info **) op_prg_mem_alloc (new_arr_size * sizeof (WlanT_HCF_Hld_Info *));
					
					/* Copy the contents of the old array into the new one.	*/
					op_prg_mem_copy (ba_info_ptr->retx_arr, new_retx_arr, ba_info_ptr->retx_arr_size * sizeof (WlanT_HCF_Hld_Info *));
					ba_info_ptr->retx_arr_size = new_arr_size;
					
					/* Destroy the old retransmission buffer array.			*/
					op_prg_mem_free (ba_info_ptr->retx_arr);
					ba_info_ptr->retx_arr = new_retx_arr;

			        /* If inactivity timeout is disabled, and the size of	*/
                    /* the retransmission buffer is at least double of the	*/
                    /* block size (and at least 32 if a small block size is */
                    /* used) and awaiting_delayed_ba flag is set, then      */
                    /* probably we are awaiting a delayed BA that will      */
                    /* never arrive (because the peer discarded its delayed */
                    /* BA due to excessive retransmission attempts). Since  */
                    /* this will prevent us sending new BARs, reset the     */
                    /* flag to be able to continue with proper operation.   */
                    if (tc_config_arr [hld_ptr->up].ba_timeout_value == NO_BA_INACTIVITY_TIMEOUT && 
                        new_arr_size >= 2 * ba_info_ptr->block_size && new_arr_size >= 32)
                        ba_info_ptr->awaiting_delayed_ba = OPC_FALSE;		
					}

				/* If inactivity timeout is disabled and we are waiting for	*/
				/* a delayed BA, and it has been more than 					*/
				/* MAX_DELAYED_BA_WAIT_TIME since we received an ACK for	*/
				/* BAR, then probably that delayed BA will	never arrive	*/
				/* (because the peer discarded its delayed BA due to		*/
				/* excessive retransmission attempts). Since this will		*/
				/* prevent us sending new BARs, reset the flag to be able	*/
				/* to continue with proper operation.						*/
				if (tc_config_arr [hld_ptr->up].ba_timeout_value == NO_BA_INACTIVITY_TIMEOUT &&
					ba_info_ptr->awaiting_delayed_ba && current_time - ba_info_ptr->bar_ack_time > MAX_DELAYED_BA_WAIT_TIME)
					ba_info_ptr->awaiting_delayed_ba = OPC_FALSE;
				
				/* Insert the copy into the buffer.							*/
				ba_info_ptr->retx_arr [ba_info_ptr->mpdu_count] = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);
				op_prg_mem_copy (hld_ptr, ba_info_ptr->retx_arr [ba_info_ptr->mpdu_count], sizeof (WlanT_HCF_Hld_Info));
				ba_info_ptr->retx_arr [ba_info_ptr->mpdu_count]->pkptr = op_pk_copy (wlan_transmit_frame_ptr);
				ba_info_ptr->retx_arr [ba_info_ptr->mpdu_count]->size  = (num_fragments_arr [cur_tx_ac] > 1 ? frag_threshold : remainder_size_arr [cur_tx_ac]);
				ba_info_ptr->retx_arr [ba_info_ptr->mpdu_count]->time_rcvd = current_time;
				
				/* Increment the number of MPDUs in the retransmission		*/
				/* buffer.													*/
				ba_info_ptr->mpdu_count++;
				
				/* If this is the first MPDU using BA, stop the 			*/
				/* corresponding inactivity timer, if enabled, unless the	*/
				/* retransmission buffer was emptied not because of 		*/
				/* receiving a BA, but because of discarding the last BAR	*/
				/* due to consistently failing transmissions and reaching	*/
				/* the transmission lifetime limit.							*/
				if (ba_info_ptr->mpdu_count == 1 && tc_config_arr [hld_ptr->up].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT &&
					ba_info_ptr->bar_tx_time == 0.0)
					op_ev_cancel (ba_info_ptr->inactivity_evh);
				
				/* If this is the last fragment of the MSDU, decrement the	*/
				/* number of the queued MSDUs with block-ACK policy.		*/
				if (num_fragments_arr [cur_tx_ac] == 1)
					ba_info_ptr->queued_msdu_count--;
				
				/* Check whether it is time to send a Block ACK Request.	*/
				/* A BAR is enqueued to be transmitted by the AC following	*/
				/* transmission of the current MSDU if one of the following	*/
				/* conditions are true (no new BAR will be enqueued if a	*/
				/* delayed BA is awaited or there is already a queued BAR):	*/
				/* 1. There are no more MSDUs already queued that can be	*/
				/*    included in the block.								*/
				/* 2. Block size limit will be reached while transmitting	*/
				/*    the MPDUs of the current MSDU (block size is assumed	*/
				/*    4 MPDUs less when delayed BA policy is in use, since	*/
				/*    the recipient may receive more MPDUs from us before	*/
				/* 	  we receive its delayed BA).							*/
				/* 3. Fragmentation is enabled and there is possibility	of	*/
				/*    exceeding the block size while sending the fragments	*/
				/*    of the next MSDU.										*/
				/* 4. With the addition of the currently transmitted MSDU,	*/
				/*    now block contains 64 MSDUs (because a BA can			*/
				/*    acknowledge only up to 64 MSDUs).						*/
				if (ba_info_ptr->awaiting_delayed_ba == OPC_FALSE && ba_info_ptr->bar_pending == OPC_FALSE &&
					(ba_info_ptr->queued_msdu_count == 0 ||
					 ba_info_ptr->mpdu_count + 
					 	((tc_config_arr [hld_ptr->up].ba_policy == WlanC_Delayed_BA && ba_info_ptr->block_size > DELAYED_BA_BK_SIZE_ADJ) ? DELAYED_BA_BK_SIZE_ADJ : 0) 
							== ba_info_ptr->block_size ||
					 ba_info_ptr->mpdu_count + max_frags_per_msdu > ba_info_ptr->block_size ||		
					 (wlan_hcf_seq_a_minus_seq_b ((pkt_seq_cntl_arr [cur_tx_ac] >> WLANC_FRAG_NUM_SIZE), ba_info_ptr->starting_seq_num, ba_info_ptr->block_size) + 1 == WLANC_BA_STATUS_BITMAP_MAX_MSDU && 
					  (pkt_seq_cntl_arr [cur_tx_ac] & WLANC_FRAG_NUM_BIT_MASK) == 0)))
					{
					wlan_hcf_ba_control_enqueue (WlanC_BAR, (wlan_flags->ad_hoc_or_ap == OPC_FALSE) ? ap_mac_address : hld_ptr->dest_addr, hld_ptr->up, cur_tx_ac);
					
					/* Set the flag indicating existence of a queued BAR.	*/
					ba_info_ptr->bar_pending = OPC_TRUE;
					}
				}
			}
		
		
		
		
		/*if(cur_tx_ac == WlanC_AC_VI)
			{
			total_data_header_size_sent += total_pk_size - op_stat_local_read(3); //(mohammad) calculate header size and add it to total
			total_data_size_sent_without_headers += op_stat_local_read(3);//(mohammad) calculate to la data sent
			data_packet_sent_count ++;
		
			}*/
		
		}
					
	/* Place the transmission data rate and physical layer technology		*/
	/* information into the packet.											*/
	wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, operational_speed, phy_type, phy_char_flag);
	
	
	/* Based on whether we are sending a data or management frame, update	*/
	/* the corresponding traffic sent statistics. For accuracy, write a		*/
	/* value of 0 for the end of transmission.								*/
	total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
	
	
	//if the packet is a new video data frame packet 
	if(hld_ptr->type & WLANC_DATA_TYPE_BIT && cur_tx_ac == WlanC_AC_VI && notRetransmission_flag ==1)
		{
		
		/*int myDatasize;
		int frameN, packetN, packetStatus,FrameSizeInPackets,imageLineNumber,q;
		//read data recorded by the app regarding data size 
	
		if(opencvDebugFlag)
			{
			op_pk_fd_get (copy_pkptr, 1, &frameN);
			op_pk_fd_get (copy_pkptr, 2, &packetN);
			op_pk_fd_get (copy_pkptr, 3, &packetStatus);
			op_pk_fd_get (copy_pkptr, 4, &FrameSizeInPackets);
			if(current_time > EAestimationTime+1)
				{
				op_pk_fd_get (copy_pkptr, 5, &imageLineNumber);
				op_pk_fd_get (copy_pkptr, 6, & q);
				}
			op_pk_fd_get (copy_pkptr, 7, &myDatasize);
			
			
			opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
			fprintf(opencvDebugFile,"MAC %d:frameN = %d\tpacketN=%d\tFrameSizeInPackets=%d\tpacketStatus=%d\tcurrent_time=%f\timageLineNumber=%d\tq=%d\tmyDatasize=%d\n"
				,(int)my_address,(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)packetStatus,(float)current_time,imageLineNumber,q,myDatasize);
			fclose(opencvDebugFile);
			}*/
		
		total_data_size_sent_without_headers += op_pk_total_size_get (copy_pkptr);//seg_pkptr);//(mohammad) calculate to la data sent
		printf("I am  %d:total data size without headers = %d\n",(int)my_address, (int)total_data_size_sent_without_headers);
		total_data_header_size_sent += total_pk_size - op_pk_total_size_get (copy_pkptr); //(mohammad) calculate header size and add it to total
		printf("I am  %d:total data header size = %d\n",(int)my_address, (int)total_data_header_size_sent);
		total_bits_sent_in_the_last_TXOP += op_pk_total_size_get (copy_pkptr);
		printf("I am  %d:total bits sent in the last TXOP = %d\n",(int)my_address, (int)total_bits_sent_in_the_last_TXOP);
		
		
		
		
		data_packet_sent_count ++;
		//printf("data_size_sent_without_headers = %d, header size = %d, data_packet_sent_count = %d\n", (int)op_pk_total_size_get (copy_pkptr),(int)(total_pk_size - op_pk_total_size_get (copy_pkptr)), (int)data_packet_sent_count);
		//printf("total_data_size_sent_without_headers = %d, toral header size = %d\n", (int)total_data_size_sent_without_headers,(int)total_data_header_size_sent);
		last_sent_video_frame_time = current_time;
		last_sent_video_frame_size = total_pk_size;
		last_sent_video_frame_size_without_header = op_pk_total_size_get (copy_pkptr);//read backet data stat from app layer
		notRetransmission_flag = 0;
		op_stat_write (data_packet_sent_count_stat, data_packet_sent_count);
		op_stat_write (packet_data_percent_stat, op_pk_total_size_get (copy_pkptr)/total_pk_size);
		
		//printf("I am %d:before distroying the copy\n",my_address);
	
		op_pk_destroy (copy_pkptr);
		//printf("I am %d:after distroying the copy\n",my_address);
		
		
		}
	
	
	
	//if the packet is a new data frame packet 
	if(hld_ptr->type & WLANC_DATA_TYPE_BIT && notRetransmission_flag ==1)
		{
		//data_frames_sent_in_the_last_stateREport_int_count ++;
		//last_sent_video_frame_time = current_time;
		//last_sent_video_frame_size = total_pk_size;
		//notRetransmission_flag = 0;
		
		}
	
	//if the packet is a data frame packet 
	//if(hld_ptr->type & WLANC_DATA_TYPE_BIT)
		//{
		//last_sent_video_frame_time = current_time;
		//last_sent_video_frame_size = total_pk_size;
		//}
		
	
	//op_stat_write (packet_size_stat, total_pk_size);
	
		
	tx_time     = total_pk_size / operational_speed;
	tx_end_time = current_time + tx_time;
	if (hld_ptr->type & WLANC_DATA_TYPE_BIT)
		{
		
		//last_sent_video_frame_time = current_time;
		//last_sent_video_frame_size = total_pk_size;
		
		
		op_stat_write (data_traffic_sent_handle_inbits, total_pk_size);
		op_stat_write (data_traffic_sent_handle, 1.0);
		op_stat_write_t (data_traffic_sent_handle_inbits, 0.0, tx_end_time);
		op_stat_write_t (data_traffic_sent_handle, 0.0, tx_end_time);
		
		
		my_sent_sum += total_pk_size;
		//my_sent = total_pk_size/(tx_end_time - last_my_sent_calculated_time);
		//last_my_sent_calculated_time = tx_end_time;
		
		
		}
	else
		{
		op_stat_write (mgmt_traffic_sent_handle_inbits, total_pk_size);
		op_stat_write (mgmt_traffic_sent_handle, 1.0);
		op_stat_write_t (mgmt_traffic_sent_handle_inbits, 0.0, tx_end_time);
		op_stat_write_t (mgmt_traffic_sent_handle, 0.0, tx_end_time);
		}
	
	/* If this is the last MPDU (fragment) of the current MSDU,	check		*/
	/* whether we can start the transmission of a new MSDU within the		*/
	/* current TXOP. 														*/
	if (txop_limit_arr [cur_tx_ac] != 0.0				 && num_fragments_arr [cur_tx_ac] == 1 && 
		op_prg_list_size (hlpk_lptr_arr [cur_tx_ac]) > 1 && AP_CONNECTED						  )
		{
		/* Multiple MSDUs within a single TXOP are allowed and the AC has	*/
		/* at least one more higher layer packet to send. Compute the time	*/
		/* that will have left in the current TXOP duration when the		*/
		/* current transmission completes with its response frame, if any.	*/
		/* Don't forget to account for signal extension if it will be used.	*/
		txop_time_left = txop_limit_arr [cur_tx_ac] - (current_time - txop_start_time) - duration -
						 ((phy_char_flag == WlanC_ERP_OFDM_11g && operational_speed > 5500000.0 && operational_speed != 11000000.0) ? 
						 tx_time + WLANC_11g_SIGNAL_EXTENSION : tx_time);

		/* Remaining TXOP time won't be useful if it is less than SIFS.		*/
		if (txop_time_left >= sifs_time)
			{
			/* Access the header information of the packet, unless we have	*/
			/* already done it earlier (retransmission case).				*/
			if (pk_dhstruct_ptr->retry == OPC_FALSE && hld_ptr->ba_retx == OPC_FALSE)
				op_pk_fd_access_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, (void **) &pk_dhstruct_ptr);
			
			/* Check whether we can fit another transmission into our		*/
			/* current TXOP. This function call will update the	duration	*/
			/* field of the frame when it realizes that another				*/
			/* transmission is possible within the TXOP.					*/
			wlan_flags->txop_on = wlan_hcf_next_txop_transmission_check (txop_time_left, &(pk_dhstruct_ptr->duration), 1);
			}
		}

	/* Reset the "response frame to send" variable if we are expecting an	*/
	/* ACK frame.															*/
	if (hld_ptr->ack_policy == WlanC_Normal_ACK)
		fresp_to_send = WlanC_None;
	else
		{
		/* Decrement the number of pending fragments. An MSDU may be		*/
		/* fragmented even under block ACK policy.							*/
		num_fragments_arr [cur_tx_ac]--;
		
		/* Dequeue the packet from transmission buffer if all of its		*/
		/* fragments are transmitted.										*/
		if (num_fragments_arr [cur_tx_ac] == 0)
			{
			/* Dequeue the packet from higher layer buffer since we are		*/
			/* done with it (no retransmissions for unacknowledged packets).*/
			wlan_hcf_hlpk_dequeue (cur_tx_ac, 0);

			/* Reset the "response frame to send" variable and set the 		*/
			/* CW-required bit flag unless we will have a following			*/
			/* transmission within our TXOP.								*/
			if (wlan_flags->txop_on == OPC_FALSE)
				{
				fresp_to_send = WlanC_None;
				wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
				}
			else
				{
				/* We will continue with another transmission.				*/
				fresp_to_send = WlanC_QoS_Data;
				
				/* Reset the CW since we have a successful transmission		*/
				/* within the TXOP.											*/
				cw_arr [cur_tx_ac] = cwmin_arr [cur_tx_ac];
				}
			}
		}
					
	/* Send packet to the transmitter.										*/
	op_pk_send (wlan_transmit_frame_ptr, LOW_LAYER_OUTPUT_STREAM);	
	wlan_flags->transmitter_busy = OPC_TRUE;
	
	/* Set the flag if the current transmission requires signal extension.	*/
	if (phy_char_flag == WlanC_ERP_OFDM_11g && operational_speed > 5500000.0 && operational_speed != 11000000.0)
		wlan_flags->wait_signal_ext = OPC_TRUE;
	
	if(myStringDebug)
		{
		sprintf(myString,"I am  %d:send data frame function DONE",(int)my_address,(int)my_address, importance);
		op_prg_odb_print_major(myString,OPC_NIL);
		}

	FOUT;
	}

static Boolean
wlan_hcf_next_txop_transmission_check (double txop_time_left, double* duration_ptr, int queue_index)
	{	
	int					frame_size;
	WlanT_HCF_Hld_Info*	hld_ptr;
	double				tx_time;
	double				next_tx_drate;
	char				msg_string [256];
	
	/** This function checks whether the next frame in the queue of the AC	**/
	/** that owns the current TXOP can be also transmitted before the end	**/
	/** of the TXOP. The function will return OPC_TRUE if this is possible,	**/
	/** OPC_FALSE otherwise. If the next frame in the queue has to be		**/
	/** fragmented, then the function will check for the possibility of		**/
	/** transmitting only the first fragment of the frame within the TXOP.	**/
	FIN (wlan_hcf_next_txop_transmission_check (txop_time_left, duration_ptr, queue_index));
	
	/* No data trasmission while the receiver is busy. We will terminate 	*/
	/* TXOP earlier.														*/
	if (wlan_flags->receiver_busy == OPC_TRUE)
		FRET (OPC_FALSE);
	
	/* Access the record of the next higher layer packet in the AC's buffer.*/
	hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [cur_tx_ac], queue_index);
	
	/* Find out the frame size of the next transmission. Pay attention to	*/
	/* fragmentation possibility.											*/
	if (frag_threshold == -1 || hld_ptr->ack_policy == WlanC_No_ACK || hld_ptr->size < frag_threshold)
		frame_size = (int) hld_ptr->size + MPDU_HEADER_SIZE (hld_ptr->type);
	else
		frame_size = frag_threshold + MPDU_HEADER_SIZE (hld_ptr->type);
	
	/* Compute the transmission time of the complete frame with SIFS. Be	*/
	/* careful since we may need to use a different data rate for the next	*/
	/* transmission, if we are an 11g-capable node and the destination is a	*/
	/* non-ERP STA.															*/
	if (phy_type == WlanC_11g_PHY && wlan_flags->non_erp_present && wlan_flags->ad_hoc_or_ap && data_tx_rate > 5500000.0 && data_tx_rate != 11000000.0)
		{
		/* Check whether the destination is 11g capable. We will use an 11b	*/
		/* data rate if the next transmission is a broadcast due to the		*/
		/* presence of non-ERP STA(s) in the BSS. If the destination is		*/
		/* unknown, use 11g data rate not to waste time.					*/
		if (hld_ptr->dest_addr < 0 || (hld_ptr->addr1_info_ptr != PRGC_NIL && hld_ptr->addr1_info_ptr->is_erp == OPC_FALSE))
			{
			/* Pick the highest 11b data rate that is lower than our		*/
			/* regular 11g data rate.										*/
			next_tx_drate = (data_tx_rate > 11000000.0) ? 11000000.0 : 5500000.0;
			}
		else
			next_tx_drate = data_tx_rate;
		
		/* Compute the transmission time using the data rate that will be	*/
		/* used.															*/
		tx_time = sifs_time + TXTIME_DATA_DR (frame_size, next_tx_drate);
		}
	else
		tx_time = sifs_time + TXTIME_DATA (frame_size);
	
	/* If needed, add the time to transmit the response (ACK) frame.		*/
	if (hld_ptr->ack_policy == WlanC_Normal_ACK)
		tx_time += sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
		
	/* Check whether there is enough time for the next transmission.		*/
	if (txop_time_left >= tx_time)
		{
		/* There is. Update the duration field of the current transmission	*/
		/* in order to reserve the medium also for the next transmission.	*/
		*duration_ptr = *duration_ptr + tx_time;

		/* If enabled, write a ODB trace message.							*/
		if (wlan_trace_active)
			{
			sprintf (msg_string, "Currently %.0f usec, after current transmission %.0f usec, after the tx of next MPDU %.0f usec.\n",
								(txop_limit_arr [cur_tx_ac] - (current_time - txop_start_time)) * 1000000,
								txop_time_left * 1000000,
								(txop_time_left - tx_time) * 1000000);
			op_prg_odb_print_major ("The MAC will continue transmitting MPDUs in the current TXOP. Remaining TXOP time:", msg_string, OPC_NIL);
			}

		/* Return OPC_TRUE since there is sufficient time in the TXOP for	*/
		/* the next transmission.											*/
		FRET (OPC_TRUE);
		}
	
	/* The time left in TXOP is not sufficient for another transmission.	*/
	FRET (OPC_FALSE);
	}

static void
wlan_hcf_beacon_send (void)
	{
	Packet*							seg_pkptr;
	Packet*							wlan_transmit_frame_ptr;
	WlanT_Beacon_Body_Fields*		pk_bbstruct_ptr;
	WlanT_Data_Header_Fields*		pk_dhstruct_ptr;
	WlanT_HCF_Hld_Info*				beacon_info_ptr;
	int								add_beacon_size;
	int								i;
	double							tx_data_rate;
	double							mac_delay;
	double							total_pk_size;	
	double							tx_time, tx_end_time;
	double							txop_time_left;
	double							total_plcp_overhead;
	double							bulk_size;
	
	
	OmsT_Pr_Handle					temp_process_record_handle;
	List * 							temp_proc_record_handle_list_ptr;
	int 							stations_no;
	Objid							temp_mac_objid;
	int 							temp_statype;
	int								temp_mac_address = -1;
	OpT_Int64						temp_sta_addr;
	WlanT_HCF_Peer_Info*			peer_info_ptr;
	
	
	
	double							LAMBDA;
	double 							sum = 0,sumB=0, EAestimation = 0;
	double							sumH = 0;
	double							sumD = 0;
	double							sumTXOP=0;
	double							b;
	//static int 						EAcalculatedFlag = 0;

	/** This function creates a beacon frame, populates its fields and		**/
	/** sends it to the receiver. It determines which information is		**/
	/** included in the frame body and adjusts the frame size accordingly.	**/
	FIN (wlan_hcf_beacon_send (void));
	
	/*Loren
	printf("I am %d: entering beacon send function.\n", (int)my_address);
	*/
	
	/* First initialize the transmission data rate to the lowest supported	*/
	/* data rate, which is the data rate used for beacons.					*/
	tx_data_rate = control_data_rate;

	/* Record that the last transmitted frame is a beacon.					*/
	last_tx_frtype_arr [cur_tx_ac] = WlanC_Beac;

	/* Create packet container for beacon body.								*/
	seg_pkptr = op_pk_create_fmt ("wlan_beacon_body");
	
	/* Initialize the bit count that will be added to the size of the		*/
	/* beacon body to represent the size of the optional beacon frame body	*/
	/* elements.															*/
	add_beacon_size = 0;
		
	/* Create beacon body.													*/
	pk_bbstruct_ptr = wlan_pk_bbstruct_create ();
	
	/* Timestamp should be set to reference 1st bit of timestamp in			*/
	/* message at antenna (11.1.2.1). To reduce processing, it is currently	*/
	/* set for first bit of MAC frame at antenna (assuming no PHY delay).	*/
	pk_bbstruct_ptr->timestamp  = current_time;
	pk_bbstruct_ptr->beacon_intv = beacon_int;
	
	/* This is not a beacon to start a CFP (PCF).							*/ 
	pk_bbstruct_ptr->cf_par.cfp_count = 1;   
	pk_bbstruct_ptr->cf_par.cfp_period = 0;
    
	
	
	if(current_time > EAestimationTime-1 && strcmp(tempBnadwidth_allocation_method,"matlabOptimization_accu")!=0 && strcmp(tempBnadwidth_allocation_method,"matlabOptimization_accuD")!=0
		&& strcmp(tempBnadwidth_allocation_method,"matlabOptimization_dist")!=0 && strcmp(tempBnadwidth_allocation_method,"matlabOptimization_wdist")!=0 )
		{
	
		if(strcmp(tempBnadwidth_allocation_method,"EDCA")!=0&&strcmp(tempBnadwidth_allocation_method,"app_only")!=0&& strcmp(tempBnadwidth_allocation_method,"link_only")!=0)
			{
	
	
			//********************************************************************
			///******************calculating LAMBDA*******************************
			//********************************************************************
	
	
	
			//Mohammad this code is to find number of stations S in the network
			/* Search for the other WLAN MACs that are in the same LAN with us.	*/
			temp_proc_record_handle_list_ptr = op_prg_list_create ();

		
			/* If the subnet is BSS based then do the process discovery using	*/
			/* BSS ID (domain_id), otherwise do it using subnet ID.				*/
			if (bss_id_type == WlanC_Bss_Divided_Subnet)
				{
				oms_pr_process_discover (OPC_OBJID_INVALID, temp_proc_record_handle_list_ptr, 
				"domain_id",			OMSC_PR_NUMBER,  		 (double) bss_id,
				"mac_type",			OMSC_PR_STRING,	 		 "wireless_lan",
				"protocol",			OMSC_PR_STRING,			 "mac",
				OPC_NIL);
				}
			else
				{
				oms_pr_process_discover (OPC_OBJID_INVALID, temp_proc_record_handle_list_ptr, 
				"subnetid",			OMSC_PR_OBJID,			 my_subnet_objid,
				"mac_type",			OMSC_PR_STRING,			"wireless_lan",
				"protocol",			OMSC_PR_STRING,			"mac",
				OPC_NIL);
				}

			/* Find out the number of WLAN MACs belonging to our BSS, execluding	*/
			/* this MAC (AP).														*/
			stations_no = op_prg_list_size (temp_proc_record_handle_list_ptr) - 1;//(Mohammad) This is S
		
			if(fee_lambda_trace_flag)
				{
				sprintf(myString,"I am  %d:Number of stations in the network is %d",(int)my_address,stations_no);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
	
	
			op_stat_write(number_of_stations, (int)stations_no);
	
	
	
	
			/* Traversing the process record handle list to determine if there	*/
			/* is any access point in the subnet and to collect information		*/
			/* about other STAs in our BSS.										*/
			sumB = 0;
			sum = 0;
			sumTXOP = 0;
			for (i = 0; i < stations_no+1; i++ )
				{
				/* Obtain a handle on the process record.						*/
				temp_process_record_handle = (OmsT_Pr_Handle) op_prg_list_access (temp_proc_record_handle_list_ptr, i);
				
				/* Get the station type.										*/
				oms_pr_attr_get (temp_process_record_handle, "subprotocol", OMSC_PR_INT32, &temp_statype);
				
				/* Obtain the MAC address of the STA. Read the value of the		*/
				/* corresponding attribute to make sure that we get the final	*/
				/* value.														*/
				oms_pr_attr_get (temp_process_record_handle, "module objid", OMSC_PR_OBJID, &temp_mac_objid);
				op_ima_obj_attr_get (temp_mac_objid, "Address", &temp_mac_address);
				temp_sta_addr = temp_mac_address;
			
				/* If the station is an Access Point ignor it				*/
				if (temp_statype == WlanC_QAP || temp_statype == WlanC_AP)
					{
					continue;
					}
			
				if(EAcalculatedFlag && !totalDataResetedFalgArray[i])
					{
					//reset total data sent
					totalPeerStreamData[i] = 0;
					totalPeerStreamData2[i] = 0;
					if(current_time > EAestimationTime + transitionTime)//time sensitive
						totalDataResetedFalgArray[i] = 1;
					}
			
			
				peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &temp_sta_addr);
			
				if(peer_info_ptr == PRGC_NIL)
					op_sim_end ("peer info are not available. check the code that add to the hash table", "", "", "");
				
				if(fee_lambda_trace_flag)
					{
					sprintf(myString,"I am  %d:node %d information: a=%f, b=%f, c=%f, importance=%f, frameRate=%f, physicalRate=%f, droppedBRate=%f, droppedRRate=%f",(int)my_address,i,peer_info_ptr -> peer_a , peer_info_ptr -> peer_b ,peer_info_ptr -> peer_c , peer_info_ptr -> peer_importance , 
						(double)peer_info_ptr -> peer_frameRate, peer_info_ptr -> peer_physicalRate, peer_info_ptr -> peer_droppedBRate, peer_info_ptr -> peer_droppedRRate);
					op_prg_odb_print_major(myString,OPC_NIL);
					}
			
				if(strcmp(tempBnadwidth_allocation_method,"dist2")==0)
					{
					double tb= (peer_info_ptr ->peer_b*peer_info_ptr -> peer_physicalRate/1000000.0/(double)peer_info_ptr -> peer_frameRate);
					double ta = pow(peer_info_ptr -> peer_a,2);
					sum += (log( ta*tb*log(2.0))/log(2.0))/tb;
					sumB+= 1.0/tb;
					}
				else if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0)
					{
					double tb= (peer_info_ptr ->peer_b*peer_info_ptr -> peer_physicalRate/1000000.0/(double)peer_info_ptr -> peer_frameRate);
					double ta = pow(peer_info_ptr -> peer_a,2);
					// Loren: typecast log arguments for C++
					sum += (log( (double)peer_info_ptr -> peer_importance*ta*tb*log(2.0))/log(2.0))/tb;
					sumB+= 1.0/tb;
					}
				else if(strcmp(tempBnadwidth_allocation_method,"faccu")==0)//accuracy without weight
					{
					sum+= 
						pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate * 
								pow(peer_info_ptr -> peer_physicalRate/(double)peer_info_ptr -> peer_frameRate,peer_info_ptr -> peer_b-1.0)),1.0/(peer_info_ptr -> peer_b-1.0));
					}
					
				else if(strcmp(tempBnadwidth_allocation_method,"accu")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link")==0  
					|| strcmp(tempBnadwidth_allocation_method,"wdis")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_link")==0 
					||strcmp(tempBnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(tempBnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0 
					|| strcmp(tempBnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0 || strcmp(tempBnadwidth_allocation_method,"accu_D2")==0
					)
					{
					sum+= 
						pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_importance * peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate * 
								pow(peer_info_ptr -> peer_physicalRate/(double)peer_info_ptr -> peer_frameRate,peer_info_ptr -> peer_b-1.0)),1.0/(peer_info_ptr -> peer_b-1.0));
					
					}
				else if(strcmp(tempBnadwidth_allocation_method,"accu_app")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_app")==0 )
					{
					sum+= 
						pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_importance * peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate * 
								pow(peer_info_ptr -> peer_physicalRate/(double)peer_info_ptr -> peer_frameRate,peer_info_ptr -> peer_b-1.0)),1.0/(peer_info_ptr -> peer_b-1.0));
					}
				else if(strcmp(tempBnadwidth_allocation_method,"dist")==0|| strcmp(tempBnadwidth_allocation_method,"dist_app")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link")==0
					|| strcmp(tempBnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0
					)	
					{
					sum+= 
						pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate * 
								pow(peer_info_ptr -> peer_physicalRate/(double)peer_info_ptr -> peer_frameRate,peer_info_ptr -> peer_b-1.0)),1.0/(peer_info_ptr -> peer_b-1.0));
					}
			
			
				//with header overhead
				else if(strcmp(tempBnadwidth_allocation_method,"accu_H")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link_H")==0 
					|| strcmp(tempBnadwidth_allocation_method,"wdis_H")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_link_H")==0
					||strcmp(tempBnadwidth_allocation_method,"accu_D")==0 || strcmp(tempBnadwidth_allocation_method,"wdis_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link_D")==0
					|| strcmp(tempBnadwidth_allocation_method,"accu_onlyApp_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_onlylink_D")==0)
					{
					sum+= 
						(peer_info_ptr -> peer_frameRate * pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_importance * peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate),1.0/(peer_info_ptr -> peer_b-1.0)))/peer_info_ptr -> peer_physicalRate;
					}
				else if(strcmp(tempBnadwidth_allocation_method,"accu_app_H")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_app_H")==0 || strcmp(tempBnadwidth_allocation_method,"accu_app_D")==0)
					{
					sum+= 
						(peer_info_ptr -> peer_frameRate * pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_importance * peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate),1.0/(peer_info_ptr -> peer_b-1.0)))/peer_info_ptr -> peer_physicalRate;
					}
				else if(strcmp(tempBnadwidth_allocation_method,"dist_D")==0||strcmp(tempBnadwidth_allocation_method,"dist_H")==0|| strcmp(tempBnadwidth_allocation_method,"dist_app_H")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link_H")==0)
					{
					sum+= 
						(peer_info_ptr -> peer_frameRate * pow(-(double)peer_info_ptr -> peer_frameRate 
							/ (peer_info_ptr -> peer_a * peer_info_ptr -> peer_b * peer_info_ptr -> peer_physicalRate),1.0/(peer_info_ptr -> peer_b-1.0)))/peer_info_ptr -> peer_physicalRate;
					}
				
			
				b = peer_info_ptr -> peer_b;
				
				if(EAcalculatedFlag != 1)
					EAestimation += totalPeerStreamData[i]/(current_time-start_times[i])/peer_info_ptr -> peer_physicalRate;//for estimation
			
				sumH+=peer_info_ptr -> peer_averageProtocolOverhead/peer_info_ptr -> peer_physicalRate;
				
				
				
				
				sumD+=dropping[i]/peer_info_ptr -> peer_physicalRate;//(peer_info_ptr -> peer_droppedBRate+peer_info_ptr -> peer_droppedRRate)/peer_info_ptr -> peer_physicalRate ;
				
							
				if(EAcalculatedFlag && (current_time - EACalculationLastTime >= EACalculationPeriod) )//reset dropping data to wait for new data from nodes
					{
					peer_info_ptr -> peer_droppedBRate = 0;
					peer_info_ptr -> peer_droppedRRate = 0;
					}
				
				
				
				sumTXOP += peer_info_ptr -> peer_TXOP;
			
				}//end of for (i = 0; i < stations_no+1; i++ ) 
			
			
			if(sumD > 0 && (lastOperation == 0 || lastOperation == -1) && current_time > EACalculationLastTime + EACalculationPeriod/2.0 )
				{
				
				sumsumD += sumD;
				sumDCounter ++;
				}
			else if (sumD > 0 && lastOperation == 1)
				{
				sumsumD += sumD;
				sumDCounter ++;
				}
			
				
		
		
			if (current_time > EAestimationTime && EAcalculatedFlag != 1 && EAestimationFlag == 1)
				{
				EAcalculatedFlag = 1;
				EA = EAestimation;// * 1.1;
				//EA = 0.32;
				//printf("before change bnadwidth_allocation_method = %s and tempBnadwidth_allocation_method = %s\n",bnadwidth_allocation_method,tempBnadwidth_allocation_method);
				sprintf(bnadwidth_allocation_method,"%s",tempBnadwidth_allocation_method);
				
				//printf("after change bnadwidth_allocation_method = %s and tempBnadwidth_allocation_method = %s\n",bnadwidth_allocation_method,tempBnadwidth_allocation_method);
			
				}
			else if (current_time <= EAestimationTime)
				{
				//EA = 1.0/(2.0/(cwmin_arr [WlanC_AC_VI]+2)/sumTXOP/stations_no +	( 1 + (2.0*stations_no/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(cwmin_arr [WlanC_AC_VI]/(cwmin_arr [WlanC_AC_VI]+2.0),stations_no-1)));//EA using per catigory CWmin and TXOP
				EA = 1.0/(( 1 + (2.0*stations_no/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(cwmin_arr [WlanC_AC_VI]/(cwmin_arr [WlanC_AC_VI]+2.0),stations_no-1)));//EA using per catigory CWmin and without TXOP
				//EA = 0.3*EA;
				//EA = 1.0/	( 1 + (2.0*stations_no/(double)(phy_cw_min+ 2.0))*pow(/phy_cw_min/(phy_cw_min+2.0),stations_no-1));//EA using phy CWmin
				}
			
			
			
			
			
			/*
			overshooting at the begining
			//var1
			if(!EAdone && EAcalculatedFlag && current_time < EAestimationTime + transitionTime && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d\n ",sumDCounter,sumsumD/sumDCounter,lastOperation);
				if(sumDCounter == 0 ||  sumsumD/sumDCounter < 0.005 )//if(dropping is Zero)
					{
											
					//last operation was decrement
						
						lastIncrement = 0.5 *lastDecrement;
						EA = EA + lastIncrement;
						lastOperation = 1;
						incrementCounter++; 
						
					//if(lastOperation == -1) //initial
					//	{
					//	EA = EA + 0.05;
					//	lastIncrement = 0.05;
					//	}
					
					
					//if(lastIncrement < 0.0005)
						//EAdone = 1;
					if(incrementCounter > 20)
						EAdone = 1;
					}
				else if (sumsumD/sumDCounter >=  0.005 )
					{
					
					lastDecrement = 0.5*sumsumD/sumDCounter;
					EA = EA - lastDecrement;
					lastOperation = 0;
					}
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				
				}
			*/
			
			/*//var2
			printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
			if(!EAdone && EAcalculatedFlag && (current_time < EAestimationTime + transitionTime) && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
								
				if(sumDCounter != 0 && fabs((float)(sumsumD/sumDCounter -  0.005)) <=0.000002)
					{
						EAdone = 1;
					}
				else 
					{
				
					printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d\n ",sumDCounter,sumsumD/sumDCounter,lastOperation);
					if(sumDCounter == 0 ||  sumsumD/sumDCounter < 0.005 )//if(dropping is Zero)
						{
											
						//last operation was decrement
						
						lastIncrement = 0.5 *lastDecrement;
						EA = EA + 0.02;
						lastOperation = 1;
						incrementCounter++; 
						
						
					
						}
					else if (sumsumD/sumDCounter >=  0.005 )
						{
					
						lastDecrement = sumsumD/sumDCounter - 0.005 ;
						EA = EA - lastDecrement;
						lastOperation = 0;
						}
							
					}
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				
				}
			*/
			
			/*
			
			//as good as the final algo
			if(!EAdone && EAcalculatedFlag && (current_time < EAestimationTime + transitionTime) && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
								
				if(sumDCounter != 0 && fabs((float)(sumsumD/sumDCounter -  0.005)) <=0.000002)
					{
						EAdone = 1;
					}
				else 
					{
				
					printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d\n ",sumDCounter,sumsumD/sumDCounter,lastOperation);
					if(sumDCounter == 0 ||  sumsumD/sumDCounter < 0.005 )//if(dropping is Zero)
						{
											
						if(lastOperation == 0)//last operation was decrement
							{
							lastIncrement = 0.5 *lastDecrement;
							EA = EA + lastIncrement;
							lastOperation = 1;
							}
						else if(lastOperation == 1)//last operation was increment
							{
							lastIncrement =  0.5 * lastIncrement;
							EA = EA + lastIncrement;//lastIncrement;
							lastOperation = 1;
							}
						else //initial
							{
							EA = EA + 0.05;
							lastIncrement = 0.05;
							}
					

						}
					else if (sumsumD/sumDCounter >=  0.005 )
						{
						EA = EA - sumsumD/sumDCounter;
						lastDecrement = sumsumD/sumDCounter;
						lastOperation = 0;
						}
						
					}
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				
				}
			*/
			
			
			//PID will run all simulation time
			if(!EAdone && EAcalculatedFlag && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				
				BeforeLastError=LastError;
				LastError=error;
				
				if(sumDCounter != 0)				
					error=0.005-sumsumD/sumDCounter;
				else
					error = (float)0.005;
				
				
				if(EA + Kprop*error - Kinteg*LastError + Kderv*BeforeLastError > 0 )
					EA = EA + Kprop*error - Kinteg*LastError + Kderv*BeforeLastError;
				else
					EA = 0;
				
				//Loren
				sprintf(myString,"I am  %d:EA is calculated as %f, during PID.",(int)my_address,(double)EA);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				
				}
			
			if(current_time > EAestimationTime + transitionTime)
			{
				//Loren
				if(LorenDebugFlag)
				{
					sprintf(myString,"I am %d, sim done just compared current time (%f) to EA estimation time + transition time (%d).", (int)my_address, (float)current_time, (int)EAestimationTime+(int)transitionTime);
					op_prg_odb_print_major(myString,OPC_NIL);
				}
				
				//Loren
				sprintf(myString,"I am  %d:EA is calculated as %f",(int)my_address,(double)EA);
				op_prg_odb_print_major(myString,OPC_NIL);
				sprintf(myString,"I am  %d:EAestimation is calculated as %f",(int)my_address,(double)EAestimation);
				op_prg_odb_print_major(myString,OPC_NIL);
				//op_sim_end ("EA estimation is done", "", "", "");
			}
			
			
			
			//final algo
			/*
			
			if(!EAdone && EAcalculatedFlag && current_time < EAestimationTime + transitionTime && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d\n ",sumDCounter,sumsumD/sumDCounter,lastOperation);
				if(sumDCounter == 0 ||  sumsumD/sumDCounter < 0.005 )//if(dropping is Zero)
					{
											
					if(lastOperation == 0)//last operation was decrement
						{
						lastIncrement = 0.5 *lastDecrement;
						EA = EA + lastIncrement;
						lastOperation = 1;
						}
					else if(lastOperation == 1)//last operation was increment
						{
						lastIncrement =  0.5 * lastIncrement;
						EA = EA + lastIncrement;//lastIncrement;
						lastOperation = 1;
						}
					else //initial
						{
						EA = EA + 0.05;
						lastIncrement = 0.05;
						}
					
					if(lastIncrement < 0.0005)
						EAdone = 1;
					}
				else if (sumsumD/sumDCounter >=  0.005 )
					{
					EA = EA - sumsumD/sumDCounter;
					lastDecrement = sumsumD/sumDCounter;
					lastOperation = 0;
					}
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				
				}
			*/
			
			
			/*
			//very simple with advanced increase
			if(!EAdone && EAcalculatedFlag && (current_time < EAestimationTime + transitionTime) && (current_time > EAestimationTime+1) && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
								
				if(sumDCounter!=0 && fabs(sumsumD/sumDCounter - 0.005) <=0.00000001)
					EAdone = 1;
				else if(sumDCounter == 0  || sumsumD/sumDCounter < 0.005)
					{
					
						if(lastOperation == 0)//last operation was decrement
							{
							lastIncrement = 0.5 *lastDecrement;
							EA = EA + lastIncrement;
							lastOperation = 1;
							}
						else if(lastOperation == 1)//last operation was increment
							{
							lastIncrement =  0.5 * lastIncrement;
							EA = EA + lastIncrement;//lastIncrement;
							lastOperation = 1;
							}
						else //initial
							{
							EA = EA + 0.05;
							lastIncrement = 0.05;
							}
							
						
					}
				else if (sumsumD/sumDCounter > 0.005)
					{
					EA = EA - sumsumD/sumDCounter;
						lastDecrement = sumsumD/sumDCounter;
						lastOperation = 0;
					}
				
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				}
			*/
			
			/*
			
			
			//very simple with simple increase
			if(!EAdone && EAcalculatedFlag && (current_time < EAestimationTime + transitionTime) && (current_time > EAestimationTime+1) && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
								
				if(sumDCounter!=0 && fabs(sumsumD/sumDCounter - 0.005) <=0.00000001)
				
					EAdone = 1;
				
				if(sumDCounter == 0  || sumsumD/sumDCounter < 0.005)
					{
					
						EA = EA + 0.01;
							
						
					}
				else if (sumsumD/sumDCounter > 0.005)
					EA = EA - sumsumD/sumDCounter - 0.005 ;
				
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				}
			*/
			
			/*
			
			//very simple
			if(!EAdone && EAcalculatedFlag && (current_time < EAestimationTime + transitionTime) && (current_time > EAestimationTime+1) && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				printf("sumDCounter = %d, sumsumD/sumDCounter = %f, lastOperation = %d, abs(sumsumD/sumDCounter -  0.005) = %f, sumsumD/sumDCounter -  0.005 = %f\n ",sumDCounter,sumsumD/sumDCounter,lastOperation, fabs((float)(sumsumD/sumDCounter -  0.005)), (float)(sumsumD/sumDCounter -  0.005));
								
				if(sumDCounter == 0  || sumsumD/sumDCounter <= 0.005)
					{
						
					
						EAdone = 1;
					}	
				else
					EA = EA - sumsumD/sumDCounter - 0.005 ;
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				}
			
			
			*/
			
			
			/*
			
			
			
			//the one before last version
			if(EAcalculatedFlag && current_time < EAestimationTime + transitionTime && (current_time - EACalculationLastTime >= EACalculationPeriod) ) 
				{
				if(sumDCounter == 0 ||  sumsumD/sumDCounter < 0.005 )//if(dropping is Zero)
					{
											
					if(lastOperation == 0)//last operation was decrement
						{
						if(incrementCounter < 20)
							lastIncrement = 0.5 *lastDecrement;
						else
							lastIncrement = lastDecrement;
							
						EA = EA + lastIncrement;
						}
					else //last operation was increment
						{
						EA = EA + 0.5 * lastIncrement;//lastIncrement;
						lastIncrement =  0.5 * lastIncrement;
						}
					if(current_time < EAestimationTime + EACalculationPeriod)	
						{
						lastOperation = 0;
						}
					else
						{
						lastOperation = 1;
						lastEAWithoutDropping = EA;
						}
						incrementCounter++;
					}
				else if (sumsumD/sumDCounter >=  0.005 )
					{
					EA = EA - sumsumD/sumDCounter;
					lastDecrement = sumsumD/sumDCounter;
					lastOperation = 0;
					}
				
				EACalculationLastTime = current_time;
				sumDCounter = 0;
				sumsumD = 0;
				if(incrementCounter >=20)
					{
					EAsum += EA;
					EAcounter++;
					
					
					EA = EAsum/EAcounter;
					}
				}
			
				
				
			*/
			
			if(strcmp(tempBnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0)
				EA = 1.0/(( 1 + (2.0*stations_no/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(cwmin_arr [WlanC_AC_VI]/(cwmin_arr [WlanC_AC_VI]+2.0),stations_no-1)));//EA using per catigory CWmin and without TXOP
				
						
			op_stat_write(EA_stat, (double)EA);
			op_stat_write(sumD_stat, (double)sumD);
		
			if(fee_lambda_trace_flag)
				{
				sprintf(myString,"I am  %d:EA is calculated as %f",(int)my_address,EA);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
		
			if(strcmp(tempBnadwidth_allocation_method,"dist2")==0||strcmp(tempBnadwidth_allocation_method,"wdis2")==0)
				{
				LAMBDA = pow(2,(sum-EA)/(double)sumB);
				}
			
			else if(strcmp(tempBnadwidth_allocation_method,"faccu")==0 ||strcmp(tempBnadwidth_allocation_method,"accu")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link")==0 
				|| strcmp(tempBnadwidth_allocation_method,"wdis")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_link")==0
				||strcmp(tempBnadwidth_allocation_method,"accu_app")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_app")==0
				||strcmp(tempBnadwidth_allocation_method,"dist")==0|| strcmp(tempBnadwidth_allocation_method,"dist_app")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link")==0
				|| strcmp(tempBnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(tempBnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(tempBnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
				|| strcmp(tempBnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(tempBnadwidth_allocation_method,"accu_D2")==0
				)
				{
			
				LAMBDA = pow((double)EA/sum,(b - 1.0));
				}
			else if(strcmp(tempBnadwidth_allocation_method,"accu_H")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link_H")==0 
				|| strcmp(tempBnadwidth_allocation_method,"wdis_H")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_link_H")==0
				||strcmp(tempBnadwidth_allocation_method,"accu_app_H")==0 ||strcmp(tempBnadwidth_allocation_method,"wdis_app_H")==0
				||strcmp(tempBnadwidth_allocation_method,"dist_H")==0|| strcmp(tempBnadwidth_allocation_method,"dist_app_H")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link_H")==0)
				{
				LAMBDA = pow(((double)EA+sumH)/sum,(b - 1.0));
				}
			else if(strcmp(tempBnadwidth_allocation_method,"accu_D")==0||strcmp(tempBnadwidth_allocation_method,"dist_D")==0||strcmp(tempBnadwidth_allocation_method,"wdis_D")==0 
				|| strcmp(tempBnadwidth_allocation_method,"accu_link_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_app_D")==0
				|| strcmp(tempBnadwidth_allocation_method,"accu_onlyApp_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_onlylink_D")==0)
				{
				LAMBDA = pow(((double)EA-sumD)/sum,(b - 1.0));
				//LAMBDA = pow((double)EA/sum,(b - 1.0));
				}
			else if((strcmp(tempBnadwidth_allocation_method,"EDCA_estimation")==0 ||strcmp(tempBnadwidth_allocation_method,"EDCA_estimation_txop")==0)&& EAcalculatedFlag)
				{
				LAMBDA = EA;
				}
		
		
				
			op_stat_write(LoopSum_stat, (double) sum);
			op_stat_write(AP_Lambda_stat, (double) LAMBDA);
	
			if(fee_lambda_trace_flag)
				{
				sprintf(myString,"I am  %d:Sum is calculated as %40.40f",(int)my_address,(double)sum);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				sprintf(myString,"I am  %d:SumH is calculated as %40.40f",(int)my_address,(double)sumH);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				sprintf(myString,"I am  %d:SumD is calculated as %40.40f",(int)my_address,(double)sumD);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				
				sprintf(myString,"I am  %d:EA is calculated as %e",(int)my_address,(double)EA);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				sprintf(myString,"I am  %d:LAMBDA is calculated as %e",(int)my_address,(double)LAMBDA);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				sprintf(myString,"I am  %d:EAestimation is calculated as %f",(int)my_address,(double)EAestimation);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				}
			
			if(EA <=0)
					op_sim_end ("EA is calculated as 0 or less", "", "", "");
				
			
			if(LAMBDA <=0  && current_time > EAestimationTime+transitionTime)
				op_sim_end ("Invalid LAMBDA calculated in AP", "", "", "");
			
			pk_bbstruct_ptr->lambda = LAMBDA;
			}///end of calculating LAMBDA
		}//end of 
		
	/* If we are an 11g supporting AP, then set the non_erp_present bit of	*/
	/* the beacon if there are some non-ERP STAs in our BSS.				*/
	if (phy_type == WlanC_11g_PHY)
		{
		/* Lock the related mutex before checking the current number of		*/
		/* non-ERP STAs in our BSS.											*/
		op_prg_mt_mutex_lock (mapping_info_mutex, OPC_MT_MUTEX_LOCK_READER);
			
		/* Check whether there is a change in the count of non-ERP STAs in	*/
		/* our BSS.															*/
		if (wlan_flags->non_erp_present == OPC_FALSE && my_bss_info_ptr->non_erp_sta_count > 0)
			{
			/* We have a new non-ERP STA in our BSS. Set the flag.			*/
			wlan_flags->non_erp_present = OPC_TRUE;
			
			/* Increase the slot time to 20 usec and recompute the			*/
			/* dependent parameters.										*/
			wlan_hcf_slot_time_set (20E-06);

			/* Reduce the control frame data rate to 802.11/11b mandatory	*/
			/* data rate.													*/
			control_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
			}
		
		else if (wlan_flags->non_erp_present == OPC_TRUE && my_bss_info_ptr->non_erp_sta_count == 0)
			{
			/* All the non-ERP STAs have left our BSS. Reset the flag.		*/
			wlan_flags->non_erp_present = OPC_FALSE;
			
			/* Decrease the slot time to 9 usec and recompute the			*/
			/* dependent parameters.										*/
			wlan_hcf_slot_time_set (9E-06);
				
			/* Set our data transmission rate to the original data rate,	*/
			/* since we could be using a lower data rate to communicate		*/
			/* with non-ERP STAs.											*/
			operational_speed = data_tx_rate;
			
			/* Reselect the control frame data rate. Choose the highest		*/
			/* mandatory data rate that is equal to or lower than the data	*/
			/* rate specified for data transmissions.						*/
			for (i = 0; data_tx_rate < WLANC_11g_MANDATORY_DRATE_ARRAY [i]; i++);
			control_data_rate = WLANC_11g_MANDATORY_DRATE_ARRAY [i];
			}
		
		/* Unlock the mutex since we are done accessing the BSS info.		*/
		op_prg_mt_mutex_unlock (mapping_info_mutex);
		
		/* Set the non_erp_present bit value of the beacon frame.			*/
		pk_bbstruct_ptr->non_erp_present = wlan_flags->non_erp_present;
		
		/* Since we are an AP supporting 11g data rates, make sure that we	*/
		/* transmit our beacon messages with the lowest 802.11/11b			*/
		/* mandatory data rate so that if there are any roaming non-ERP		*/
		/* STAs in the network that are in the scanning process, they can	*/
		/* decode our beacons and join into our BSS.						*/
		tx_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
		
		/* Make additions to the size of beacon due to the 11g specific		*/
		/* elements added to the beacon frame body. 11g APs are assumed to	*/
		/* support 12 data rates. Hence, increase the size of the			*/
		/* "Supported Rates" by six rates (= 6 bytes) and also add an		*/
		/* "Extended Supported Rates" elements for the remaining 4 rates,	*/
		/* which also becomes 6 bytes. Finally add the sizes of "DS			*/
		/* Parameter Set" and "ERP Information" elements, which are	both	*/
		/* are 3 bytes.														*/
		add_beacon_size += 10 * WLANC_BC_COMP_SUP_RATE_SIZE + WLANC_BC_COMP_EXT_RATES_SIZE + 
						   WLANC_BC_COMP_DS_PS_SIZE + WLANC_BC_COMP_ERP_INFO_SIZE + WLANC_BC_COMP_LAMBDA_PS_SIZE;
		}
	
	else if (phy_type == WlanC_11a_PHY)
		{
		/* 11a-APs support 8 data rates. Adjust the beacon body size for	*/
		/* additional 6 rates in the "Supported Rates" element.				*/
		add_beacon_size += 6 * WLANC_BC_COMP_SUP_RATE_SIZE;
		}
	else if (phy_char_flag == WlanC_Direct_Sequence)
		{
		/* DSSS-APs support 4 data rates. Adjust the beacon body size for	*/
		/* additional 2 rates in the "Supported Rates" element, and for the	*/
		/* "DS Parameter Set" element.										*/
		add_beacon_size += 2 * WLANC_BC_COMP_SUP_RATE_SIZE + WLANC_BC_COMP_DS_PS_SIZE;
		}
	else if (phy_char_flag == WlanC_Frequency_Hopping)
		{
		/* Add 7 bytes to the beacon size to represent the "FH Parameter	*/
		/* Set" element, which exists in beacons generated by the APs using	*/
		/* frequency-hopping PHYs.											*/
		add_beacon_size += WLANC_BC_COMP_FH_PS_SIZE;
		}			
	
	/* Advertise the EDCA parameters for access categories in the beacon	*/
	/* if we are configured to do so.										*/
	if (bss_edca_params_arr != OPC_NIL)
		{
		pk_bbstruct_ptr->edca_param_set_arr = (WlanT_AC_EDCA_Param_Rec *)
			op_prg_mem_copy_create (bss_edca_params_arr, sizeof (WlanT_AC_EDCA_Param_Rec) * WLANC_HCF_AC_COUNT);
		
		/* Since the beacon is carrying an "EDCA Parameter Set" information,*/
		/* increase the beacon size further by 20 bytes.					*/
		add_beacon_size += WLANC_BC_COMP_EDCA_PS_SIZE;
		}
	else
		pk_bbstruct_ptr->edca_param_set_arr = OPC_NIL;
	
	/* If any, add the bits of optional beacon frame body elements to the	*/
	/* size of the beacon as bulk size.										*/
	op_pk_bulk_size_set (seg_pkptr, (OpT_Packet_Size) add_beacon_size);
		
	/* Use data frame format for beacon frame since we need frame body.		*/

	/* Creating transmit data packet type.									*/
	wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_mac");
		
	/* Prepare data frame fields for transmission.							*/		
	pk_dhstruct_ptr = wlan_pk_dhstruct_create ();	
	pk_dhstruct_ptr->retry = OPC_FALSE;				
	pk_dhstruct_ptr->order = 1;
	pk_dhstruct_ptr->sequence_control = pkt_seq_cntl_arr [cur_tx_ac];

	/* Setting the Header field structure. Set the destination address to	*/
	/* broadcast. During CP duration is set to zero since broadcast			*/
	/* (Section 7.2.3).														*/
	pk_dhstruct_ptr->duration  = 0.0;
	pk_dhstruct_ptr->address1  = MAC_BROADCAST_ADDR;
	pk_dhstruct_ptr->address2  = my_address;
	
	/* This value is checked at the receiving end to see if this frame was	*/
	/* intended for this BSS ID.											*/
	pk_dhstruct_ptr->address3  = bss_id;

	/* Management frames (Beacon) never involve DS.							*/
	pk_dhstruct_ptr->fromds	 = 0;
	pk_dhstruct_ptr->tods    = 0;
	
	/* Start setting the packet fields.										*/
	op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_TYPE_FD, WlanC_Beac, OPC_FIELD_SIZE_UNCHANGED);
	op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
	
	/* Set the frame control field.											*/
	op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, pk_dhstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,	
				      wlan_pk_dhstruct_copy, wlan_pk_dhstruct_destroy, sizeof (WlanT_Data_Header_Fields));

	/* The beacon body is placed in the Packet container.					*/
	op_pk_fd_set_ptr (seg_pkptr, WLANC_BEACON_BODY_FD, pk_bbstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,	
				      wlan_pk_bbstruct_copy, wlan_pk_bbstruct_destroy, sizeof (WlanT_Beacon_Body_Fields));

	/* The beacon body "packet" is placed in the Frame Body field			*/
	op_pk_fd_set_pkt (wlan_transmit_frame_ptr, WLANC_DATA_BODY_FD, seg_pkptr, OPC_FIELD_SIZE_UNCHANGED);
	
	/* Place the transmission data rate and physical layer technology		*/
	/* information into the packet.											*/
	wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
	
	/* Adjust the packet size if necessary to model the PLCP overhead		*/
	/* accurately, which is physical layer technology dependent. The		*/
	/* default value is set for infra-red technology.						*/
	if (phy_char_flag != WlanC_Infra_Red)
		{
		total_plcp_overhead = PLCP_OVERHEAD_CTRL_DR (((int) op_pk_total_size_get (wlan_transmit_frame_ptr) -  WLANC_DEFAULT_PLCP_OVERHEAD), tx_data_rate);
		bulk_size			= total_plcp_overhead * tx_data_rate - WLANC_DEFAULT_PLCP_OVERHEAD;
		op_pk_bulk_size_set (wlan_transmit_frame_ptr,(OpT_Packet_Size) bulk_size);
		}
	
	/* Printing out information to ODB.										*/
	if (wlan_trace_active == OPC_TRUE)
		{
		op_prg_odb_print_major ("Beacon is being transmitted by the Access Point.", OPC_NIL);
		}
	
	/* Clear tx beacon flag.												*/
	wlan_flags->tx_beacon = OPC_FALSE;
	
	/* Remove the entry of this beacon from its ACs queue.					*/
	beacon_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [WlanC_AC_VO], OPC_LISTPOS_HEAD);
	
	/* Decrement the number of queued packets and update the related		*/
	/* statistics.															*/
	total_hlpk_num--;
	op_stat_write (hl_packets_rcvd,                       (double) total_hlpk_num);
	op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]));

	/* Update the medium access statistics.									*/
	mac_delay = current_time - beacon_info_ptr->time_rcvd;
	op_stat_write (media_access_delay,                         mac_delay);
	op_stat_write (ac_access_delay_shndl_arr [WlanC_AC_VO],    mac_delay);
	op_stat_write (global_mac_delay_handle,                    mac_delay);
	op_stat_write (ac_gb_access_delay_shndl_arr [WlanC_AC_VO], mac_delay);

	/* Also update the management traffic sent statistics.					*/
	total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
	op_stat_write (mgmt_traffic_sent_handle_inbits, total_pk_size);
	op_stat_write (mgmt_traffic_sent_handle, 1.0);

	/* For accuracy, write a zero for end of transmission time.				*/
	tx_time     = total_pk_size / tx_data_rate;
	tx_end_time = current_time + tx_time;
	op_stat_write_t (mgmt_traffic_sent_handle_inbits, 0.0, tx_end_time);
	op_stat_write_t (mgmt_traffic_sent_handle, 0.0, tx_end_time);

	/* Destroy the information record.										*/
	op_prg_mem_free (beacon_info_ptr);

	/* Check whether we can start the transmission of a new MSDU within the	*/
	/* current TXOP. Initially assume that this is not possible.			*/
	wlan_flags->txop_on = OPC_FALSE;
	if (txop_limit_arr [WlanC_AC_VO] != 0.0 && op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]) > 0)
		{
		/* Multiple MSDUs within a single TXOP are allowed and the AC has	*/
		/* at least one more higher layer packet to send. Compute the time	*/
		/* that will have left in the current TXOP duration when the		*/
		/* transmission of the beacon completes.							*/
		txop_time_left = txop_limit_arr [WlanC_AC_VO] - (current_time - txop_start_time) - tx_time;

		/* Remaining TXOP time won't be useful if it is less than SIFS.		*/
		if (txop_time_left >= sifs_time)
			{
			/* Access the header information of the packet.					*/
			op_pk_fd_access_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, (void **) &pk_dhstruct_ptr);
			
			/* Check whether we can fit another transmission into our		*/
			/* current TXOP. This function call will update the	duration	*/
			/* field of the frame when it realizes that another				*/
			/* transmission is possible within the TXOP.					*/
			wlan_flags->txop_on = wlan_hcf_next_txop_transmission_check (txop_time_left, &(pk_dhstruct_ptr->duration), 0);
			}
		}

	/* Reset the "response frame to send" variable, unless we are allowed	*/
	/* at least	one more transmission in our TXOP following the beacon		*/
	/* transmission.														*/
	if (wlan_flags->txop_on == OPC_FALSE)
		{
		fresp_to_send = WlanC_None;
		
		/* Set the related bit flag, since the "Voice AC" has to perform a	*/
		/* CW-backoff following its TXOP.									*/
		wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO];
		}
	else
		{
		/* We will continue with another transmission after our broadcast.	*/
		fresp_to_send = WlanC_QoS_Data;
		
		/* Reset the CW since we have a successful transmission	within the	*/
		/* TXOP.															*/
		cw_arr [WlanC_AC_VO] = cwmin_arr [WlanC_AC_VO];
		}
	
	
	
	{// mohammad
	
		WlanT_Mac_Frame_Type my_frame_type;
	
		op_pk_nfd_get_int32 (wlan_transmit_frame_ptr, "Type", (int *) &my_frame_type);
		if(my_frame_type == WlanC_Beac)
			++sent_beacon_count;

		op_stat_write_t (sent_beacon_count_stat, sent_beacon_count, op_sim_time ());
	}
	
	/* Send packet to the transmitter.										*/
	op_pk_send (wlan_transmit_frame_ptr, LOW_LAYER_OUTPUT_STREAM);	
	wlan_flags->transmitter_busy = OPC_TRUE;
	
	//mohammad
		if(myDebugFlag)
			{		
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f I sent beacon packet\n",op_sim_time());
			fclose(MyExcecutionTrace);
			
	
			
			}
	if(myStringDebug)
		{
			sprintf(myString,"I am %d:I sent beacon packet",(int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
	//end mohammad
	
	FOUT;
	}





//(mohammad) function to send state Reprot
static void 
wlan_hcf_stateReport_send (void)
	{
	Packet*							seg_pkptr;
	Packet*							wlan_transmit_frame_ptr;
	WlanT_StateReport_Body_Fields*	pk_srstruct_ptr;
	WlanT_Data_Header_Fields*		pk_dhstruct_ptr;
	WlanT_HCF_Hld_Info*				stateReport_info_ptr;
	int								add_stateReport_size;
	
	double							tx_data_rate;
	double							mac_delay;
	double							total_pk_size;	
	double							tx_time, tx_end_time;
	double							txop_time_left;
	double							total_plcp_overhead;
	double							bulk_size;
	
	
	

	/** This function creates a state report frame, populates its fields and		**/
	/** sends it to the receiver. It determines which information is		**/
	/** included in the frame body and adjusts the frame size accordingly.	**/
	FIN (wlan_hcf_stateReport_send (void));
	
	/* First initialize the transmission data rate to the lowest supported	*/
	/* data rate, which is the data rate used for beacons.					*/
	tx_data_rate = control_data_rate;

	/* Record that the last transmitted frame is a stateReport.					*/
	last_tx_frtype_arr [cur_tx_ac] = WlanC_StateReport;//chech where this array is used.

	/* Create packet container for stateReport body.								*/
	seg_pkptr = op_pk_create_fmt ("wlan_stateReport_body");
	
	/* Initialize the bit count that will be added to the size of the		*/
	/* state report body to represent the size of the state report frame body	*/
	/* elements.															*/
	add_stateReport_size = 8 * 13* 8;//size of the packet in bits
		
	/* Create state report body.													*/
	pk_srstruct_ptr = wlan_pk_srstruct_create ();
	
	
	
	/* Timestamp should be set to reference 1st bit of timestamp in			*/
	/* message at antenna (11.1.2.1). To reduce processing, it is currently	*/
	/* set for first bit of MAC frame at antenna (assuming no PHY delay).	*/
	pk_srstruct_ptr->pk_timestamp  = current_time;
	pk_srstruct_ptr->pk_stateReport_intv = stateReport_int;
	pk_srstruct_ptr->pk_a = accuracyConstant_a;
	pk_srstruct_ptr->pk_b = accuracyConstant_b;
	pk_srstruct_ptr->pk_c = accuracyConstant_c;
	pk_srstruct_ptr->pk_frameRate = op_stat_local_read(APPL_FRAMERATE_INSTAT);
	
	
	
	
	if(strcmp(bnadwidth_allocation_method,"accu_onlylink_D")!=0 && strcmp(bnadwidth_allocation_method,"accu_link_D")!=0 && strcmp(bnadwidth_allocation_method,"accu_link")!=0)
		
		pk_srstruct_ptr->pk_importance = importance;
		
	else
		pk_srstruct_ptr->pk_importance = 1.0/nodes_no;
		
	
	//pk_srstruct_ptr->pk_averageProtocolOverhead = (double)total_data_header_size_sent / data_packet_sent_count;
	pk_srstruct_ptr->pk_averageProtocolOverhead= (double)total_data_header_size_sent / (op_sim_time()-last_my_droppedB_calculated_time) + (double)op_stat_local_read(5);//last_my_droppedB_calculated_time is just the last calculation time
	last_sent_protocolOverheadRate = pk_srstruct_ptr->pk_averageProtocolOverhead;
	
	Ls = (double)total_data_size_sent_without_headers/data_packet_sent_count;
			
	Os = (double)total_data_header_size_sent / data_packet_sent_count;
			
			
			
	total_data_size_sent_without_headers = 0;
	data_packet_sent_count = 0;
	total_data_header_size_sent = 0;
	
	if(myStringDebug)
		{
		sprintf(myString,"I am  %d:importance of %d is being sent to AP(%d) via stateReport and it is %f",(int)my_address,(int)my_address,(int)ap_mac_address, importance);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	
	//physicalRate = temp_ph_rate;
	
	
	//op_prg_odb_print_major(myString,OPC_NIL);
	if(strcmp(bnadwidth_allocation_method,"accu_app")==0||strcmp(bnadwidth_allocation_method,"wdis_app")==0//||strcmp(bnadwidth_allocation_method,"dist_app")==0
		||strcmp(bnadwidth_allocation_method,"accu_app_H")==0||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0||strcmp(bnadwidth_allocation_method,"dist_app_H")==0
		||strcmp(bnadwidth_allocation_method,"accu_app_D")==0||strcmp(bnadwidth_allocation_method,"wdis_app_D")==0||strcmp(bnadwidth_allocation_method,"dist_app_D")==0
		||strcmp(bnadwidth_allocation_method,"accu_onlyApp_D")==0
	)
		{
		pk_srstruct_ptr->pk_physicalRate = max_operational_speed;
		op_stat_write (max_operational_speed_stat, max_operational_speed);
		}
	
	else if(strcmp(bnadwidth_allocation_method,"app_only")==0)
		pk_srstruct_ptr->pk_physicalRate = 54000000;
	else
		pk_srstruct_ptr->pk_physicalRate = operational_speed;
		//pk_srstruct_ptr->pk_physicalRate = temp_ph_rate/(double)data_frames_sent_in_the_last_stateREport_int_count;//this should be the effective data rate.
	
	last_sent_physicalRate = pk_srstruct_ptr->pk_physicalRate;
	
	pk_srstruct_ptr->pk_appRate = appRateBits;
	
	
	pk_srstruct_ptr->pk_droppedBRate = my_droppedB_sum/(op_sim_time()-last_my_droppedB_calculated_time);
	last_sent_droppedBRate = pk_srstruct_ptr->pk_droppedBRate;
	
	
	
	op_stat_write (my_droppedB_stat, last_sent_droppedBRate);
	
	last_my_droppedB_calculated_time = op_sim_time();
	my_droppedB_sum = 0;
	
	pk_srstruct_ptr->pk_TXOP = txop_limit_arr [WlanC_AC_VI];
	pk_srstruct_ptr->pk_droppedRRate = my_droppedR_sum/(op_sim_time()-last_my_droppedR_calculated_time);
	last_sent_droppedRRate = pk_srstruct_ptr->pk_droppedRRate;
	
	dropping[(int)my_address] = last_sent_droppedBRate + last_sent_droppedRRate;
	
	//last_sent_droppedRRate = my_droppedR_sum/(op_sim_time()-last_my_droppedR_calculated_time);
	last_sent_loadRate = my_load_sum/(op_sim_time()-last_my_load_calculated_time);
	last_sent_sentRate = my_sent_sum/(op_sim_time()-last_my_sent_calculated_time);	
	
	last_my_droppedR_calculated_time = op_sim_time();
	my_droppedR_sum = 0;
	last_my_load_calculated_time = op_sim_time();
	my_load_sum = 0;
	last_my_sent_calculated_time = op_sim_time();
	my_sent_sum = 0;
	
	last_calculated_droppedB_prob = (double)data_packet_droppedB_in_the_last_stateReport_int_count/data_packet_loaded_in_the_last_stateReport_int_count;
	data_packet_droppedB_in_the_last_stateReport_int_count = 0;
	data_packet_loaded_in_the_last_stateReport_int_count = 0;
	
	op_stat_write (my_droppedR_stat, last_sent_droppedRRate);
	op_stat_write (my_load_stat, last_sent_loadRate);
	op_stat_write (my_sent_stat, last_sent_sentRate);
	
	op_stat_write (physicalRate_stat, last_sent_physicalRate);
	
	
	
	op_stat_write (importance_stat, importance);	
	op_stat_write (frameRate_stat, frameRate);
	op_stat_write (a_stat, pk_srstruct_ptr->pk_a);
	op_stat_write (b_stat, pk_srstruct_ptr->pk_b);
	op_stat_write (c_stat, pk_srstruct_ptr->pk_c); 
	
	//did not work:op_stat_write (physicalRate_readfromtransmiter_stat, (double) op_stat_local_read(TRANSMITTER_TROUGHPUT_INSTAT)/(double) op_stat_local_read(TRANSMITTER_UTILIZATION_INSTAT));
	
	op_stat_write(data_frames_sent_in_the_last_stateREport_int_count_stat,data_frames_sent_in_the_last_stateREport_int_count);
	
	
	last_calculated_average_TXOP_displasement = TXOP_displasement_total/number_of_TXOP_in_calculation_period;
	TXOP_displasement_total = 0;
	number_of_TXOP_in_calculation_period = 0;
	
	
	//sprintf(myString,"I am  %d:StateReport is being sent ph_rate = %f",(int)my_address, last_sent_physicalRate);
	//op_prg_odb_print_major(myString,OPC_NIL);
	
	temp_ph_rate = 0;
	data_frames_sent_in_the_last_stateREport_int_count = 0;
	
	
	/* If any, add the bits of optional beacon frame body elements to the	*/
	/* size of the beacon as bulk size.										*/
	op_pk_bulk_size_set (seg_pkptr, (OpT_Packet_Size) add_stateReport_size);
		
	/* Use data frame format for stateReport frame since we need frame body.		*/

	/* Creating transmit data packet type.									*/
	wlan_transmit_frame_ptr = op_pk_create_fmt ("wlan_mac");
		
	/* Prepare data frame fields for transmission.							*/		
	pk_dhstruct_ptr = wlan_pk_dhstruct_create ();	
	pk_dhstruct_ptr->retry = OPC_FALSE;				
	pk_dhstruct_ptr->order = 1;
	pk_dhstruct_ptr->sequence_control = pkt_seq_cntl_arr [cur_tx_ac];

	/* Setting the Header field structure. Set the destination address to	*/
	/* AP. */
	pk_dhstruct_ptr->duration  = 0.0;
	pk_dhstruct_ptr->address1  = ap_mac_address;
	pk_dhstruct_ptr->address2  = my_address;
	
	
	
	/* This value is checked at the receiving end to see if this frame was	*/
	/* intended for this BSS ID.											*/
	pk_dhstruct_ptr->address3  = bss_id;
	
	
	/* Management frames never involve DS.							*/
	pk_dhstruct_ptr->fromds	 = 0;
	pk_dhstruct_ptr->tods    = 0;
	
	/* Start setting the packet fields.										*/
	op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_TYPE_FD, WlanC_StateReport, OPC_FIELD_SIZE_UNCHANGED);
	op_pk_fd_set_int32 (wlan_transmit_frame_ptr, WLANC_DATA_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
	
	/* Set the frame control field.											*/
	op_pk_fd_set_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, pk_dhstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,	
				      wlan_pk_dhstruct_copy, wlan_pk_dhstruct_destroy, sizeof (WlanT_Data_Header_Fields));

	/* The stateReport body is placed in the Packet container.					*/
	op_pk_fd_set_ptr (seg_pkptr, WLANC_STATEREPORT_BODY_FD, pk_srstruct_ptr, OPC_FIELD_SIZE_UNCHANGED,	
				      wlan_pk_srstruct_copy, wlan_pk_srstruct_destroy, sizeof (WlanT_StateReport_Body_Fields));

	/* The stateREport body "packet" is placed in the Frame Body field			*/
	op_pk_fd_set_pkt (wlan_transmit_frame_ptr, WLANC_DATA_BODY_FD, seg_pkptr, OPC_FIELD_SIZE_UNCHANGED);
	
	/* Place the transmission data rate and physical layer technology		*/
	/* information into the packet.											*/
	wlan_frame_tx_phy_info_set (wlan_transmit_frame_ptr, tx_data_rate, phy_type, phy_char_flag);
	
	/* Adjust the packet size if necessary to model the PLCP overhead		*/
	/* accurately, which is physical layer technology dependent. The		*/
	/* default value is set for infra-red technology.						*/
	if (phy_char_flag != WlanC_Infra_Red)
		{
		total_plcp_overhead = PLCP_OVERHEAD_CTRL_DR (((int) op_pk_total_size_get (wlan_transmit_frame_ptr) -  WLANC_DEFAULT_PLCP_OVERHEAD), tx_data_rate);
		bulk_size			= total_plcp_overhead * tx_data_rate - WLANC_DEFAULT_PLCP_OVERHEAD;
		op_pk_bulk_size_set (wlan_transmit_frame_ptr,(OpT_Packet_Size) bulk_size);
		}
	
	/* Printing out information to ODB.										*/
	if (wlan_trace_active == OPC_TRUE)
		{
		op_prg_odb_print_major ("StateReport is being transmitted to the Access Point %d from %d.", ap_mac_address, my_address);
		}
	
	/* Clear tx stateReport flag.												*/
	wlan_flags->tx_stateReport = OPC_FALSE;
	
	/* Remove the entry of this stateREport from its ACs queue.					*/
	stateReport_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [WlanC_AC_VO], OPC_LISTPOS_HEAD);
	
	/* Decrement the number of queued packets and update the related		*/
	/* statistics.															*/
	total_hlpk_num--;
	//op_stat_write (hl_packets_rcvd,                       (double) total_hlpk_num);
	//op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]));

	/* Update the medium access statistics.									*/
	mac_delay = current_time - stateReport_info_ptr->time_rcvd;
	//op_stat_write (media_access_delay,                         mac_delay);
	//op_stat_write (ac_access_delay_shndl_arr [WlanC_AC_VO],    mac_delay);
	//op_stat_write (global_mac_delay_handle,                    mac_delay);
	//op_stat_write (ac_gb_access_delay_shndl_arr [WlanC_AC_VO], mac_delay);

	/* Also update the management traffic sent statistics.					*/
	total_pk_size = (double) op_pk_total_size_get (wlan_transmit_frame_ptr);
	//op_stat_write (mgmt_traffic_sent_handle_inbits, total_pk_size);
	//op_stat_write (mgmt_traffic_sent_handle, 1.0);

	/* For accuracy, write a zero for end of transmission time.				*/
	tx_time     = total_pk_size / tx_data_rate;
	tx_end_time = current_time + tx_time;
	//op_stat_write_t (mgmt_traffic_sent_handle_inbits, 0.0, tx_end_time);
	//op_stat_write_t (mgmt_traffic_sent_handle, 0.0, tx_end_time);

	/* Destroy the information record.										*/
	op_prg_mem_free (stateReport_info_ptr);

	/* Check whether we can start the transmission of a new MSDU within the	*/
	/* current TXOP. Initially assume that this is not possible.			*/
	wlan_flags->txop_on = OPC_FALSE;
	if (txop_limit_arr [WlanC_AC_VO] != 0.0 && op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]) > 0)
		{
		/* Multiple MSDUs within a single TXOP are allowed and the AC has	*/
		/* at least one more higher layer packet to send. Compute the time	*/
		/* that will have left in the current TXOP duration when the		*/
		/* transmission of the beacon completes.							*/
		txop_time_left = txop_limit_arr [WlanC_AC_VO] - (current_time - txop_start_time) - tx_time;

		/* Remaining TXOP time won't be useful if it is less than SIFS.		*/
		if (txop_time_left >= sifs_time)
			{
			/* Access the header information of the packet.					*/
			op_pk_fd_access_ptr (wlan_transmit_frame_ptr, WLANC_DATA_HEADER_FD, (void **) &pk_dhstruct_ptr);
			
			/* Check whether we can fit another transmission into our		*/
			/* current TXOP. This function call will update the	duration	*/
			/* field of the frame when it realizes that another				*/
			/* transmission is possible within the TXOP.					*/
			wlan_flags->txop_on = wlan_hcf_next_txop_transmission_check (txop_time_left, &(pk_dhstruct_ptr->duration), 0);
			}
		}

	/* Reset the "response frame to send" variable, unless we are allowed	*/
	/* at least	one more transmission in our TXOP following the beacon		*/
	/* transmission.														*/
	if (wlan_flags->txop_on == OPC_FALSE)
		{
		fresp_to_send = WlanC_None;
		
		/* Set the related bit flag, since the "Voice AC" has to perform a	*/
		/* CW-backoff following its TXOP.									*/
		wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO];
		}
	else
		{
		/* We will continue with another transmission after our sending.	*/
		fresp_to_send = WlanC_QoS_Data;
		
		/* Reset the CW since we have a successful transmission	within the	*/
		/* TXOP.															*/
		cw_arr [WlanC_AC_VO] = cwmin_arr [WlanC_AC_VO];
		}
	
	
	
	{// mohammad
	
		WlanT_Mac_Frame_Type my_frame_type;
	
		op_pk_nfd_get_int32 (wlan_transmit_frame_ptr, "Type", (int *) &my_frame_type);
		if(my_frame_type == WlanC_StateReport)
			++sent_stateReport_count;

		op_stat_write_t (sent_stateReport_count_stat, sent_stateReport_count, op_sim_time ());
	}
	
	/* Send packet to the transmitter.										*/
	op_pk_send (wlan_transmit_frame_ptr, LOW_LAYER_OUTPUT_STREAM);	
	wlan_flags->transmitter_busy = OPC_TRUE;
	
	if(myDebugFlag)
		{
		sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
		MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
	
		fprintf(MyExcecutionTrace,"Time %f I sent a stateReport packet from %d to %d in bss %d\n",op_sim_time(),pk_dhstruct_ptr->address2,pk_dhstruct_ptr->address1,pk_dhstruct_ptr->address3);
		fclose(MyExcecutionTrace);
	
		
		}
	if(myStringDebug)
		{
		sprintf(myString,"I am %d:I sent a stateReport packet from %d to %d in bss %d",(int)my_address,(int)pk_dhstruct_ptr->address2,(int)pk_dhstruct_ptr->address1,(int)pk_dhstruct_ptr->address3);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	
	FOUT;
	}


static void
wlan_hcf_ba_control_frame_send (WlanT_HCF_Hld_Info* ba_cntl_info_ptr)
	{
	Packet*							ba_control_pkptr;
	WlanT_Control_Header_Fields*	pk_chstruct_ptr;
	WlanT_BA_Control_Fields*		ba_cntl_fields_ptr;
	WlanT_HCF_BA_State* 			peer_tid_ba_info_ptr;
	OpT_Packet_Size					pk_total_size;
	double							duration;
	double							tx_time, tx_end_time, txop_time_left;
	double							mac_delay;
	char							msg_string [128];
	
	/** This function finalizes the preparation of the control frame (block	**/
	/** ACK request or delayed block ACK) whose information record is		**/
	/** provided and sends it to the transmitter.							**/
	FIN (wlan_hcf_ba_control_frame_send (ba_cntl_info_ptr));
	
	/* Set the variable which keeps track of the last transmitted frame for	*/
	/* retransmission purposes, for which the BA control messages are		*/
	/* considered as QoS data messages, since they are buffered in the same	*/
	/* queue.																*/
	last_tx_frtype_arr [cur_tx_ac] = WlanC_QoS_Data;
	
	/* Is this first trial or a retransmission.								*/
	if (mpdu_retx_copy_arr [cur_tx_ac] != OPC_NIL)
		{
		/* In case of retransmission, just create a copy from the copy we	*/
		/* kept for retransmissions.										*/
		ba_control_pkptr = op_pk_copy (mpdu_retx_copy_arr [cur_tx_ac]);
		
		/* Are we retransmitting a BAR or a BA?								*/
		if (ba_cntl_info_ptr->type == WlanC_BAR)
			{
			/* Set the expected frame type for response and compute the		*/
			/* duration value that may be needed later in this function.	*/
			if (tc_config_arr [ba_cntl_info_ptr->up].ba_policy == WlanC_Immediate_BA)
				{
				duration = sifs_time + TXTIME_DATA (WLANC_BA_LENGTH);
				expected_frame_type = WlanC_BA;
				}
			else
				{
				duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
				expected_frame_type = WlanC_Ack;
				}
			}
		else
			{
			/* The expected response to our delayed block-ACK is an ACK.	*/
			expected_frame_type = WlanC_Ack;
			duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
			
			/* Get the latest status to report, which may have changed		*/
			/* since the previous transmission. Access the BA control		*/
			/* fields.														*/
			op_pk_fd_access_ptr (ba_control_pkptr, WLANC_CNTL_BA_FD, (void **) &ba_cntl_fields_ptr);

			/* Get the BA state information for the destination and	TID		*/
			/* of our BA message.											*/
			peer_tid_ba_info_ptr = ba_cntl_info_ptr->addr1_info_ptr->ba_state_ptr_arr [ba_cntl_info_ptr->up];
			
			/* Copy the current status information into the BA message.		*/
			op_prg_mem_copy (peer_tid_ba_info_ptr->status_bitmap, &(ba_cntl_fields_ptr->status_bitmap), WLANC_BA_STATUS_BITMAP_SIZE);
			
			/* Since we are sending our BA just now with an updated status	*/
			/* bitmap, check whether any more MSDU can be completed and		*/
			/* forwarded from reordering buffer.							*/
			if (peer_tid_ba_info_ptr->reordering_buffer_ptr != OPC_NIL)
				wlan_hcf_delayed_ba_complete_msdu_check (peer_tid_ba_info_ptr);
			}
	
		/* Get the total size of the retransmitted packet to be used in		*/
		/* statistic updates and computations below.						*/
		pk_total_size = op_pk_total_size_get (ba_control_pkptr);
		
		/* Write an ODB trace message if enabled.							*/
		if (wlan_trace_active)
			{				
			sprintf (msg_string, "Retransmitting %s to STA "OPC_INT64_FMT" for TID %d.\n", 
				(ba_cntl_info_ptr->type == WlanC_BAR) ? "Block ACK Request" : "delayed Block ACK", ba_cntl_info_ptr->dest_addr, ba_cntl_info_ptr->up);
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}
		}
	else
		{
		/* Create the control frame and its header fields.					*/
		ba_control_pkptr = op_pk_create_fmt ("wlan_control");
		pk_chstruct_ptr = wlan_pk_chstruct_create ();
		
		/* Set the source and destination address information.				*/
		pk_chstruct_ptr->rx_addr = ba_cntl_info_ptr->dest_addr;
		pk_chstruct_ptr->tx_addr = my_address;
		
		/* Get the BA state information for the given destination and TID.	*/
		peer_tid_ba_info_ptr = ba_cntl_info_ptr->addr1_info_ptr->ba_state_ptr_arr [ba_cntl_info_ptr->up];

		/* Perform type specific tasks.										*/
		if (ba_cntl_info_ptr->type == WlanC_BAR)
			{
			/* Create the frame field structure that will convey BA			*/
			/* specific information and set the TID information.			*/
			ba_cntl_fields_ptr = (WlanT_BA_Control_Fields *) op_prg_mem_alloc (sizeof (WlanT_BA_Control_Fields));
			ba_cntl_fields_ptr->tid = ba_cntl_info_ptr->up;
		
			/* Compute the duration based on the type of the response frame	*/
			/* and set the response frame information.						*/
			if (tc_config_arr [ba_cntl_info_ptr->up].ba_policy == WlanC_Immediate_BA)
				{
				duration = sifs_time + TXTIME_DATA (WLANC_BA_LENGTH);
				expected_frame_type = WlanC_BA;
				}
			else
				{
				duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
				expected_frame_type = WlanC_Ack;
				}
			pk_chstruct_ptr->duration = duration;
			
			/* Set the starting sequence control number of our block ACK	*/
			/* request.														*/
			ba_cntl_fields_ptr->starting_seq_num = peer_tid_ba_info_ptr->starting_seq_num;
			
			/* Reset the flag indicating pending BAR.						*/
			peer_tid_ba_info_ptr->bar_pending = OPC_FALSE;

			/* Store the current time which is when we start the			*/
			/* transmission trials of this BAR. If our trials keep failing	*/
			/* for "inactivity timeout", then we will terminate the			*/
			/* transmission of the BAR and also tear down the BA agreement	*/
			/* due to inactivity. If the previous BAR is discarded, don't	*/
			/* reset the start time, use the previous value; also cancel	*/
			/* the interrupt for the inactivity timer, since now we will	*/
			/* monitor inactivity using this "bar_tx_time" information,		*/
			/* until BAR is responded by the peer or discarded.				*/
			if (peer_tid_ba_info_ptr->bar_tx_time == 0.0)
				peer_tid_ba_info_ptr->bar_tx_time = current_time;
			else if (tc_config_arr [ba_cntl_info_ptr->up].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
				op_ev_cancel (peer_tid_ba_info_ptr->inactivity_evh);
			
			/* Print an ODB trace message if enabled.						*/
			if (wlan_trace_active)
				{				
				sprintf (msg_string, "Transmitting Block ACK Request to STA "OPC_INT64_FMT" for TID %d with starting seq num %d.\n", 
					ba_cntl_info_ptr->dest_addr, ba_cntl_info_ptr->up, peer_tid_ba_info_ptr->starting_seq_num);
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			}
		else
			{
			/* Retrieve the BA control information from peer-TID BA state	*/
			/* information record, which was stored from received BAR.		*/
			ba_cntl_fields_ptr = peer_tid_ba_info_ptr->block_ack_fields_ptr;
			
			/* Reset the block ACK contents kept in the BA state record.	*/
			peer_tid_ba_info_ptr->block_ack_fields_ptr = OPC_NIL;
		
			/* Update the MPDU status information that we will ship with	*/
			/* our delayed BA, which may have changed since we received the	*/
			/* BAR.															*/
			op_prg_mem_copy (peer_tid_ba_info_ptr->status_bitmap, &(ba_cntl_fields_ptr->status_bitmap), WLANC_BA_STATUS_BITMAP_SIZE);
			
			/* Since we are sending our BA just now with an updated status	*/
			/* bitmap, check whether any more MSDU can be completed and		*/
			/* forwarded from reordering buffer.							*/
			if (peer_tid_ba_info_ptr->reordering_buffer_ptr != OPC_NIL)
				wlan_hcf_delayed_ba_complete_msdu_check (peer_tid_ba_info_ptr);

			/* We expect an ACK as a response to our BA message.			*/
			expected_frame_type = WlanC_Ack;
			
			/* Compute and set the duration value that will be conveyed in	*/
			/* BA message.													*/
			duration = sifs_time + TXTIME_CTRL (WLANC_ACK_LENGTH);
			pk_chstruct_ptr->duration = duration;

			/* Print an ODB trace message if enabled.						*/
			if (wlan_trace_active)
				{				
				sprintf (msg_string, "Transmitting delayed Block ACK to STA "OPC_INT64_FMT" for TID %d with starting seq num %d.\n", 
					ba_cntl_info_ptr->dest_addr, ba_cntl_info_ptr->up, ba_cntl_fields_ptr->starting_seq_num);
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			}
		
		/* Set the packet fields.											*/
		op_pk_fd_set_int32 (ba_control_pkptr, WLANC_CNTL_TYPE_FD, ba_cntl_info_ptr->type, OPC_FIELD_SIZE_UNCHANGED);
		op_pk_fd_set_int32 (ba_control_pkptr, WLANC_CNTL_ACCEPT_FD, OPC_TRUE, OPC_FIELD_SIZE_UNCHANGED);
		op_pk_fd_set_ptr (ba_control_pkptr, WLANC_CNTL_HEADER_FD, pk_chstruct_ptr, OPC_FIELD_SIZE_UNCHANGED, 
				          wlan_pk_chstruct_copy, wlan_pk_chstruct_destroy, sizeof (WlanT_Control_Header_Fields));
		op_pk_fd_set_ptr (ba_control_pkptr, WLANC_CNTL_BA_FD, ba_cntl_fields_ptr, OPC_FIELD_SIZE_UNCHANGED, 
				          op_prg_mem_copy_create, op_prg_mem_free, sizeof (WlanT_BA_Control_Fields));

		/* Place the transmission data rate and physical layer technology	*/
		/* information into the packet.										*/
		wlan_frame_tx_phy_info_set (ba_control_pkptr, operational_speed, phy_type, phy_char_flag);
	
		/* Determine and set the total size of the packet with PLCP			*/
		/* overhead.														*/
		if (ba_cntl_info_ptr->type == WlanC_BAR)
			pk_total_size = (OpT_Packet_Size) (WLANC_BAR_LENGTH + PLCP_OVERHEAD_DATA (WLANC_BAR_LENGTH) * operational_speed);
		else
			pk_total_size = (OpT_Packet_Size) (WLANC_BA_LENGTH + PLCP_OVERHEAD_DATA (WLANC_BA_LENGTH) * operational_speed);
		op_pk_total_size_set (ba_control_pkptr, pk_total_size);

		/* Create a copy of the packet in case we need to retransmit.		*/
		mpdu_retx_copy_arr [cur_tx_ac] = op_pk_copy (ba_control_pkptr);
		
		/* Since this is the first transmission of this control frame,		*/
		/* update the medium access statistics.								*/
		mac_delay = current_time - ba_cntl_info_ptr->time_rcvd;
		op_stat_write (media_access_delay,                       mac_delay);
		op_stat_write (ac_access_delay_shndl_arr [cur_tx_ac],    mac_delay);
		op_stat_write (global_mac_delay_handle,                  mac_delay);
		op_stat_write (ac_gb_access_delay_shndl_arr [cur_tx_ac], mac_delay);
		}

	/* Update the control traffic sent statistics.							*/
	op_stat_write (ctrl_traffic_sent_handle_inbits, pk_total_size);
	op_stat_write (ctrl_traffic_sent_handle, 		1.0);
	
	/* Write a value of 0 for the end of transmission.						*/
	tx_time     = pk_total_size / operational_speed;
	tx_end_time = current_time + tx_time;
	op_stat_write_t (ctrl_traffic_sent_handle_inbits, 0.0, tx_end_time);
	op_stat_write_t (ctrl_traffic_sent_handle, 		  0.0, tx_end_time);
		
	/* Check whether we can start the transmission of next frame in the		*/
	/* transmission buffer of the AC within the current TXOP. Initially		*/
	/* assume that this is not possible.									*/
	wlan_flags->txop_on = OPC_FALSE;
	if (txop_limit_arr [cur_tx_ac] != 0.0 && op_prg_list_size (hlpk_lptr_arr [cur_tx_ac]) > 1 && AP_CONNECTED)
		{
		/* Multiple MSDUs within a single TXOP are allowed and the AC has	*/
		/* at least one more higher layer packet to send. Compute the time	*/
		/* that will have left in the current TXOP duration when the		*/
		/* current transmission completes with its response frame, if any.	*/
		/* Don't forget to account for signal extension if it will be used.	*/
		txop_time_left = txop_limit_arr [cur_tx_ac] - (current_time - txop_start_time) - duration -
						 ((phy_char_flag == WlanC_ERP_OFDM_11g && operational_speed > 5500000.0 && operational_speed != 11000000.0) ? 
						 tx_time + WLANC_11g_SIGNAL_EXTENSION : tx_time);

		/* Remaining TXOP time won't be useful if it is less than SIFS.		*/
		if (txop_time_left >= sifs_time)
			{
			/* Access the header information of the packet.					*/
			op_pk_fd_access_ptr (ba_control_pkptr, WLANC_CNTL_HEADER_FD, (void **) &pk_chstruct_ptr);
			
			/* Check whether we can fit another transmission into our		*/
			/* current TXOP. This function call will update the	duration	*/
			/* field of the frame when it realizes that another				*/
			/* transmission is possible within the TXOP.					*/
			wlan_flags->txop_on = wlan_hcf_next_txop_transmission_check (txop_time_left, &(pk_chstruct_ptr->duration), 1);
			}
		}

	/* Reset the "response frame to send" variable.							*/
	fresp_to_send = WlanC_None;

	/* Send packet to the transmitter.										*/
	op_pk_send (ba_control_pkptr, LOW_LAYER_OUTPUT_STREAM);	
	wlan_flags->transmitter_busy = OPC_TRUE;
	
	/* Set the flag if the current transmission requires signal extension.	*/
	if (phy_char_flag == WlanC_ERP_OFDM_11g && operational_speed > 5500000.0 && operational_speed != 11000000.0)
		wlan_flags->wait_signal_ext = OPC_TRUE;

	FOUT;
	}

static void
wlan_hcf_slot_time_set (double new_slot_time)
 	{
	int		ac_index;
	
	/** This function sets the slot time to the given value and recomputed	**/
	/** the values of the MAC parameters that depend on the value of the	**/
	/** slot time.															**/
	FIN (wlan_hcf_slot_time_set (new_slot_time));
	
	/* Update the slot time with the new value.								*/
	slot_time = new_slot_time;
	
	/* Recompute the inter-frame spacing values, which depend on slot time.	*/
	difs_time = sifs_time + 2 * slot_time;
	eifs_time = difs_time + sifs_time + TXTIME_CTRL_DR (WLANC_ACK_LENGTH, WLANC_11b_MIN_MANDATORY_DRATE);
	for (ac_index = 0; ac_index < WLANC_HCF_AC_COUNT; ac_index++)
		aifs_arr [ac_index] = sifs_time + (double) aifsn_arr [ac_index] * slot_time; 
	
	FOUT;
	}

static WlanT_HCF_Access_Category 
wlan_hcf_interrupts_process (void)
	{
	List*						voice_ac_hlpk_lptr;
	OpT_Int64*					sta_addr_ptr;
	int							i;
	OpT_Int64					sta_mac_addr;
	Boolean						beacon_scheduled, ignore_interrupt, stateReport_scheduled;
	WlanT_HCF_Peer_Info*		peer_info_ptr;
	void*						dummy_ptr;
	WlanT_HCF_Hld_Info*			hld_ptr;
	WlanT_HCF_BA_State*			ba_info_ptr;
	WlanT_HCF_Access_Category	new_ac, temp_ac;
	WlanT_HCF_Access_Category	ret_value = WlanC_AC_None;
	char						msg_string1 [256];
	char						msg_string2 [256];
	int							integer_sta_mac_addr;
	
	/** This routine handles the appropriate processing need for each type 	**/
	/** of remote interrupt. The type of interrupts are: stream interrupts	**/
	/** (from lower and higher layers), stat interrupts (from receiver and 	**/
	/** transmitter). In case of higher layer packet arrivals, the function	**/
	/** returns the access category that will process the higher layer		**/
	/** packet, if the packet is queued successfully. If the higher layer	**/
	/** packet is dropped, all for other type of interrupts, it returns		**/
	/** WlanC_AC_None.														**/
	FIN (wlan_hcf_interrupts_process (void));
	
	/*Loren: here for following program flow
	printf("got to interrupts process beginning.\n");
	*/
	
	/* Check if debugging is enabled.										*/
	wlan_trace_active = (debug_mode && op_prg_odb_ltrace_active ("wlan"));

	/* Determine the current simulation time.								*/	
	current_time = op_sim_time ();
	
	/* Determine interrupt type and code to divide treatment along the		*/
	/* lines of interrupt type.						  						*/
	intrpt_type = op_intrpt_type ();
	//Loren
	//printf("interrupt type = %d\n", (int)intrpt_type);
	
	intrpt_code = (WlanT_Mac_Intrpt_Code) op_intrpt_code ();
	//Loren
	//printf("interrupt code = %d\n", (int)intrpt_code);
	
	/* Stream interrupts are either arrivals from the higher layer, or		*/
	/* from the physical layer.												*/
	if (intrpt_type == OPC_INTRPT_STRM)
		{
		//Loren
		if(myStringDebug)
		{
			printf("I am %d: stream interrupt type.\n", (int)my_address);
		}
		/* Determine the stream on which the arrival occurred.				*/
		i_strm = op_intrpt_strm ();
	

		/* If the event arrived from higher layer then queue the packet	and	*/
		/* the destination address.											*/
		if (i_strm == instrm_from_mac_if)
			{
			//Loren
			/* Process stream interrupt received from higher layer.			*/
			ret_value = wlan_hcf_higher_layer_data_arrival ();
			//printf("ret_value = %s\n", ret_value);
			}

		/* If the event was an arrival from the physical layer, accept the	*/
		/* packet and decapsulate it.								 		*/
		else 
			{	
			/* Check the receiver's status and update the related flag if	*/
			/* necessary. The statwire interrupt from the receiver before	*/
			/* the arrival of the physical layer packet won't reset this	*/
			/* flag when signal extension is used in 11g networks.			*/
			
			//Loren
			//printf("I am %d: took i_strm not equal.\n", (int)my_address);
			if (wlan_flags->receiver_busy == OPC_TRUE && rx_state_info_ptr->rx_end_time - PRECISION_RECOVERY <= current_time)
				{
				wlan_flags->receiver_busy = OPC_FALSE;
				}

			/* Process stream interrupt received from physical layer.		*/
			/*Loren*/
			//printf("I am %d: calling physical layer data arrival\n", (int)my_address);
			
			wlan_hcf_physical_layer_data_arrival (); 			
  			}
	 	}	
	/* Handle stat interrupt received from the receiver.					*/
	else if (intrpt_type == OPC_INTRPT_STAT)
		{
		//Loren
		if(myStringDebug)
		{
			printf("I am %d: stat interrupt type from receiver.\n", (int)my_address);
		}
		/* Make sure it is not a stat interrupt from the transmitter.		*/
		if (intrpt_code < TRANSMITTER_BUSY_INSTAT)
			{
			/* One of receiver channels is changing its status. Update the	*/
			/* channel status flag.											*/
			wlan_hcf_mac_rcv_channel_status_update (intrpt_code);
			}
		else
			{
			/* Reset bad_packet_dropped flag upon a stat interrupt from the	*/
			/* transmitter.													*/
			wlan_flags->bad_packet_dropped = OPC_FALSE;
			}
		}
	
	/* Check whether it is time to send a beacon. Unless beacon simulation	*/
	/* efficiency is enabled, AP MACs will be sending periodic beacons.		*/
	/* When efficiency is enabled, then the AP may be requested to send a	*/
	/* beacon message to report a change in the BSS	configuration or		*/
	/* condition (like association of an non-ERP STA with a ERP-capable		*/
	/* BSS) with remote interrupts.											*/
	else if ((intrpt_type == OPC_INTRPT_SELF || intrpt_type == OPC_INTRPT_REMOTE) && intrpt_code == WlanC_Beacon_Tx_Time) //(mohammad) we add code to handle interrepts for sending status report. the code should be similar to the beacon handling code. 
		{
		
		//Loren
		if(myStringDebug)
		{
			printf("I am %d: time to send beacon interrupt.\n", (int)my_address);
		}
			/*
		
			//this code is to calculate statistics at the AP about accuracy and distortion
			if(calculationMethod == PERIODIC && current_time - last_DataRate_reset_time_PERIODIC > calculationPeriod )
				{
				
				int i;
				OpT_Int64 i_address;
				WlanT_HCF_Peer_Info* peer_info_ptr;
				double	dataRateSum = 0, accuracySum =0, distortionSum=0,weighted_sum = 0;
				
				nodes_no = prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1; //nodes_no is defined in th header file which should be readable from all nodes.
				
				for(i= 0; i < nodes_no+1;i++)
					{
										
					if(i==0)
						continue;
					
					i_address = (OpT_Int64)i;
					peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &i_address);
					
					
					peerStreamDataRate[(int)i] =  peerStreamData[(int)i]/(current_time-last_DataRate_reset_time_PERIODIC);
				
					
					if(strcmp(curve,"accu_quality_cmumit_withNI")==0)//!accu_woe_flag)
						{//for curve accuracy error = 1-detectionIndex + false detection index
						peerStreamAccuracy[(int)i] = (1.266E-7 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-2.529)+0.2362);
						peerStreamAccuracyError[(int)i] = peerStreamAccuracy[(int)i];
						if(peerStreamAccuracy[(int)i] <0 || peerStreamAccuracy[(int)i] > 1)
							trimmedAccuracyCounter[i]++;
						
						peerStreamAccuracy[(int)i] = 1 - (peerStreamAccuracy[(int)i] > 1 ? 1 : peerStreamAccuracy[(int)i]);
					
						peerStreamDistortion[(int)i] = 6.778 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-0.2555) + -10.63;
						}
					else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
						{
						//for curve accuracy error = 1-detectionIndex
						peerStreamAccuracy[(int)i] = (2.899E-7 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-2.455)+0.11);
						peerStreamAccuracyError[(int)i] = peerStreamAccuracy[(int)i];
						if(peerStreamAccuracy[(int)i] <0 || peerStreamAccuracy[(int)i] > 1)
							trimmedAccuracyCounter[i]++;
						peerStreamAccuracy[(int)i] = 1 - (peerStreamAccuracy[(int)i] > 1 ? 1 : peerStreamAccuracy[(int)i]);
					
						peerStreamDistortion[(int)i] = 6.778 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-0.2555) + -10.63;
						}
					else if(strcmp(curve,"accu_quality_frontal")==0)
						{
					
						peerStreamAccuracy[(int)i] = (4.346E-16 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-8.104)+0.1797);
						peerStreamAccuracyError[(int)i] = peerStreamAccuracy[(int)i];
						if(peerStreamAccuracy[(int)i] <0 || peerStreamAccuracy[(int)i] > 1)
							trimmedAccuracyCounter[i]++;
						peerStreamAccuracy[(int)i] = 1 - (peerStreamAccuracy[(int)i] > 1 ? 1 : peerStreamAccuracy[(int)i]);
					
					
						peerStreamDistortion[(int)i] = 8.417E-7 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-3.937) + 0;
						}
					else if(strcmp(curve,"accu_resolution_frontal")==0)
						{
					
						peerStreamAccuracy[(int)i] = (5.079E-008 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-2.28)+0.2446);
						peerStreamAccuracyError[(int)i] = peerStreamAccuracy[(int)i];
						if(peerStreamAccuracy[(int)i] <0 || peerStreamAccuracy[(int)i] > 1)
							trimmedAccuracyCounter[i]++;
						peerStreamAccuracy[(int)i] = 1 - (peerStreamAccuracy[(int)i] > 1 ? 1 : peerStreamAccuracy[(int)i]);
					
					
						peerStreamDistortion[(int)i] = 0.1403 * pow(peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0,-0.6785) + 0;
						}
				
					else if(strcmp(curve,"matlabOptimization_accu_resolution_cmumit")==0)//hoon
						{
					
						//0.9405 .*W .* exp(-233.5 .*(x.* Y)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y)./T)
					
						peerStreamAccuracy[(int)i] = 0.9405 * exp(-233.5 *peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0) + 0.2563 * exp(-1.354 *peerStreamDataRate[(int)i]/8.0/20.0/1024.0/1024.0);
						peerStreamAccuracyError[(int)i] = peerStreamAccuracy[(int)i];
						if(peerStreamAccuracy[(int)i] <0 || peerStreamAccuracy[(int)i] > 1)
							trimmedAccuracyCounter[i]++;
					
						//peerStreamAccuracy[(int)i] = (5.079E-008 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-2.28)+0.2446);
						peerStreamAccuracy[(int)i] = 1 - (peerStreamAccuracy[(int)i] > 1 ? 1 : peerStreamAccuracy[(int)i]);
						}
					
					
					
				
					//	peerStreamDistortion[(int)i] =6.778 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-0.2555) + -10.63;
					if(peerStreamDistortion[(int)i]<0)
						peerStreamDistortion[(int)i] = 0;
				
					if (peerStreamDataRate[(int)i] == 0)
						{
						peerStreamAccuracyError[i]= 25;
						peerStreamDistortion[(int)i] = 25;
						}
						
						
					
					
					
					accuracyCalculationCounter[i]++;
					
					if(myStringDebug)
						{
						sprintf(myString,"I am  %d:Data Rate of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamDataRate[i]);
						op_prg_odb_print_major(myString,OPC_NIL);
					
					
						sprintf(myString,"I am  %d:Accuracy of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamAccuracy[i]);
						op_prg_odb_print_major(myString,OPC_NIL);
					
						sprintf(myString,"I am  %d:Distortion of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamDistortion[i]);
						op_prg_odb_print_major(myString,OPC_NIL);
						}
					
					if(myDataFileGenerationFlag == 1)
							{
						
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							//fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f\n",
							fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f,totalData=%f,trimmedCounter=%d,totalCounter=%d,accuracyError=%f\n",
							(double)op_sim_time(),(int)i,(double)peerStreamDataRate[(int)i],(double)peerStreamAccuracy[(int)i],(double)peerStreamDistortion[(int)i],(double)totalPeerStreamData[(int)i],trimmedAccuracyCounter[(int)i],accuracyCalculationCounter[(int)i],peerStreamAccuracyError[(int)i]);
							fclose(MyExcecutionTrace);
							}
					
					dataRateSum += peerStreamDataRate[i];
					accuracySum +=peerStreamAccuracy[i];
					
					weighted_sum += peerStreamAccuracy[i]*peer_info_ptr -> peer_importance;
					
					distortionSum +=peerStreamDistortion[i];
					
					peerStreamData[i] = 0;
					peerStreamDataRate[i] = 0;
					peerStreamAccuracy[i] = 0;
					peerStreamDistortion[i] = 0;
					peerStreamAccuracyError[(int)i] = 0;
					}
							
				
				if(myStringDebug)
					{
					sprintf(myString,"I am  %d:weighted Accuracy sum is %f",(int)my_address,(double)weighted_sum);
					op_prg_odb_print_major(myString,OPC_NIL);
			
					sprintf(myString,"I am  %d:Average Data Rate of the stream recievedis %f",(int)my_address,(double)dataRateSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
					op_prg_odb_print_major(myString,OPC_NIL);
					
					//op_sim_end ("mesh rade yetba3", "", "", "");
			
					sprintf(myString,"I am  %d:Average Accuracy of the stream recieved is %f",(int)my_address,(double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
					op_prg_odb_print_major(myString,OPC_NIL);
				
					sprintf(myString,"I am  %d:Average Distortion of the stream recieved is %f",(int)my_address,(double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
					op_prg_odb_print_major(myString,OPC_NIL);
					}
				
				if(myDataFileGenerationFlag == 1)
					{
					
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					fprintf(MyExcecutionTrace,"AVERAGE At Time %f:AverageDaraRate=%f,AverageAccuracy=%f,AverageDistortion=%f,WeightedAccuracy=%f\n",
						(double)op_sim_time(),(double)dataRateSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1)/(double) (current_time-last_DataRate_reset_time_PERIODIC),(double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1),(double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1),(double)weighted_sum);
					fclose(MyExcecutionTrace);
					}
			
				op_stat_write (average_accuracy, (double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				op_stat_write (average_distortion, (double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				op_stat_write (weighted_accuracy_sum, (double)weighted_sum);
				op_stat_write (average_stream_DataRate, (double)dataRateSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				
				last_DataRate_reset_time_PERIODIC = current_time;
				dataRateSum = 0;
				accuracySum =0;
				distortionSum =0;
				weighted_sum = 0;
			
				}
		*/
			
		
		
		
		
		/* If this is a requested beacon transmission rather than periodic,	*/
		/* set the number of beacons transmissions to be performed.			*/
		beacon_scheduled = OPC_FALSE;
		ignore_interrupt = OPC_FALSE;
		if (intrpt_type == OPC_INTRPT_REMOTE)
			{
			rem_beacon_tx = beacon_tx_count;
			
			/* Decrement the count if a beacon is already queued.			*/
			if (wlan_flags->tx_beacon == OPC_TRUE)
				rem_beacon_tx--;
			
			/* Don't schedule a new interrupt if one is already scheduled.	*/
			else if (beacon_tx_time > current_time)
				{
				beacon_scheduled = OPC_TRUE;
				ignore_interrupt = OPC_TRUE;
				}
			
			/* Or don't send a beacon at this time if it hasn't been "a		*/
			/* beacon interval" since the last beacon.						*/
			else if (current_time - beacon_tx_time < beacon_int)
				ignore_interrupt = OPC_TRUE;
			
			/* Otherwise we will send a beacon now. Update the beacon		*/
			/* transmission time.											*/
			else 
				beacon_tx_time = current_time;
			}				
		
		/* It is time to send a beacon. We will perform the transmission at	*/
		/* the first opportunity. Create an entry for the beacon frame in	*/
		/* the "voice" access category, which should have the highest		*/
		/* priority. We will create the actual packet when we will be		*/
		/* sending the beacon. We will insert the entry to the head of the	*/
		/* queue of the voice access category, unless the transmission		*/
		/* process of the packet that is currently at the head has already	*/
		/* started. In that case, the entry of the beacon will be next to	*/
		/* the head in the queue. One exception: Don't queue another beacon	*/
		/* if we couldn't send the previous one, yet, or there is already a	*/
		/* scheduled one, which is possible when beacon efficiency is on.	*/

		if (wlan_flags->tx_beacon == OPC_FALSE && ignore_interrupt == OPC_FALSE)
			{
			/* Allocate memory for the queue entry.							*/	
			hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);
		
			/* Generate error message and abort simulation if no memory		*/
			/* left for data received from higher layer.					*/
			if (hld_ptr == OPC_NIL)
				wlan_error_print ("No more memory left to assign for data received from higher layer", OPC_NIL, OPC_NIL);
		
			/* Set the frame type to beacon and destination address to		*/
			/* broadcast, and initialize the fields that need to be set.	*/
			hld_ptr->type           = WlanC_Beac;
			hld_ptr->dest_addr      = MAC_BROADCAST_ADDR;
			hld_ptr->time_rcvd		= current_time;
			hld_ptr->pkptr          = OPC_NIL;
			hld_ptr->addr1_info_ptr = PRGC_NIL;
		
			/* Insert the entry into the queue for the access category		*/
			/* "voice".	"First check whether it is empty.					*/
			voice_ac_hlpk_lptr = hlpk_lptr_arr [WlanC_AC_VO];
			if (op_prg_list_size (voice_ac_hlpk_lptr) == 0)
				{
				/* Insert the entry into the queue.							*/
				op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, OPC_LISTPOS_HEAD);
			
				/* Also update the queue status array if necessary.			*/
				if(!(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]))
					{
					/* Insert voice to the top of the list of contending	*/
					/* ACs. Make sure that the list remains sorted.			*/
					for (i = 0, new_ac = WlanC_AC_VO; ac_queue_status_arr [i] != WlanC_AC_None; i++)
						{
						temp_ac = new_ac;
						new_ac = ac_queue_status_arr [i];						
						ac_queue_status_arr [i] = temp_ac;
						}
					ac_queue_status_arr [i] = new_ac;
					}
				}
			else
				{
				/* The queue of the AC is not empty. Check the status of	*/
				/* the packet that is at the head of the queue and insert	*/
				/* the beacon entry into the queue accordingly.				*/
				op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, wlan_hcf_ac_queue_transmission_status_check (voice_ac_hlpk_lptr, WlanC_AC_VO));
				}
		
			/* Increment the number of queued packets and update the		*/
			/* related statistics.											*/
			total_hlpk_num++;
			op_stat_write (hl_packets_rcvd,                       (double) total_hlpk_num);
			op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) op_prg_list_size (voice_ac_hlpk_lptr));
			
			/* This is equivalent of receiving a higher layer packet for	*/
			/* the "voice" AC.												*/
			ret_value = WlanC_AC_VO;
		
			/* Set the related flag to indicate we have a beacon to send.	*/
			wlan_flags->tx_beacon = OPC_TRUE;
			
			/* If we are sending certain number of beacons, rather than		*/
			/* periodically for whole simulation, then decrement the number	*/
			/* of needed beacon transmissions.								*/
			if (BEACON_TX_EFFICIENCY_ENABLED)
				rem_beacon_tx--;
			}
		
		/* Set timer for next beacon transmission if we are sending			*/
		/* periodic beacons, or if we have more beacons to send even if the	*/
		/* beacon efficiency mode is enabled. Important: the check must be	*/
		/* "!= 0" rather than "> 0" because rem_beacon_tx will be "-1" when	*/
		/* sending periodic beacons.										*/		
		if (rem_beacon_tx != 0 && beacon_scheduled == OPC_FALSE)
			{
			beacon_tx_time += beacon_int;
			op_intrpt_schedule_self (beacon_tx_time, WlanC_Beacon_Tx_Time);
			}
		}
	/* (mohammad) Check whether it is time to change operational speed. 											*/
	else if ((intrpt_type == OPC_INTRPT_SELF ) && intrpt_code == WlanC_OperationalSpeed_Change) //(mohammad) we add code to handle interrepts for changing the operational speed 
		{
				//Loren
			if(myStringDebug)
			{
				printf("I am %d: changing operational speed interrupt.\n", (int)my_address);
			}
		operational_speed = myDataRates[dataRatePeriodCounter];
		dataRatePeriodCounter++;
		
		
		
		}
	/*
	else if ((intrpt_type == OPC_INTRPT_SELF ) && intrpt_code ==WlanC_matlabOptimization)// hoon i will do tha matlab optimization
		{
		if(ap_flag == OPC_BOOLINT_DISABLED)
			{
				double	f, ceiling;
			
	
				if(myStringDebug)
					{
				
				sprintf(myString,"I am  %d:I am updating my information  ",(int)my_address,(int)my_address,(int)ap_mac_address, importance);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
				
				
			//if(strcmp(bnadwidth_allocation_method,"accu_onlylink_D")!=0 && strcmp(bnadwidth_allocation_method,"accu_link_D")!=0 && strcmp(bnadwidth_allocation_method,"accu_link")!=0)
		
				//pk_srstruct_ptr->pk_importance = importance;
			W[(int)my_address] =importance; 
			
			//else
			//	pk_srstruct_ptr->pk_importance = 1.0/nodes_no;
			
				
			//pk_srstruct_ptr->pk_averageProtocolOverhead = (double)total_data_header_size_sent / data_packet_sent_count;
			//last_sent_protocolOverheadRate = pk_srstruct_ptr->pk_averageProtocolOverhead;
	
			if(myStringDebug)
				{
				sprintf(myString,"I am  %d:importance of %d is being sent to AP(%d) via stateReport and it is %f",(int)my_address,(int)my_address,(int)ap_mac_address, importance);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
					
	
			/*if(strcmp(bnadwidth_allocation_method,"accu_app")==0||strcmp(bnadwidth_allocation_method,"wdis_app")==0||strcmp(bnadwidth_allocation_method,"dist_app")==0
				||strcmp(bnadwidth_allocation_method,"accu_app_H")==0||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0||strcmp(bnadwidth_allocation_method,"dist_app_H")==0
				||strcmp(bnadwidth_allocation_method,"accu_app_D")==0||strcmp(bnadwidth_allocation_method,"wdis_app_D")==0||strcmp(bnadwidth_allocation_method,"dist_app_D")==0
				||strcmp(bnadwidth_allocation_method,"accu_onlyApp_D")==0
				)
				{
				pk_srstruct_ptr->pk_physicalRate = max_operational_speed;
				op_stat_write (max_operational_speed_stat, max_operational_speed);
				}
	
			else if(strcmp(bnadwidth_allocation_method,"app_only")==0)
				pk_srstruct_ptr->pk_physicalRate = 54000000;
			else
				pk_srstruct_ptr->pk_physicalRate = operational_speed;
				//pk_srstruct_ptr->pk_physicalRate = temp_ph_rate/(double)data_frames_sent_in_the_last_stateREport_int_count;//this should be the effective data rate.
			
			TXOP[(int)my_address] = txop_limit_arr [WlanC_AC_VI];	

			last_sent_physicalRate = operational_speed;
			last_sent_droppedBRate = my_droppedB_sum/(op_sim_time()-last_my_droppedB_calculated_time);
			last_sent_droppedRRate = my_droppedR_sum/(op_sim_time()-last_my_droppedR_calculated_time);
			last_sent_loadRate = my_load_sum/(op_sim_time()-last_my_load_calculated_time);
			last_sent_sentRate = my_sent_sum/(op_sim_time()-last_my_sent_calculated_time);	
	
	
			last_my_droppedB_calculated_time = op_sim_time();
			my_droppedB_sum = 0;
			last_my_droppedR_calculated_time = op_sim_time();
			my_droppedR_sum = 0;
			last_my_load_calculated_time = op_sim_time();
			my_load_sum = 0;
			last_my_sent_calculated_time = op_sim_time();
			my_sent_sum = 0;
	
			last_calculated_droppedB_prob = (double)data_packet_droppedB_in_the_last_stateReport_int_count/data_packet_loaded_in_the_last_stateReport_int_count;
			data_packet_droppedB_in_the_last_stateReport_int_count = 0;
			data_packet_loaded_in_the_last_stateReport_int_count = 0;
	
	
			D[(int)my_address] = (last_sent_droppedBRate+last_sent_droppedRRate)/1024.0/1024.0/8.0;
			Y[(int)my_address] = last_sent_physicalRate/1024.0/1024.0/8.0;
			W[(int)my_address] = importance;
			T[(int)my_address] = frameRate;
			
			op_stat_write (my_droppedB_stat, last_sent_droppedBRate);
			op_stat_write (my_droppedR_stat, last_sent_droppedRRate);
			op_stat_write (my_load_stat, last_sent_loadRate);
			op_stat_write (my_sent_stat, last_sent_sentRate);
			
			op_stat_write (physicalRate_stat, last_sent_physicalRate);
			
			
			
			op_stat_write (importance_stat, importance);	
			op_stat_write (frameRate_stat, frameRate);
			
			op_stat_write(data_frames_sent_in_the_last_stateREport_int_count_stat,data_frames_sent_in_the_last_stateREport_int_count);
	
	
			temp_ph_rate = 0;
			data_frames_sent_in_the_last_stateREport_int_count = 0;
			
			
			//make the changes to make the optimization take effect
			
				f = fees[(int)my_address];	
				op_stat_write (fee_stat, (double) f);
					
					
					
				Ls = (double)total_data_size_sent_without_headers/data_packet_sent_count;
			
				Os = (double)total_data_header_size_sent / data_packet_sent_count;
			
			
			
				total_data_size_sent_without_headers = 0;
				data_packet_sent_count = 0;
				total_data_header_size_sent = 0;
					
				//if(strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0)
				//	ceiling = ceil((double)f * last_sent_physicalRate * (double)beacon_int/Ls);
				//else
				ceiling = ceil((double)f * last_sent_physicalRate * (float)TXOPinterval/Ls);
					
			
				//for now i will change TXOP of the video catigory only
				//if(strcmp(bnadwidth_allocation_method,"dist")==0 || strcmp(bnadwidth_allocation_method,"wdis")==0 || strcmp(bnadwidth_allocation_method,"accu")==0
				//	||strcmp(bnadwidth_allocation_method,"wdis_link")==0|| strcmp(bnadwidth_allocation_method,"dist_link")==0|| strcmp(bnadwidth_allocation_method,"accu_link")==0
					
					
				//	||strcmp(bnadwidth_allocation_method,"dist_H")==0 || strcmp(bnadwidth_allocation_method,"wdis_H")==0|| strcmp(bnadwidth_allocation_method,"accu_H")==0
				//	||strcmp(bnadwidth_allocation_method,"wdis_link_H")==0|| strcmp(bnadwidth_allocation_method,"dist_link_H")==0|| strcmp(bnadwidth_allocation_method,"accu_link_H")==0
		
				//	||strcmp(bnadwidth_allocation_method,"accu_D")==0 ||strcmp(bnadwidth_allocation_method,"dist_D")==0||strcmp(bnadwidth_allocation_method,"wdis_D")==0
				//	||strcmp(bnadwidth_allocation_method,"accu_link_D")==0 || strcmp(bnadwidth_allocation_method,"accu_app_D")==0
				//	|| strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
				//	|| strcmp(bnadwidth_allocation_method,"accu_onlylink_D")==0
				//	)
			
					txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
			
			
				//else if(strcmp(bnadwidth_allocation_method,"wdis_app")==0|| strcmp(bnadwidth_allocation_method,"dist_app")==0|| strcmp(bnadwidth_allocation_method,"accu_app")==0
					
					
				//	||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0|| strcmp(bnadwidth_allocation_method,"dist_app_H")==0|| strcmp(bnadwidth_allocation_method,"accu_app_H")==0)
			
				//	txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				
				//else if(strcmp(bnadwidth_allocation_method,"link_only")==0)
				//	txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				//else if(strcmp(bnadwidth_allocation_method,"accu_D2")==0 || strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0)
				//	{
				//	txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				//	txop_limit_arr [WlanC_AC_VI] += last_calculated_droppedB_prob * txop_limit_arr [WlanC_AC_VI];
				//	}////
				///*else if (strcmp(bnadwidth_allocation_method,"accu")==0)
				//	{
				//	txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				//	txop_limit_arr [WlanC_AC_VI] += last_calculated_droppedB_prob * txop_limit_arr [WlanC_AC_VI];
				//	}
					
			
				////txop_limit_arr [WlanC_AC_VI] = 0.7;
				op_stat_write (video_TXOP_stat,(double)txop_limit_arr [WlanC_AC_VI]);
				
				
				
							
				//if(strcmp(bnadwidth_allocation_method,"dist")==0 || strcmp(bnadwidth_allocation_method,"wdis")==0|| strcmp(bnadwidth_allocation_method,"accu")==0
				//	||strcmp(bnadwidth_allocation_method,"wdis_app")==0|| strcmp(bnadwidth_allocation_method,"dist_app")==0|| strcmp(bnadwidth_allocation_method,"accu_app")==0 ||strcmp(bnadwidth_allocation_method,"accu_link")==0
				//	
				//	||strcmp(bnadwidth_allocation_method,"dist_H")==0 || strcmp(bnadwidth_allocation_method,"wdis_H")==0|| strcmp(bnadwidth_allocation_method,"accu_H")==0
				//	||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0|| strcmp(bnadwidth_allocation_method,"dist_app_H")==0|| strcmp(bnadwidth_allocation_method,"accu_app_H")==0
				//	
				//||strcmp(bnadwidth_allocation_method,"accu_D")==0 ||strcmp(bnadwidth_allocation_method,"dist_D")==0||strcmp(bnadwidth_allocation_method,"wdis_D")==0
				//	||strcmp(bnadwidth_allocation_method,"app_only")==0 
				//	
				//	||strcmp(bnadwidth_allocation_method,"accu_link_D")==0 || strcmp(bnadwidth_allocation_method,"accu_app_D")==0
				//	||strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
				//	|| strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"accu_D2")==0|| strcmp(bnadwidth_allocation_method,"accu_onlyApp_D")==0 
				//	
				//	)
				////if (strcmp(bnadwidth_allocation_method,"EDCA")!=0)
				//	{
				//	if(pruning_flag == 1)
				//		{
				//		if(strcmp(bnadwidth_allocation_method,"accu_D")!=0)
				//			{
				//			tempFrameSize = (double) f * last_sent_physicalRate/8.0/1024.0/1024.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT);
				//			
				//			tempAccuracy = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
				//		
				//			//sprintf(myString,"I am  %d:frame size before reduction is calculated as %f, accuracy is %f",(int)my_address,(double)tempFrameSize,tempAccuracy);
			//
			//				//op_prg_odb_print_major(myString,OPC_NIL);
			//			
			//			
			//				
			//				tempFrameSize = exp(log(((tempAccuracy + pruning_percent/100.0*tempAccuracy)-accuracyConstant_c)/accuracyConstant_a)/accuracyConstant_b);
			//			
			//				
			//			
			//				tempAccuracy = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
			//				}
			//			else
			//				{
			//				if(f * last_sent_physicalRate - (last_sent_droppedBRate + last_sent_droppedRRate) <=0)
			//					op_sim_end ("f * last_sent_physicalRate - last_sent_droppedBRate is less than 0", "", "", "");
			//				
			//				tempFrameSize = (double)( f * last_sent_physicalRate - (last_sent_droppedBRate+last_sent_droppedRRate))/8.0/1024.0/1024.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT);
			//				tempAccuracy = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
			//			
			//				//sprintf(myString,"I am  %d:frame size before reduction is calculated as %f, accuracy is %f",(int)my_address,(double)tempFrameSize,tempAccuracy);
			//
			//				//op_prg_odb_print_major(myString,OPC_NIL);
						
						
			//				if((tempAccuracy + pruning_percent/100.0*tempAccuracy)-accuracyConstant_c <=0)
			//					op_sim_end ("(tempAccuracy + pruning_percent/100.0*tempAccuracy)-accuracyConstant_c is less than 0", "", "", "");
			//				
			//				tempFrameSize = exp(log(((tempAccuracy + pruning_percent/100.0*tempAccuracy)-accuracyConstant_c)/accuracyConstant_a)/accuracyConstant_b);
			//			
							
			//			
			//				tempAccuracy = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
			//				}
			//				
			//			
			//			//sprintf(myString,"I am  %d:frame size after reduction is calculated as %f, accuracy is %f",(int)my_address,(double)tempFrameSize,tempAccuracy);
			//
			//			//op_prg_odb_print_major(myString,OPC_NIL);
			//			
			//			//sprintf(myString,"I am  %d:application rate (bit per second) is %f",(int)my_address,(double) f * last_sent_physicalRate);
			//
			//			//op_prg_odb_print_major(myString,OPC_NIL);
			//			
			//			appRateBits = (double) tempFrameSize*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*8*1024*1024;
			//			
			//			}
			//		else if(pruning_flag == 0)
			//			{
			//			//sprintf(myString,"I am  %d:sending application rate (bit per second is %f",(int)my_address,(double) f * last_sent_physicalRate);
			//
			//			//op_prg_odb_print_major(myString,OPC_NIL);
			//			//if((double) f * last_sent_physicalRate > last_sent_droppedBRate)
							appRateBits = (double) f * last_sent_physicalRate;//-last_sent_droppedBRate;
			//			//else
			//			//	appRateBits = 500000;
			//				
//
//						}
//					//if(strcmp(bnadwidth_allocation_method,"accu_D")==0 && appRateBits - last_sent_droppedBRate > 0)
//					//	appRateBits = appRateBits - last_sent_droppedBRate;
					op_stat_write (mac_appRate_stat, appRateBits);
//					}
				
				
						
				if(myDataFileGenerationFlag == 1)
					{
					
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					//fprintf(MyExcecutionTrace,"I am %d at Time %f:Importance=%f,a=%20.20f,b=%f,c=%f,FR=%f,PR=%f,LAMBDA=%10.10f,fee=%f,AR=%f,TXOP=%f,LS=%f,OS=%f,SIFS=%f,BI=%f,ta=%f,load=%f,droppedB=%f,droppedR=%f,sent=%f\n",hoon
					fprintf(MyExcecutionTrace,"%d\t%f\t%f\t%20.20f\t%f\t%f\t%f\t%f\t%10.10f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%d\t%f\t%f\n",
						(int)my_address,(double)op_sim_time(),importance,accuracyConstant_a , accuracyConstant_b , accuracyConstant_c,(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),last_sent_physicalRate,current_lambda,f,appRateBits,(double)txop_limit_arr [WlanC_AC_VI],Ls,Os,(double)sifs_time,(double)beacon_int,(double)TXTIME_CTRL (WLANC_ACK_LENGTH),(double)last_sent_loadRate,(double)last_sent_droppedBRate,(double)last_sent_droppedRRate,(double)last_sent_sentRate,last_calculated_average_TXOP_displasement,bits_sent_in_the_last_TXOP, TXOP_counter,appRateBits/8.0/20.0,(double)op_stat_local_read(4));
					fclose(MyExcecutionTrace);
					}
				
			
	
			
			}//end of if(!ap_flag)
		else if(ap_flag == OPC_BOOLINT_ENABLED)
			{
			int i;
			char temp[20];
			double EA;
			double sumTXOP=0;
			mxArray * results = 0;
			char opCommand[] = "[x,fval] = fmincon(@myobjfun,x0,[],[],[],[],[],[],@myconfun,options)";
			
			sprintf(Wline, "W = [");
			sprintf(Yline, "Y = [");
			sprintf(Dline, "D = [");
			sprintf(Tline, "T = [");
			sprintf(x0Command,"x0=[");
			
			myobjfun = fopen("C:/matlabOptimization/myobjfun.m","w");
			fprintf(myobjfun, "function f = myobjfun(x)\n");
			fprintf(myobjfun, "%%current time = %f, curve = %s, method = %s\n",(float) op_sim_time(), curve,bnadwidth_allocation_method);
						
			for(i = 1; i <= nodes_no;i++)
				{
				sprintf(temp,"%f ",W[i]);
				strcat(Wline, temp);
				sprintf(temp,"%f ",Y[i]);
				strcat(Yline, temp);
				sprintf(temp,"%f ",D[i]);
				strcat(Dline, temp);
				sprintf(temp,"%f ",T[i]);
				strcat(Tline, temp);
				
				sprintf(temp,"%f ",0.60/nodes_no);
				strcat(x0Command, temp);
				sumTXOP += TXOP[i];
				}
			
			strcat(Wline, "];\n");
			strcat(Yline, "];\n");
			strcat(Dline, "];\n");
			strcat(Tline, "];\n");
			strcat(x0Command, "];");
			
			
			fprintf(myobjfun,Wline);
			fprintf(myobjfun,Yline);
			fprintf(myobjfun,Dline);
			fprintf(myobjfun,Tline);
			
			if( strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD")==0)
				fprintf(myobjfun,"f = sum(0.9405 .*W .* exp(-233.5 .*(x.* Y+D)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y + D)./T));\n");
			else if(strcmp(curve,"matlabOptimization_accu_resolution_cmumit")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0)
				fprintf(myobjfun,"f = sum(0.9405 .*W .* exp(-233.5 .*(x.* Y)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y)./T));\n");
			else if(strcmp(curve,"accu_quality_cmumit_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0)
				fprintf(myobjfun,"f = sum(9.623E-9 .*W .* ((x.* Y)./T).^-2.86 + W .* 0.2071);\n");
			else if(strcmp(curve,"accu_quality_cmumit_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")==0)
				fprintf(myobjfun,"f = sum(17.93 .* ((x.* Y)./T).^-0.143 + -23.72);\n");
			else if(strcmp(curve,"accu_quality_cmumit_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")==0)
				fprintf(myobjfun,"f = sum(17.93 .*W .* ((x.* Y)./T).^-0.143 + W .* -23.72);\n");
			
			
			else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0)
				fprintf(myobjfun,"f = sum(2.158E-8 .*W .* ((x.* Y)./T).^-1.807 + W .* 0.04894);\n");
			else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")==0)
				fprintf(myobjfun,"f = sum(6.783 .* ((x.* Y)./T).^-0.1983 + -23.1);\n");
			else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")==0)
				fprintf(myobjfun,"f = sum(6.783 .*W .* ((x.* Y)./T).^-0.1983 + W .* -23.1);\n");
			
			
			else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0)
				fprintf(myobjfun,"f = sum(9.399e-13 .*W .* ((x.* Y)./T).^-2.997 + W .* 0.005403);\n");
			else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")==0)
				fprintf(myobjfun,"f = sum(0.3801 .* ((x.* Y)./T).^-0.1966 + -1.142);\n");
			else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")==0)
				fprintf(myobjfun,"f = sum(0.3801 .*W .* ((x.* Y)./T).^-0.1966 + W .* -1.142);\n");
			
			//constants need editting
			else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0)
				fprintf(myobjfun,"f = sum(9.399e-13 .*W .* ((x.* Y)./T).^-2.997 + W .* 0.005403);\n");
			else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")==0)
				fprintf(myobjfun,"f = sum(0.3801 .* ((x.* Y)./T).^-0.1966 + -1.142);\n");
			else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0&&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")==0)
				fprintf(myobjfun,"f = sum(0.3801 .*W .* ((x.* Y)./T).^-0.1966 + W .* -1.142);\n");
			
			
			fclose(myobjfun);
			
			
			//EA = 1.0/(( 1 + (2.0*nodes_no/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(cwmin_arr [WlanC_AC_VI]/(cwmin_arr [WlanC_AC_VI]+2.0),nodes_no-1)));//EA using per catigory CWmin
			EA = 1.0/(( 1 + (2.0*nodes_no/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(cwmin_arr [WlanC_AC_VI]/(cwmin_arr [WlanC_AC_VI]+2.0),nodes_no-1)));//EA using per catigory CWmin and without TXOP
			//EA = 0.6*EA;
			
			if(myStringDebug)
				{
			sprintf(myString,"I am  %d:EA is calculated as %f",(int)my_address,(float)EA);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			myconfun = fopen("C:/matlabOptimization/myconfun.m","w");
			fprintf(myconfun, "function [c, ceq] = myconfun(x)\n");
			fprintf(myconfun, "%%current time = %f, curve = %s, method = %s\n",(float) op_sim_time(), curve,bnadwidth_allocation_method);
			fprintf(myconfun, "EA = %f;\n", EA);
			fprintf(myconfun, "c = [x-1, -x + 0.0001];\n");
			fprintf(myconfun, "ceq = [sum(x) - EA] ;\n");

			fclose(myconfun);
			
			if(myStringDebug)
				{
			
			sprintf(myString,"I am  %d:start to do optimization",(int)my_address,TXOPinterval);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			buffer[BUFFERSIZE] = '\0';
			
			if(myStringDebug)
				{
			
			sprintf(myString,"I am  %d:connecting output buffer to natlab engin",(int)my_address,TXOPinterval);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
			engOutputBuffer(ep, buffer, BUFFERSIZE);
			
			if(myStringDebug)
				{
			sprintf(myString,"I am  %d:exceuting cd command",(int)my_address,TXOPinterval);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
				
			engEvalString(ep, "cd('C:/matlabOptimization')");
			
			engEvalString(ep, "clear all;");
			
			if(myStringDebug)
				{
			sprintf(myString,"I am  %d:exceuting xoCommand = %s",(int)my_address,x0Command);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
				
			engEvalString(ep, x0Command);
			
			engEvalString(ep, "options = optimset('Algorithm','interior-point');");
			//engEvalString(ep, "options.MaxFunEvals = 250000");
						
			if(myStringDebug)
				{
			sprintf(myString,"I am  %d:result of options = %s",(int)my_address,buffer);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			
			
			while (results == NULL) 
				{
				
				if(myStringDebug)
					{
							
				sprintf(myString,"I am  %d:exceuting opCommand = %s",(int)my_address,opCommand);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
				
				engEvalString(ep, opCommand);
				
				if(myStringDebug)
					{
				sprintf(myString,"I am  %d:result of opCommand = %s",(int)my_address,buffer);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
				
				if ((results = engGetVariable(ep,"x")) == NULL)
					printf("Oops! You didn't create a variable X.\n\n");
				}
			
			
			
			sprintf(myString,"I am  %d:fees = ",(int)my_address);
			for(i = 1; i <= nodes_no;i++)
				{
				fees[i] = mxGetPr(results)[i-1];
				sprintf(temp,"%f ", fees[i]);
				strcat(myString,temp);
						
				}
				op_prg_odb_print_major(myString,OPC_NIL);
				
			
			
			mxDestroyArray(results);
				
			
			
			}
		
		
		
		
		

		op_intrpt_schedule_self (current_time+stateReport_int, WlanC_matlabOptimization);
		
		}//end of else if ((intrpt_type == OPC_INTRPT_SELF ) && intrpt_code ==WlanC_matlabOptimization)
		
	*/
	/* (mohammad) Check whether it is time to send a StateReport. 											*/
	else if ((intrpt_type == OPC_INTRPT_SELF || intrpt_type == OPC_INTRPT_REMOTE) && intrpt_code == WlanC_StateReport_Tx_Time) //(mohammad) we add code to handle interrepts for sending status report. the code should be similar to the beacon handling code. 
		{
		if(myStringDebug)
		{
		
		sprintf(myString,"I am  %d:I am trying to send state report",(int)my_address);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
		
		
		/* If this is a requested StateReport transmission rather than periodic,	*/
		stateReport_scheduled = OPC_FALSE;
		ignore_interrupt = OPC_FALSE;
		if (intrpt_type == OPC_INTRPT_REMOTE)
			{
			
			//rem_beacon_tx = beacon_tx_count;//(not needed in case of state report.)
			
			/* (not needed in case of state report.) Decrement the count if a beacon is already queued.			*/
			//if (wlan_flags->tx_beacon == OPC_TRUE)
			//	rem_beacon_tx--;
			
			/* Don't schedule a new interrupt if one is already scheduled.	*/
			if (stateReport_tx_time > current_time)//(mohammad) check this
				{
				stateReport_scheduled = OPC_TRUE;
				ignore_interrupt = OPC_TRUE;
				}
			
			/* (not needed in case of state report.) Or don't send a beacon at this time if it hasn't been "a		*/
			/* beacon interval" since the last beacon.						*/
			//else if (current_time - beacon_tx_time < beacon_int)
				//ignore_interrupt = OPC_TRUE;
			
			/* Otherwise we will send a state report now. Update the state report		*/
			/* transmission time.											*/
			else 
				stateReport_tx_time = current_time;
			}				
		
		/* It is time to send a state report. We will perform the transmission at	*/
		/* the first opportunity. Create an entry for the state report frame in	*/
		/* the "voice" access category, which should have the highest		*/
		/* priority. We will create the actual packet when we will be		*/
		/* sending the state report. We will insert the entry to the head of the	*/
		/* queue of the voice access category, unless the transmission		*/
		/* process of the packet that is currently at the head has already	*/
		/* started. In that case, the entry of the state report will be next to	*/
		/* the head in the queue. One exception: Don't queue another state report	*/
		/* if we couldn't send the previous one, yet. 	*/
		if (wlan_flags->tx_stateReport == OPC_FALSE && ignore_interrupt == OPC_FALSE)
			{
			/* Allocate memory for the queue entry.							*/	
			hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);
		
			/* Generate error message and abort simulation if no memory		*/
			/* left for data received from higher layer.					*/
			if (hld_ptr == OPC_NIL)
				wlan_error_print ("No more memory left to assign for state report", OPC_NIL, OPC_NIL);
		
			/* Set the frame type to state report and destination address to		*/
			/* bss, and initialize the fields that need to be set.	*/
			hld_ptr->type           = WlanC_StateReport;
			hld_ptr->orig_addr		= my_address;
			hld_ptr->dest_addr      = ap_mac_address;//MAC_BROADCAST_ADDR;
			hld_ptr->time_rcvd		= current_time;
			hld_ptr->pkptr          = OPC_NIL;
			hld_ptr->addr1_info_ptr = PRGC_NIL;
		
			/* Insert the entry into the queue for the access category		*/
			/* "voice".	"First check whether it is empty.					*/
			voice_ac_hlpk_lptr = hlpk_lptr_arr [WlanC_AC_VO];
			if (op_prg_list_size (voice_ac_hlpk_lptr) == 0)
				{
				/* Insert the entry into the queue.							*/
				op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, OPC_LISTPOS_HEAD);
			
				/* Also update the queue status array if necessary.			*/
				if(!(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]))
					{
					/* Insert voice to the top of the list of contending	*/
					/* ACs. Make sure that the list remains sorted.			*/
					for (i = 0, new_ac = WlanC_AC_VO; ac_queue_status_arr [i] != WlanC_AC_None; i++)
						{
						temp_ac = new_ac;
						new_ac = ac_queue_status_arr [i];						
						ac_queue_status_arr [i] = temp_ac;
						}
					ac_queue_status_arr [i] = new_ac;
					}
				}
			else
				{
				/* The queue of the AC is not empty. Check the status of	*/
				/* the packet that is at the head of the queue and insert	*/
				/* the state report entry into the queue accordingly.				*/
				op_prg_list_insert (voice_ac_hlpk_lptr, hld_ptr, wlan_hcf_ac_queue_transmission_status_check (voice_ac_hlpk_lptr, WlanC_AC_VO));
				}
		
			/* Increment the number of queued packets and update the		*/
			/* related statistics.											*/
			total_hlpk_num++;
			op_stat_write (hl_packets_rcvd,                       (double) total_hlpk_num);
			
					
			
			//op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) op_prg_list_size (voice_ac_hlpk_lptr));
			
			
			
			/* This is equivalent of receiving a higher layer packet for	*/
			/* the "voice" AC.												*/
			ret_value = WlanC_AC_VO;
		
			/* Set the related flag to indicate we have a beacon to send.	*/
			wlan_flags->tx_stateReport = OPC_TRUE;
			
			/* (not needed) If we are sending certain number of beacons, rather than		*/
			/* periodically for whole simulation, then decrement the number	*/
			/* of needed beacon transmissions.								*/
			//if (BEACON_TX_EFFICIENCY_ENABLED)
				//rem_beacon_tx--;
			}
		
		/* Set timer for next stateReport transmission 	*/		
		//if (rem_beacon_tx != 0 && beacon_scheduled == OPC_FALSE)
			//{
			stateReport_tx_time += stateReport_int;
			op_intrpt_schedule_self (stateReport_tx_time, WlanC_StateReport_Tx_Time);
			//}
			if(myStringDebug)
				{
			
				sprintf(myString,"I am  %d:stae interrupt set successfully",(int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
			
		}//(mohamamd) end of my code to handle the state reportinterupt.
	else if (intrpt_type == OPC_INTRPT_PROCESS)
		{
		/* This is an interrupt scheduled by a roaming STA to report its	*/
		/* association or deassociation. Find out the address of the STA.	*/
		//Loren
		if(myStringDebug)
		{
			printf("I am %d: interrupt scheduled by roaming STA.\n", (int)my_address);
		}
		
		integer_sta_mac_addr = intrpt_code >> WLANC_ADDRESS_BIT_SHIFT;
		sta_mac_addr = integer_sta_mac_addr;
		
		/* Is it an association or disassociation?							*/
		if (intrpt_code & WLANC_ASSOCIATION_BIT)
			{
			/* Create an information record for this STA joining our BSS	*/
			/* and initialize the last received frame sequence ID			*/
			/* information, which will be used for duplicate detection.		*/
			peer_info_ptr = (WlanT_HCF_Peer_Info *) op_prg_mem_alloc (sizeof (WlanT_HCF_Peer_Info));
			peer_info_ptr->seq_cntl = 0xFFFF;
			
			/* Store its QoS capability information. Increment the number	*/
			/* of nQSTAs in the BSS, if necessary.							*/
			if (intrpt_code & WLANC_QOS_SUPPORT_BIT)
				{
				peer_info_ptr->is_qsta = OPC_TRUE;
				
				/* Create the arrays that will store the sequence control	*/
				/* numbers and counters for this QSTA for each TID.			*/
				peer_info_ptr->tid_seq_counter_arr   = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
				peer_info_ptr->tid_rcvd_seq_cntl_arr = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
				for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
					{
					peer_info_ptr->tid_seq_counter_arr [i]   = 0;
					peer_info_ptr->tid_rcvd_seq_cntl_arr [i] = 0xFFFF;
					}
				
				/* Also check whether it supports block ACKs.				*/
				if (wlan_flags->ba_support == OPC_TRUE && (intrpt_code & WLANC_BA_SUPPORT_BIT))
					peer_info_ptr->is_qsta = OPC_TRUE;
				else
					peer_info_ptr->is_qsta = OPC_FALSE;
				}
			else
				{
				peer_info_ptr->is_qsta = OPC_FALSE;
				my_bss_info_ptr->nqsta_count++;
				}
	
			/* Reset the block ACK state information with the peer.			*/
			peer_info_ptr->ba_state_ptr_arr = OPC_NIL;
			
			/* Similarly store the ERP capability (11g support) information.*/
			peer_info_ptr->is_erp = (intrpt_code & WLANC_ERP_SUPPORT_BIT) ? OPC_TRUE : OPC_FALSE;
			
			/* Insert the record into our local binary Hash table for quick	*/
			/* access.														*/
			prg_bin_hash_table_item_insert (peer_info_hash_tbl, (void *) &sta_mac_addr, peer_info_ptr, &dummy_ptr);
			}
		
		else
			{
			/* The STA is leaving our BSS. Destroy our records related to	*/
			/* that STA and, if any, remove	the packets in transmission		*/
			/* queues destined for that STA. Do this now unless we are		*/
			/* contending for or in the middle of a	TXOP. Otherwise do it	*/
			/* when the current/next TXOP is over.							*/
			if (ac_queue_status_arr [0] == WlanC_AC_None ||
				(fresp_to_send == WlanC_None && expected_frame_type == WlanC_None && wlan_flags->transmitter_busy == OPC_FALSE && !MEDIUM_IS_IDLE))
				wlan_hcf_sta_disassociation_process (sta_mac_addr);
			else
				{
				sta_addr_ptr = (OpT_Int64 *) op_prg_mem_alloc (sizeof (OpT_Int64));
				*sta_addr_ptr = sta_mac_addr;
				op_prg_list_insert (disassociating_sta_lptr, sta_addr_ptr, OPC_LISTPOS_TAIL);
				}					
			}
		}

	else if (intrpt_type == OPC_INTRPT_SELF)
		{
				//Loren
		if(myStringDebug)
		{
			printf("I am  %d:self interrupt",(int)my_address);
		}
		
		if (intrpt_code == WlanC_NAV_Reset_Time)
			{
			/* Due to inactivity in the medium we are allowed to reset our	*/
			/* NAV. Set the variable nav_duration to a value so that the	*/
			/* backoff for the next transmission, if any, can begin			*/
			/* immediately.													*/
			if (ac_queue_status_arr [0] != WlanC_AC_None)
				{
				/* Note: it is still OK even if nav_duration is set to a	*/
				/* value smaller than rcv_idle_time, since in that case		*/
				/* medium_idle_time starts with rcv_idle_time, not with		*/
				/* nav_duration.											*/
				nav_duration = current_time - sifs_time - aifsn_arr [ac_queue_status_arr [0]] * slot_time;
				}
			else			
				nav_duration = rcv_idle_time;
			}
	
		else if (intrpt_code == WlanC_BA_Inactive_Tout_Rcpt || intrpt_code == WlanC_BA_Inactive_Tout_Init)
			{
			/* This is an interrupt indicating the expiry of the inactivity	*/
			/* timer for one of our BA agreements. Information about the	*/
			/* corresponding BA agreements is stored under event state.		*/
			/* Tear down the agreement and remove any related BA frames		*/
			/* from the transmission queues.								*/
			wlan_hcf_ba_inactivity_timeout_handle ((WlanT_HCF_BA_State *) op_ev_state (op_ev_current ()), intrpt_code);
			}
	
		else if (intrpt_code == WlanC_ADDBA_Failure_Timeout)
			{
			/* We didn't receive the ADDBA response frame for one of our	*/
			/* ADDBA request transmissions although the peer had			*/
			/* acknowledged its reception of our request. Get the			*/
			/* corresponding BA information record from event state.		*/
			ba_info_ptr = (WlanT_HCF_BA_State *) op_ev_state (op_ev_current ());
			
			/* Increment the ADDBA request failure counter. If we reach the	*/
			/* retry limit, don't send another ADDBA request. Otherwise,	*/
			/* send a new ADDBA request when we receive a new higher layer	*/
			/* data for this peer/TID.										*/
			if (++ba_info_ptr->addba_failure_count < ADDBA_FAILURE_RETRY_LIMIT)
				ba_info_ptr->status = WlanC_BA_Uninitiated;
			else
				ba_info_ptr->status = WlanC_BA_Failure;			

			/* Write an ODB message if enabled.								*/
			if (wlan_trace_active)
				{
				sprintf (msg_string1, "Waiting timer expired for the ADDBA response expected from STA "OPC_INT64_FMT" for TID %d.", ba_info_ptr->peer_addr, ba_info_ptr->tid);
				sprintf (msg_string2, "Incrementing ADDBA retry count to %d (limit = %d).", ba_info_ptr->addba_failure_count, ADDBA_FAILURE_RETRY_LIMIT); 
				op_prg_odb_print_major (msg_string1, msg_string2, OPC_NIL);
				}
			}
		}
	if (roam_state_ptr->scan_type == WlanC_Scan_Type_Distance && current_time >= ap_connectivity_check_time)		
		{
		/* In the "virtual" scanning mode, we check if the distance of this	*/
		/* STA is greater than "start scanning" threshold. If so, we go to	*/
		/* the scan mode, and look for a new AP. 							*/
		ap_connectivity_check_time = current_time + ap_connectivity_check_interval;
		wlan_ap_eval_virtual (my_node_objid, roam_state_ptr, conn_ap_pos_info_ptr, channel_num, phy_type, rx_power_threshold);
		}
	FRET (ret_value);
	}

static void
wlan_hcf_sta_disassociation_process (OpT_Int64 sta_addr)
	{
	WlanT_HCF_Peer_Info*		peer_info_ptr;
	WlanT_HCF_Hld_Info*			hld_ptr;
	List*						ac_lptr;
	int							ac_list_size;
	int							i, j, k;
	
	/** This function is called only by the APs when an STA disassociates	**/
	/** from their BSSs. It removes the packets destined to that STA from	**/
	/** AC transmission queues, flushes state information of any BA			**/
	/** agreement with that STA, and finally destroys the information 		**/
	/** record kept for that STA											**/	
	FIN (wlan_hcf_sta_disassociation_process (sta_addr));
	
	/* Remove the STA's record from our Hash table since it is leaving.		*/
	peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_remove (peer_info_hash_tbl, (void *) &sta_addr);
	
	/* Was the STA a QSTA?													*/
	if (peer_info_ptr->is_qsta == OPC_TRUE)
		{
		/* Free the memory allocated for sequence control counter and		*/
		/* number maintenance for this STA for each TID.					*/
		op_prg_mem_free (peer_info_ptr->tid_seq_counter_arr);
		op_prg_mem_free (peer_info_ptr->tid_rcvd_seq_cntl_arr);
	
		/* If any, flush block ACK state information with that STA.			*/
		if (peer_info_ptr->ba_state_ptr_arr != OPC_NIL)
			{
			for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
				{
				if (peer_info_ptr->ba_state_ptr_arr [i] != OPC_NIL)
					{
					/* We had a block-ACK agreement(s) with the STA. Flush	*/
					/* all the BA related information with this STA for the	*/
					/* current TC.											*/
					wlan_hcf_peer_tid_ba_info_flush (peer_info_ptr->ba_state_ptr_arr [i], Wlanc_BA_Bidirectional);
					}
				}
			
			/* Now free STA's block-ACK state information record.			*/
			op_prg_mem_free (peer_info_ptr->ba_state_ptr_arr);
			}
		}
	else
		/* Decrement the number of nQSTAs in our BSS.						*/
		my_bss_info_ptr->nqsta_count--;
	
	/* Scan through all the packets in the AC transmission queues and		*/
	/* remove any packets that are destined to this disassociating STA.		*/
	for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None;)
		{
		ac_lptr      = hlpk_lptr_arr [ac_queue_status_arr [i]];
		ac_list_size = op_prg_list_size (ac_lptr);
		for (j = 0; j < ac_list_size;)
			{
			/* Access the information record of the packet.					*/
			hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_lptr, j);
			
			/* Check its destination.										*/
			if (hld_ptr->dest_addr == sta_addr)
				{
				/* Destined to the leaving STA. Remove from the queue.		*/
				wlan_hcf_frame_remove (ac_queue_status_arr [i], j);
				ac_list_size--;
				}
			else
				/* Move to the next packet.									*/
				j++;
			}
		
		/* If the queue is empty and there is no CW-backoff scheduled for	*/
		/* it then update queue status array accordingly.					*/
		if (j == 0 && !(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [ac_queue_status_arr [i]]))
			{
			/* Remove the current AC from the list of ACs with non-empty	*/
			/* queues.														*/
			ac_queue_status_arr [i] = ac_queue_status_arr [i + 1];
			for (k = i + 1; ac_queue_status_arr [k] != WlanC_AC_None; k++)
				ac_queue_status_arr [k] = ac_queue_status_arr [k + 1];
			}
		else
			/* Otherwise move to the next AC.								*/
			i++;
		}
	
	/* Finally, free the memory allocated for STA's record.					*/
	op_prg_mem_free (peer_info_ptr);
	
	FOUT;
	}

static void
wlan_hcf_peer_tid_ba_info_flush (WlanT_HCF_BA_State* peer_tid_ba_info_ptr, WlanT_HCF_BA_Direction direction)
	{
	WlanT_BA_Buffered_MSDU*		current_msdu_ptr;
	WlanT_BA_Buffered_MPDU*		temp_mpdu_ptr;
	Packet*						msdu_pkptr;
	WlanT_HCF_Access_Category	ac;
	int							ac_queue_size;
	int							i;
	char						msg_string [256];
	
	/** This function destroys any block-ACK related record and buffer		**/
	/** created and maintained for the given destination and TID for both	**/
	/** directions (i.e., as originator and as recipient) and frees the		**/
	/** memory allocated for the corresponding data structures. Using		**/
	/** direction argument, the flush operation can be restricted with only	**/
	/** one direction.														**/
	FIN (wlan_hcf_peer_tid_ba_info_flush (peer_tid_ba_info_ptr, direction));
	
	/* Is there a block-ACK agreement initiated by this MAC?				*/
	if (peer_tid_ba_info_ptr->status == WlanC_BA_Established && direction != WlanC_BA_Recipient)
		{
		/* If any, destroy the MPDUs in the retransmission buffer with		*/
		/* their records.													*/
		for (i = peer_tid_ba_info_ptr->mpdu_count - 1; i >= 0; i--)
			{
			/* Decrease the buffer usage by higher layer data.				*/
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size before decrement #2 = %d\n",(int)total_hlpk_size);
			}
			total_hlpk_size -= peer_tid_ba_info_ptr->retx_arr [i]->size;
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size after decrement #2 = %d\n", (int)total_hlpk_size);
			}
			
			/* Destroy the MPDU packet and its information record.			*/
			op_pk_destroy (peer_tid_ba_info_ptr->retx_arr [i]->pkptr);
			op_prg_mem_free (peer_tid_ba_info_ptr->retx_arr [i]);
			}
		
		/* Destroy the retransmission buffer.								*/
		op_prg_mem_free (peer_tid_ba_info_ptr->retx_arr);

		/* If this is done due to roaming rather than inactivity, cancel	*/
		/* the inactivity timeout interrupt.								*/
		if (direction == Wlanc_BA_Bidirectional && tc_config_arr [peer_tid_ba_info_ptr->tid].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT &&
			op_ev_valid (peer_tid_ba_info_ptr->inactivity_evh))
			op_ev_cancel (peer_tid_ba_info_ptr->inactivity_evh);
		}
	
	/* Also, is there an agreement initiated by the peer STA?				*/
	if (peer_tid_ba_info_ptr->peer_block_size > 0 && direction != WlanC_BA_Initiator)
		{
		/* Free the status bitmap.											*/
		op_prg_mem_free (peer_tid_ba_info_ptr->status_bitmap);
		
		/* If any, free the control information we kept for the next BA.	*/
		if (peer_tid_ba_info_ptr->block_ack_fields_ptr != OPC_NIL)
			op_prg_mem_free (peer_tid_ba_info_ptr->block_ack_fields_ptr);
		
		/* Destroy the reordering buffer. If it contains any MSDUs that are	*/
		/* completely received, then reassemble those MSDUs and forward		*/
		/* them to the higher layer. Also note the queue size of the AC		*/
		/* before we make any possible additions.							*/
		ac = WLANC_UP_TO_AC_MAPPING_ARRAY [peer_tid_ba_info_ptr->tid];
		ac_queue_size = op_prg_list_size (hlpk_lptr_arr [ac]);
		while (peer_tid_ba_info_ptr->reordering_buffer_ptr != OPC_NIL)
			{
			/* Is the current MSDU complete? Recall that some complete		*/
			/* MSDUs may have their MPDUs already reassembled and forwarded.*/
			current_msdu_ptr = peer_tid_ba_info_ptr->reordering_buffer_ptr;
			if (current_msdu_ptr->complete == OPC_TRUE && current_msdu_ptr->mpdu_lptr != OPC_NIL)
				{
				/* Reassemble the MSDU.										*/
				msdu_pkptr = wlan_hcf_buffered_ba_msdu_reassemble (current_msdu_ptr);
				
				/* Process the reassembled MSDU: forward to the higher		*/
				/* layer or enqueue it to transmit to its final destination	*/
				/* in the BSS.*/
				
				/*Loren
				sprintf(myString,"I am %d, calling frame forward function 1.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
				*/
				
				wlan_hcf_completed_frame_forward (msdu_pkptr, peer_tid_ba_info_ptr->peer_addr, my_address, current_msdu_ptr->final_dest_addr, 
												  current_msdu_ptr->hl_protocol, current_msdu_ptr->pkt_id, peer_tid_ba_info_ptr->tid);
				}
			else if (current_msdu_ptr->complete == OPC_FALSE)
				{
				/* Print an ODB trace message if enabled.					*/
				if (wlan_trace_active)
					{				
					sprintf (msg_string, "Destroying the MPDUs of the incomplete MSDU in reordering buffer with seq # = %d.", current_msdu_ptr->sequence_number);
					op_prg_odb_print_major (msg_string, OPC_NIL);
				}
				
				/* Destroy the buffered MPDUs of the MSDU, if any, which	*/
				/* can't be completed.										*/
				while (current_msdu_ptr->mpdu_lptr != OPC_NIL)
					{
					temp_mpdu_ptr = current_msdu_ptr->mpdu_lptr;
					current_msdu_ptr->mpdu_lptr = temp_mpdu_ptr->next_mpdu_ptr;
					op_pk_destroy (temp_mpdu_ptr->mpdu_data_pkptr);
					op_prg_mem_free (temp_mpdu_ptr);
					}
				}
			
			/* Destroy the MSDU record since we are done with this MSDU.	*/
			peer_tid_ba_info_ptr->reordering_buffer_ptr = current_msdu_ptr->next_msdu_ptr;
			op_prg_mem_free (current_msdu_ptr);
			}
		
		/* Update the statistic that indicates the total size of active		*/
		/* reordering buffers.												*/
		total_ba_reorder_buf_size -= (peer_tid_ba_info_ptr->peer_block_size * WLANC_MAXMSDU_LENGTH / 8);
		op_stat_write (total_reorder_size_handle, total_ba_reorder_buf_size);

		/* If this is done due to roaming rather than inactivity, cancel	*/
		/* the inactivity timeout interrupt.								*/
		if (direction == Wlanc_BA_Bidirectional && peer_tid_ba_info_ptr->peer_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
			op_ev_cancel (peer_tid_ba_info_ptr->peer_inactivity_evh);
		
		/* If the TID's AC's queue was empty before and we reassembled some	*/
		/* MSDUs from the reordering buffer and placed them into the AC's	*/
		/* queue (this can happen only in QAPs) for transmission and if we	*/
		/* are currently in "IFS and BACKOFF" state then also add this AC	*/
		/* to the contention.												*/
		if (ac_queue_size == 0 && op_prg_list_size (hlpk_lptr_arr [ac]) > 0 && backoff_ac != WlanC_AC_None && 
			op_ev_valid (deference_info_arr [backoff_ac].deference_end_evh))
			wlan_hcf_new_ac_to_contention_add (ac);		
		}
					
	/* Free the TID's block-ACK state information record, if there was no	*/
	/* direction restriction.												*/
	if (direction == Wlanc_BA_Bidirectional)
		op_prg_mem_free (peer_tid_ba_info_ptr);
	
	FOUT;
	}

static void 
wlan_hcf_physical_layer_data_arrival (void)
	{
	char								msg_string [128];
	int									accept;
	OpT_Int64							dest_addr, remote_sta_addr;//,i_address;
	OpT_uInt8							tid;
	OpT_uInt16							prev_seq_num;
	OpT_Packet_Id						data_pkt_id;
	const WlanT_Data_Header_Fields*		pk_dhstruct_ptr;
	const WlanT_Control_Header_Fields*	pk_chstruct_ptr;
	const WlanT_QoS_Control_Fields*		qos_info_ptr;
	WlanT_HCF_Peer_Info*				src_sta_info_ptr;
	WlanT_HCF_Hld_Info*					hld_info_ptr;
	WlanT_HCF_BA_State*					ba_state_info_ptr;
	WlanT_Mac_Frame_Type				rcvd_frame_type;
	WlanT_Phy_Char_Code					rcvd_frame_phy_char;
	WlanT_HCF_Ack_Policy				ack_policy;
	Packet*								wlan_rcvd_frame_ptr;	
	Packet*								seg_pkptr;
	const WlanT_Beacon_Body_Fields*		pk_bbstruct_ptr;
	const WlanT_StateReport_Body_Fields*		pk_srstruct_ptr;
	int									rcvd_sta_bssid;
	int									i;
	Boolean								disable_signal_extension = OPC_FALSE;
	double								rcvd_pk_size, rx_start_time;
	double								total_retries;
	double dFOPT, DFR, AFOPT, AFR;
	
	
	
	WlanT_HCF_Peer_Info*				peer_info_ptr;//(mohammad) this is to store hash table entry tempororlly to change it and store it back in the table
	void*								dummy_ptr;
	
	//double								dataRateSum = 0, accuracySum =0, distortionSum=0,weighted_sum = 0;
	double 								f, ceiling;
	
	/** Process the frame received from the lower layer. This	**/
	/** routine decapsulate the frame and set appropriate flags	**/
	/** if the station needs to generate a response to the  	**/
	/** received frame.											**/
	FIN (wlan_hcf_physical_layer_data_arrival (void));

	/*  Access received packet from the physical layer stream.	*/
	wlan_rcvd_frame_ptr = op_pk_get (i_strm);	

	/* Get the type of the received WLAN frame and check 		*/
	/* whether it is marked as a bad packet in the pipeline		*/
	/* stages. Consider the possibility that we may receive a	*/
	/* noise packet from a powerful jammer, which we need		*/
	/* simply discard.											*/
	if (op_pk_encap_flag_is_set (wlan_rcvd_frame_ptr, OMSC_JAMMER_ENCAP_FLAG_INDEX) == OPC_FALSE)
		{
		op_pk_nfd_get_int32 (wlan_rcvd_frame_ptr, "Accept", &accept);
		op_pk_nfd_get_int32 (wlan_rcvd_frame_ptr, "Type", (int *) &rcvd_frame_type);
		}
	else
		{
		accept          = OPC_FALSE;
		rcvd_frame_type = WlanC_None;
		}
	
	//mohammad
	if(myDebugFlag)
		{
		sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
		MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
		fprintf(MyExcecutionTrace,"Time %f I am receiving a packet of type %d\n",op_sim_time(),(int)rcvd_frame_type);
		fclose(MyExcecutionTrace);
		
	
		
		}
	if(myStringDebug)
		{
		sprintf(myString,"I am %d:I am receiving a packet of type %d",(int)my_address,(int)rcvd_frame_type);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	//end mohammad

	/* If this is an ERP-OFDM packet and if we support 802.11g	*/
	/* PHY, then it is received with 6 usec signal extension	*/
	/* delay. Hence, reset the delay attribute of the packet	*/
	/* stream from the receiver.								*/
	if (accept && phy_type == WlanC_11g_PHY)
		{
		op_pk_nfd_get_int32 (wlan_rcvd_frame_ptr, "PHY Info", (int *) &rcvd_frame_phy_char);
		if (rcvd_frame_phy_char == WlanC_ERP_OFDM_11g)
			{
			op_ima_obj_attr_set (rx_state_info_ptr->mac_strm_objid, "delay", 0.0);
			
			/* If the packet will be rejected due to a 			*/
			/* collision, then update the receiver idle time	*/
			/* accordingly, since the packet could not be		*/
			/* decoded, which disables the signal extension.	*/
			if (wlan_flags->rcvd_bad_packet == OPC_TRUE) 
				disable_signal_extension = OPC_TRUE;
			}
		}
	
	/* Update the receiver idle time with current time. This is	*/
	/* necessary even though the receiver may be still busy.	*/
	/* Pay attention to collided packets with signal extension.	*/
	if (disable_signal_extension == OPC_FALSE)
		rcv_idle_time = current_time;
	else if (rcv_idle_time < current_time - WLANC_11g_SIGNAL_EXTENSION)
		rcv_idle_time = current_time - WLANC_11g_SIGNAL_EXTENSION;
		
	/* Update the TXOP flag. This is necessary because if the 	*/
	/* receiver is busy, no data transmission can be done.		*/
	if (wlan_flags->receiver_busy == OPC_TRUE)
		wlan_flags->txop_on = OPC_FALSE;
	
	/* If we received our own CTS-to-self and if we experienced	*/
	/* a reception during our transmission then discard the		*/
	/* CTS message since it has collided.						*/
	if (wlan_flags->rcvd_bad_cts && rcvd_frame_type == WlanC_Cts && op_pk_creation_mod_get (wlan_rcvd_frame_ptr) == my_objid)
		{
		/* Due to collision enable the EIFS duration flag.		*/ 	
		wlan_flags->wait_eifs_dur = OPC_TRUE;
			
		/* Increment the retry count.							*/
		src_arr [cur_tx_ac] += 1;
		
		/* Check if more retrys permitted, if not discard.		*/
		wlan_hcf_frame_discard (cur_tx_ac);

		/* Set expected frame type flag to none as we need to	*/
		/* retransmit the frame.								*/
		expected_frame_type = WlanC_None;
			
		/* Reset the flag that indicated the corrupted CTS-to-	*/
		/* self message.										*/
		wlan_flags->rcvd_bad_cts = OPC_FALSE;		

		/* Printing out information to ODB.						*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("Received bad CTS-to-self packet. Discarding.", OPC_NIL);
			}
		
		/* Destroy the bad packet.								*/
		op_pk_destroy (wlan_rcvd_frame_ptr);

		/* Unless it was already done, cancel the frame timeout	*/
		/* interrupt. It is likely to be still active due to	*/
		/* collision.											*/
		if (op_ev_valid (frame_timeout_evh) == OPC_TRUE)
			{
			op_ev_cancel (frame_timeout_evh);
			}
				
		/* Break the routine as no further processing is needed.*/
		FOUT;
		}
	else
		{
		/* Reset the phy_pkt_expected flag since we have received the	*/
		/* expected packet (hence, note that this flag is not set and	*/
		/* reset for own CTS-to-self messages).							*/
		wlan_flags->phy_pkt_expected = OPC_FALSE;
		}
	
	/* If the packet is received while the station is in transmission,	*/
	/* or if the packet is collided with another packet received or if	*/
	/* the accept field is set to false, then the packet will not be	*/
	/* processed and if needed the station will retransmit the packet.	*/
	if ((wlan_flags->rcvd_bad_packet == OPC_TRUE) || (accept == OPC_FALSE)) 
		{	
		/* If the pipeline stage set the accept flag to be false or if	*/
		/* it is collided then it means that the packet is erroneous.	*/
		/* Enable the EIFS duration flag. Do the same if the packet has	*/
		/* collided with our transmission, which doesn't require a		*/
		/* response, and its reception ended after our transmission.	*/
		if (accept == OPC_FALSE ||	(wlan_flags->rcvd_bad_packet == OPC_TRUE 
			&& expected_frame_type == WlanC_None && op_stat_local_read (TRANSMITTER_BUSY_INSTAT) == 0))
			{
			wlan_flags->wait_eifs_dur = OPC_TRUE;
			}
		
		/* We may have experienced a collision during transmission. We	*/
		/* could be transmitting a packet which requires a response (an	*/
		/* Rts or a data frame requiring an Ack). Even, this is the		*/
		/* case, we do not take any action right now and wait for the	*/
		/* related timers to expire; then we will retransmit the frame.	*/
		/* This is the approach described in the standard, and it is	*/
		/* necessary because of the slight possibility that our peer	*/
		/* may receive the frame without collision and send us the		*/
		/* response back, which we should be still expecting.			*/

		/* Check whether the timer for the expected response has		*/
		/* already expired. If yes, we must initiate the retransmission.*/
		if ((expected_frame_type != WlanC_None) && (wlan_flags->transmitter_busy == OPC_FALSE) &&
			(op_ev_valid (frame_timeout_evh) == OPC_FALSE))
			{
			/* We have either sent an RTS frame or a data frame.	*/
			/* Increment the short retry count if the transmission	*/
			/* of an RTS frame or a data frame smaller than RTS/CTS	*/
			/* threshold has failed; otherwise increment the long	*/
			/* retry count.											*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr [cur_tx_ac] += 1;
			else
				lrc_arr [cur_tx_ac] += 1;
			
			/* Check if more retrys permitted, if not discard.		*/
			wlan_hcf_frame_discard (cur_tx_ac);

			/* If Rts sent flag was enable then disable it as the station will recontend for the channel.	*/
			if (wlan_flags->rts_sent == OPC_TRUE)
				{
				wlan_flags->rts_sent = OPC_FALSE;
				}

			/* Set expected frame type flag to none as the		*/
			/* station needs to retransmit the frame.			*/
			expected_frame_type = WlanC_None;			
			}

		/* Set the bad packet dropped flag if this action is 	*/
		/* because the bad packet receive flag is true.			*/
		if (wlan_flags->rcvd_bad_packet == OPC_TRUE && op_stat_local_read (TRANSMITTER_BUSY_INSTAT) == 1)
			wlan_flags->bad_packet_dropped = OPC_TRUE;
		
		/* Reset the bad packet receive flag for subsequent		*/
		/* receptions.											*/
		wlan_flags->rcvd_bad_packet = OPC_FALSE;		

		/* If the corrupted frame is a Beacon, update the		*/
		/* reliability of the signal from AP indicating that	*/
		/* the packet was not successfully received.			*/
		if (rcvd_frame_type == WlanC_Beac && roam_state_ptr->enable_roaming && roam_state_ptr->scan_type == WlanC_Scan_Type_Beacon)
			wlan_ap_reliability_eval (wlan_rcvd_frame_ptr, OPC_FALSE, roam_state_ptr);

		/* Reception of a bad packet terminates our TXOP, hence our		*/
		/* burst of data frame transmissions.							*/
		if (wlan_flags->txop_on && fresp_to_send == WlanC_QoS_Data)
			fresp_to_send = WlanC_None;
		
		/* Printing out information to ODB.								*/
		if (wlan_trace_active == OPC_TRUE) 
			{
			op_prg_odb_print_major ("Received bad packet. Discarding received packet.", OPC_NIL);
			}
				
		/* Destroy the bad packet.										*/
		op_pk_destroy (wlan_rcvd_frame_ptr);

		/* Break the routine as no further processing is needed.		*/
		FOUT;
		}
	
	/* Reset the EIFS flag if it is set.								*/
	if (wlan_flags->wait_eifs_dur == OPC_TRUE)
		{
		wlan_flags->wait_eifs_dur = OPC_FALSE;

		/* If NAV is pointing sometime in future, then reset it. This	*/
		/* can happen when NAV is updated during a frame exchange		*/
		/* sequence, which could not complete successfully.				*/
		if (nav_duration > current_time)
			nav_duration = current_time;		
		}
	
	/* Make sure that the received packet is transmitted with a			*/
	/* physical layer technology that is supported by us so that we can	*/
	/* decode and process the packet. Get the PHY info unless it is		*/
	/* already obtained (in case of 802.11g operation).					*/
	if (phy_type != WlanC_11g_PHY)
		op_pk_nfd_get_int32 (wlan_rcvd_frame_ptr, "PHY Info", (int *) &rcvd_frame_phy_char);
	
	/* Check for the support.											*/
	if (!(rcvd_frame_phy_char == phy_char_flag || (phy_type == WlanC_11g_PHY && rcvd_frame_phy_char == WlanC_Direct_Sequence)))
		{
		/* It is an mismatching/unsupported PHY. Drop the packet and	*/
		/* quit the function.											*/
		op_pk_destroy (wlan_rcvd_frame_ptr);
		FOUT; 
		}
		
	/* If we are in "scanning" mode, discard any packet received from	*/
	/* the physical layer, unless it is a beacon message. The packet is	*/
	/* not expected to be destined to this MAC anyway, since it is not	*/
	/* registered in a BSS that it is currently evaluating.				*/
	if (wlan_flags->scanning == OPC_TRUE && rcvd_frame_type != WlanC_Beac)
		{
		/* Printing out information to ODB.								*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("Discarding the packet received from physical layer during scanning process.", OPC_NIL);
			}
			
		/* Destroy the packet and quit the function.					*/
		op_pk_destroy (wlan_rcvd_frame_ptr);
		FOUT;
		}
	
	/* Compute the values that will be used while updating the received	*/
	/* traffic statistics.												*/
	op_pk_nfd_get_dbl (wlan_rcvd_frame_ptr, "Tx Data Rate", &rcvd_frame_drate);
	rcvd_pk_size  = (double) op_pk_total_size_get (wlan_rcvd_frame_ptr);
	rx_start_time = current_time - rcvd_pk_size / rcvd_frame_drate;
	
	if ((rcvd_frame_type & ~(WLANC_QOS_DATA_BIT)) == WlanC_Data)
		{
		
		//mohammad
		if(myDebugFlag)
			{
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f the received packet is of type QOS data\n",op_sim_time());
			fclose(MyExcecutionTrace);
		
			
			}
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:the received packet is of type QOS data",(int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		//end mohammad
		
		/* Update received data traffic statistics. Write the		*/
		/* appropriate values for start and end of the reception.	*/
		op_stat_write_t (data_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (data_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (data_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (data_traffic_rcvd_handle, 0.0);
		
		/* Address information, sequence control fields, and the data	*/
		/* is extracted from the received packet.						*/
		

		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_HEADER_FD, (const void **) &pk_dhstruct_ptr);

		/* Obtain the destination this packet id addressed to.			*/
		dest_addr       = pk_dhstruct_ptr->address1;	
		remote_sta_addr = pk_dhstruct_ptr->address2;
		
		/* Store the duration information.							*/
		last_rcvd_duration = pk_dhstruct_ptr->duration;
		
		/* Process frame only if it is destined for this station	*/
		/* or it is a broadcast frame that is not originated by us.	*/
		if	((dest_addr == my_address) || 
			 (dest_addr < 0 && (bss_flag == OPC_FALSE || pk_dhstruct_ptr->address3 != my_address)))
			{	
			/* Find out the UP (TID) of the received data frame from its QoS		*/
			/* Control field. If the frame is coming from a nQSTA, them	assume its	*/
			/* UP as zero (best effort). Also obtain the ACK policy requested by	*/
			/* the received message.												*/
			if (rcvd_frame_type == WlanC_QoS_Data)
			{

				//Loren: Function does not get called from here in normal operation.
				op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_QOS_FD, (const void **) &qos_info_ptr);
				tid        = qos_info_ptr->tid;
				ack_policy = qos_info_ptr->ack_policy; 
			}
			else
			{
				tid = WLANC_nQSTA_DATA_UP;
				
				/* For non-QoS data frames, assume "No ACK" policy for broadcast	*/
				/* frames and "Normal ACK" for unicast frames.						*/
				ack_policy = (dest_addr == my_address) ? WlanC_Normal_ACK : WlanC_No_ACK;
			}
		
			/* Data packet id of the received data frame is extracted.				*/
			op_pk_fd_get_pkid (wlan_rcvd_frame_ptr, WLANC_DATA_PKID_FD, &data_pkt_id);

			/* Extracting the MSDU (or MSDU fragment) from the packet.				*/
			
			/*Loren*/
			//printf("I am  %d: getting seg_pkptr MDSU\n",(int)my_address);
		
			op_pk_fd_get_pkt (wlan_rcvd_frame_ptr, WLANC_DATA_BODY_FD, &seg_pkptr);
			int pack_size = op_pk_total_size_get (seg_pkptr);
			
			//Loren
			//printf("I am  %d: seg_pkptr size = %d\n",(int)my_address, (int)pack_size);
			
			
			
			/* Send acknowledgement if needed.										*/
			if (ack_policy == WlanC_Normal_ACK)
				{
				/* Send the acknowledgement to any received data frame.				*/
				fresp_to_send     = WlanC_Ack;
				response_sta_addr = remote_sta_addr;
				
				/* If there is a timer running for NAV expiry, then cancel it since	*/
				/* we will be leaving the "MEDIUM BUSY" state.						*/
				if (nav_duration > current_time && op_ev_valid (nav_end_evh))
					op_ev_cancel (nav_end_evh);
				}
			
			
			             	
			/* If its a duplicate packet then destroy it and do nothing, otherwise 	*/
			/* insert it in the defragmentation list.								*/
			if (wlan_hcf_tuple_find (rcvd_frame_type, tid, remote_sta_addr, pk_dhstruct_ptr->sequence_control, dest_addr, 
									 pk_dhstruct_ptr->retry, &src_sta_info_ptr, &prev_seq_num) == OPC_FALSE)
				{
				
				//not duplicated packet
				//hoon write the code that fill the array of the data received
				/*if((dest_addr == my_address) && ap_flag== OPC_BOOLINT_ENABLED)
					{
					peerStreamData[(int)remote_sta_addr] += op_pk_total_size_get(seg_pkptr);
					totalPeerStreamData[(int)remote_sta_addr] += op_pk_total_size_get(seg_pkptr);
				
					if(calculationMethod == FRAMESIZECHECK && peerStreamData[(int)remote_sta_addr] >= frameSizeOfNode[(int)remote_sta_addr])
						{
						peerStreamDataRate[(int)remote_sta_addr] =  peerStreamData[(int)remote_sta_addr]/(current_time-last_DataRate_reset_time[(int)remote_sta_addr]);
				
					
						if(strcmp(curve,"accu_quality_cmumit_withNI")==0)//!accu_woe_flag)
							{//for curve accuracy error = 1-detectionIndex + false detection index
							peerStreamAccuracy[(int)remote_sta_addr] = (1.266E-7 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-2.529)+0.2362);
						
							peerStreamAccuracyError[(int)remote_sta_addr] = peerStreamAccuracy[(int)remote_sta_addr];
							if(peerStreamAccuracy[(int)remote_sta_addr] <0 || peerStreamAccuracy[(int)remote_sta_addr] > 1)
								trimmedAccuracyCounter[(int)remote_sta_addr]++;
						
							peerStreamAccuracy[(int)remote_sta_addr] = 1 - (peerStreamAccuracy[(int)remote_sta_addr] > 1 ? 1 : peerStreamAccuracy[(int)remote_sta_addr]);
					
							peerStreamDistortion[(int)remote_sta_addr] = 6.778 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-0.2555) + -10.63;
							}
						else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
							{
							//for curve accuracy error = 1-detectionIndex
							peerStreamAccuracy[(int)remote_sta_addr] = (2.899E-7 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-2.455)+0.11);
							peerStreamAccuracyError[(int)remote_sta_addr] = peerStreamAccuracy[(int)remote_sta_addr];
							if(peerStreamAccuracy[(int)remote_sta_addr] <0 || peerStreamAccuracy[(int)remote_sta_addr] > 1)
								trimmedAccuracyCounter[(int)remote_sta_addr]++;
							peerStreamAccuracy[(int)remote_sta_addr] = 1 - (peerStreamAccuracy[(int)remote_sta_addr] > 1 ? 1 : peerStreamAccuracy[(int)remote_sta_addr]);
							
							peerStreamDistortion[(int)remote_sta_addr] = 6.778 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-0.2555) + -10.63;
							}
						else if(strcmp(curve,"accu_quality_frontal")==0)
							{
					
							peerStreamAccuracy[(int)remote_sta_addr] = (4.346E-16 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-8.104)+0.1797);
							peerStreamAccuracyError[(int)remote_sta_addr] = peerStreamAccuracy[(int)remote_sta_addr];
							if(peerStreamAccuracy[(int)remote_sta_addr] <0 || peerStreamAccuracy[(int)remote_sta_addr] > 1)
								trimmedAccuracyCounter[(int)remote_sta_addr]++;
							peerStreamAccuracy[(int)remote_sta_addr] = 1 - (peerStreamAccuracy[(int)remote_sta_addr] > 1 ? 1 : peerStreamAccuracy[(int)remote_sta_addr]);
					
					
							peerStreamDistortion[(int)remote_sta_addr] = 8.417E-7 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-3.937) + 0;
							}
						else if(strcmp(curve,"accu_resolution_frontal")==0)
							{
					
							peerStreamAccuracy[(int)remote_sta_addr] = (5.079E-008 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-2.28)+0.2446);
							peerStreamAccuracyError[(int)remote_sta_addr] = peerStreamAccuracy[(int)remote_sta_addr];
							if(peerStreamAccuracy[(int)remote_sta_addr] <0 || peerStreamAccuracy[(int)remote_sta_addr] > 1)
								trimmedAccuracyCounter[(int)remote_sta_addr]++;
							peerStreamAccuracy[(int)remote_sta_addr] = 1 - (peerStreamAccuracy[(int)remote_sta_addr] > 1 ? 1 : peerStreamAccuracy[(int)remote_sta_addr]);
					
					
							peerStreamDistortion[(int)remote_sta_addr] = 0.1403 * pow(peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0,-0.6785) + 0;
							}
				
						else if(strcmp(curve,"matlabOptimization_accu_resolution_cmumit")==0)//hoon
							{
					
							//0.9405 .*W .* exp(-233.5 .*(x.* Y)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y)./T)
					
							peerStreamAccuracy[(int)remote_sta_addr] = 0.9405 * exp(-233.5 *peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0) + 0.2563 * exp(-1.354 *peerStreamDataRate[(int)remote_sta_addr]/8.0/20.0/1024.0/1024.0);
							peerStreamAccuracyError[(int)remote_sta_addr] = peerStreamAccuracy[(int)remote_sta_addr];
							if(peerStreamAccuracy[(int)remote_sta_addr] <0 || peerStreamAccuracy[(int)remote_sta_addr] > 1)
								trimmedAccuracyCounter[(int)remote_sta_addr]++;
					
							//peerStreamAccuracy[(int)i] = (5.079E-008 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-2.28)+0.2446);
							peerStreamAccuracy[(int)remote_sta_addr] = 1 - (peerStreamAccuracy[(int)remote_sta_addr] > 1 ? 1 : peerStreamAccuracy[(int)remote_sta_addr]);
							}
					
					
				
						//	peerStreamDistortion[(int)i] =6.778 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-0.2555) + -10.63;
				
					
						if(peerStreamDistortion[(int)remote_sta_addr]<0)
							peerStreamDistortion[(int)remote_sta_addr] = 0;
						
						if (peerStreamDataRate[(int)remote_sta_addr] == 0)
							{
							peerStreamAccuracyError[(int)remote_sta_addr]= 25;
							peerStreamDistortion[(int)remote_sta_addr] = 25;
							}
						
						accuracyCalculationCounter[(int)remote_sta_addr]++;
					
					
						if(myDataFileGenerationFlag == 1)
							{
						
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							//fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f\n",
							fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f,totalData=%f,trimmedCounter=%d,totalCounter=%d,accuracyError=%f\n",
							(double)op_sim_time(),(int)remote_sta_addr,(double)peerStreamDataRate[(int)remote_sta_addr],(double)peerStreamAccuracy[(int)remote_sta_addr],(double)peerStreamDistortion[(int)remote_sta_addr],(double)totalPeerStreamData[(int)remote_sta_addr],trimmedAccuracyCounter[(int)remote_sta_addr],accuracyCalculationCounter[(int)remote_sta_addr],peerStreamAccuracyError[(int)remote_sta_addr]);
							fclose(MyExcecutionTrace);
							}
					
						//dataRateSum += peerStreamDataRate[i];
						//accuracySum +=peerStreamAccuracy[i];
						
						//weighted_sum += peerStreamAccuracy[i]*peer_info_ptr -> peer_importance;
					
						//distortionSum +=peerStreamDistortion[i];
					
						peerStreamData[(int)remote_sta_addr] = 0;
						peerStreamDataRate[(int)remote_sta_addr] = 0;
						peerStreamAccuracy[(int)remote_sta_addr] = 0;
						peerStreamDistortion[(int)remote_sta_addr] = 0;
						last_DataRate_reset_time[(int)remote_sta_addr] = current_time;
						peerStreamAccuracyError[(int)remote_sta_addr] = 0;
						}
					
					
					
					}//end of my stat
				
				*/
				
				
				
	           	/* If congestion area analysis is enabled and if this is a tracer	*/
				/* packet update the congestion area info.							*/
				if (CONGESTION_AREAS_ENABLED && op_pk_encap_flag_is_set (seg_pkptr, OMSC_BGUTIL_ENCAP_FLAG_INDEX))
					wlan_support_congestion_area_info_update (seg_pkptr, rx_state_info_ptr);

				/* If there is an ongoing block ACK agreement with the source STA	*/
				/* then process the MPDU segment according to the BA rules.			*/
				if (dest_addr == my_address && 
					(ack_policy == WlanC_Block_ACK ||
					 (src_sta_info_ptr->ba_state_ptr_arr != OPC_NIL && src_sta_info_ptr->ba_state_ptr_arr [tid] != OPC_NIL &&
					  src_sta_info_ptr->ba_state_ptr_arr [tid]->peer_block_size > 0)))
					{
					wlan_hcf_ba_data_process (rcvd_frame_type, seg_pkptr, remote_sta_addr, src_sta_info_ptr, pk_dhstruct_ptr->address3, tid, 
						pk_dhstruct_ptr->sequence_control, pk_dhstruct_ptr->more_frag, pk_dhstruct_ptr->hl_protocol, data_pkt_id, ack_policy, prev_seq_num);
					}
				else
					{
					/*Loren
					printf("I am %d, calling wlan_hcf_data_process function 1.\n", (int)my_address);
					*/
					
					wlan_hcf_data_process (rcvd_frame_type, seg_pkptr, dest_addr, remote_sta_addr, pk_dhstruct_ptr->address3, pk_dhstruct_ptr->hl_protocol,
						pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK, pk_dhstruct_ptr->more_frag, data_pkt_id, tid, src_sta_info_ptr);
					}
				}
			else
				{
				
				/* Destroy the duplicate packet without any processing.				*/
				op_pk_destroy (seg_pkptr);
				}
			}
		else
			{
			
			
			//mohammad
			if(myDebugFlag)
				{
				sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
				MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
				fprintf(MyExcecutionTrace,"Time %f I am receiving a QOS DATA packet (type %d) that is not for me\n",op_sim_time(),(int)rcvd_frame_type);
				fclose(MyExcecutionTrace);
			
				
				}
			if(myStringDebug)
				{
				sprintf(myString,"I am %d:I am receiving a QOS DATA packet (type %d) that is not for me",(int)my_address,(int)rcvd_frame_type);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
			//end mohammad
			
			/* The received data packet is not destined to us. Update NAV	*/
			/* duration if the received NAV duration is greater	than the	*/
			/* current NAV duration.							  			*/    	
			if (last_rcvd_duration < 32768 && nav_duration < (last_rcvd_duration + current_time))
				{
				nav_duration = last_rcvd_duration + current_time;

				/* Set the flag that indicates updated NAV value.			*/
				wlan_flags->nav_updated = OPC_TRUE;
				}
			}
		
		if (expected_frame_type == WlanC_Ack)
			{
			/* A frame has not been properly acknowledged and requires				*/
			/* retransmission. Did the data transmission fail in spite of a			*/
			/* successful RTS/CTS exchange?											*/
			if (wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac])
				/* Increment the long retry count.									*/
				lrc_arr [cur_tx_ac] += 1;
			else
				/* Increment the short retry count.									*/
				src_arr [cur_tx_ac] += 1;
			
			/* Reset the rts_sent flag since we will recontend for the medium.		*/
			wlan_flags->rts_sent = OPC_FALSE;					
			}	

		if (expected_frame_type == WlanC_Cts) 
			{
			/* Since the station did not receive the expected frame it has to		*/
			/* retransmit the packet.												*/
			src_arr [cur_tx_ac] += 1;
			}			
		}

	else if	(rcvd_frame_type == WlanC_Beac)
		{
		
		if(strcmp(bnadwidth_allocation_method,"EDCA")==0 && (current_time - EDCA_last_DataRate_reset_time > calculationPeriod))
			{
				last_sent_physicalRate = operational_speed;
				last_sent_droppedBRate = my_droppedB_sum/(op_sim_time()-last_my_droppedB_calculated_time);
				last_sent_droppedRRate = my_droppedR_sum/(op_sim_time()-last_my_droppedR_calculated_time);
				last_sent_loadRate = my_load_sum/(op_sim_time()-last_my_load_calculated_time);
				last_sent_sentRate = my_sent_sum/(op_sim_time()-last_my_sent_calculated_time);	
	
				last_my_droppedB_calculated_time = op_sim_time();
				my_droppedB_sum = 0;
				last_my_droppedR_calculated_time = op_sim_time();
				my_droppedR_sum = 0;
				last_my_load_calculated_time = op_sim_time();
				my_load_sum = 0;
				last_my_sent_calculated_time = op_sim_time();
				my_sent_sum = 0;
				
				EDCA_last_DataRate_reset_time = current_time;
				
				Ls = (double)total_data_size_sent_without_headers/data_packet_sent_count;
			
				Os = (double)total_data_header_size_sent / data_packet_sent_count;
			
			
			
				total_data_size_sent_without_headers = 0;
				data_packet_sent_count = 0;
				total_data_header_size_sent = 0;
				
				last_calculated_average_TXOP_displasement = TXOP_displasement_total/number_of_TXOP_in_calculation_period;
				TXOP_displasement_total = 0;
				number_of_TXOP_in_calculation_period = 0;
			}
		
		
		/* Update received management traffic statistics. Write the	*/
		/* appropriate values for start and end of the reception.	*/
		op_stat_write_t (mgmt_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (mgmt_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (mgmt_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (mgmt_traffic_rcvd_handle, 0.0);
		
		//mohammad
		if(myDebugFlag)
			{
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f The received packet is of type beacon\n",op_sim_time());
			fclose(MyExcecutionTrace);
		
			
			}
		
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:The received packet is of type beacon",(int)my_address);
		
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		
		
		//end mohammad
		
		/* Address information, sequence control fields, and the	*/
		/* data is extracted from the rcvd packet.					*/
		

		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_HEADER_FD, (const void **) &pk_dhstruct_ptr);

		/* The destination address in this case will be -1 as the	*/
		/* beacon frame is a broadcast frame.				      	*/
		dest_addr = pk_dhstruct_ptr->address1;			
		
		/* Store the address of the AP transmitting the Beacon.		*/
		remote_sta_addr = pk_dhstruct_ptr->address2;	
		rcvd_sta_bssid = pk_dhstruct_ptr->address3;
		
		/* Store the duration information.							*/
		last_rcvd_duration = pk_dhstruct_ptr->duration;
				
		/* If roaming enabled, update the reliability of the signal	*/
		/* from the AP that sent this Beacon, which we received		*/
		/* successfully.											*/
		if (roam_state_ptr->enable_roaming && roam_state_ptr->scan_type == WlanC_Scan_Type_Beacon)
			wlan_ap_reliability_eval (wlan_rcvd_frame_ptr, OPC_TRUE, roam_state_ptr);
		
		/* If the STA is scanning for a new BSS, then save the BSS ID of the beacon transmitter. */
		if (roam_state_ptr->scan_mode)
			eval_bss_id = rcvd_sta_bssid;

		/* Since beacons are broadcasted, no response to sent.		*/
		fresp_to_send = WlanC_None; 
		
		/* Extracting the Beacon Body packet.						*/
		/*Loren
		printf("I am  %d: getting seg_pkptr 1\n",(int)my_address);
		*/
		
		op_pk_fd_get_pkt (wlan_rcvd_frame_ptr, WLANC_DATA_BODY_FD, &seg_pkptr);//"Frame Body"

		
		//op_pk_nfd_get_pkt (wlan_rcvd_frame_ptr, "Frame Body", &seg_pkptr);//mohammad
		
		/* Extracting the Beacon Body structure from packet  */
		
		//Loren: Function does not get called from here in normal operation.		
		op_pk_fd_access_read_only_ptr (seg_pkptr, WLANC_BEACON_BODY_FD, (const void **) &pk_bbstruct_ptr);

		if (expected_frame_type != WlanC_None) 
			{
			/* Since the station did not receive the expected frame	*/
			/* it has to retransmit the packet.						*/

			/* Increment the short retry count if the transmission	*/
			/* of an RTS frame or a data frame smaller than RTS/CTS	*/
			/* threshold has failed; otherwise increment the long	*/
			/* retry count.											*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr [cur_tx_ac] += 1;
			else
				lrc_arr	[cur_tx_ac] += 1;
			
			/* Also reset the rts_sent flag since we will recontend.*/
			wlan_flags->rts_sent = OPC_FALSE;
			}
			
		/* If beacon is intended for this BSS, update BSS related variables.	*/
		if (rcvd_sta_bssid == bss_id) 
			{
			/* Set beacon interval */
			beacon_int = pk_bbstruct_ptr->beacon_intv;
			
			
			
			op_stat_write(beacon_interval_stat,beacon_int);
			
			//mohammad
			++received_beacon_count;
			op_stat_write_t (received_beacon_count_stat, received_beacon_count,op_sim_time ());
		
			if(myDebugFlag)
				{
				sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
				MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
				fprintf(MyExcecutionTrace,"Time %f I received beacon packet from %d in bss %d\n",op_sim_time(),remote_sta_addr,rcvd_sta_bssid);
				fclose(MyExcecutionTrace);
			
			
				
				}
			if(myStringDebug)
				{
				sprintf(myString,"I am %d:I received beacon packet from %d in bss %d",(int)my_address,(int)remote_sta_addr,(int)rcvd_sta_bssid);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
			//end mohammad
			
			//op_stat_write_t(beacon_interval_stat,beacon_int, op_sim_time()+1);
			//
			
			//op_stat_write(beacon_interval_stat,beacon_int);	
			/* If we and our AP support 11g data rates and PHY then compare the	*/
			/* value of non_erp_present in the beacon frame with our own flag.	*/
			if (phy_type == WlanC_11g_PHY && ap_peer_info_ptr->is_erp == OPC_TRUE && roam_state_ptr->scan_mode == OPC_FALSE)
				{
				
				
				if (!wlan_flags->non_erp_present && pk_bbstruct_ptr->non_erp_present)
					{
					/* There are new non-ERP STAs in our BSS as reported by our	*/
					/* AP. Increase the slot time and recompute the dependent	*/
					/* parameters.												*/
					wlan_hcf_slot_time_set (20E-06);

					/* Reduce the control frame data rate to 802.11/11b			*/
					/* mandatory data rate.										*/
					control_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
					
					/* Set our own flag.										*/
					wlan_flags->non_erp_present = OPC_TRUE;
					}
				
				else if (wlan_flags->non_erp_present && !pk_bbstruct_ptr->non_erp_present)
					{
					/* There are no non-ERP STAs left in our BSS as reported by	*/
					/* our AP. Decrease the slot time and recompute the			*/
					/* dependent parameters.									*/
					
					wlan_hcf_slot_time_set (9E-06);

					/* Reselect the control frame data rate. Choose the highest	*/
					/* mandatory data rate that is equal to or lower than the	*/
					/* data rate specified for data transmissions.				*/
					for (i = 0; data_tx_rate < WLANC_11g_MANDATORY_DRATE_ARRAY [i]; i++);
					control_data_rate = WLANC_11g_MANDATORY_DRATE_ARRAY [i];
					
					/* Reset our own flag.										*/
					wlan_flags->non_erp_present = OPC_FALSE;
					}
				}
			
			}
		
		
		/* Check whether the beacon contains any EDCA Parameter Set				*/
		/* configuration, if it is from our current AP or from the AP that we	*/
		/* found during scanning and just concluded that it is reliable.		*/
		if (rcvd_sta_bssid == bss_id || (roam_state_ptr->ap_reliability == WLANC_AP_RELIABLE && wlan_flags->scanning == OPC_TRUE))
			{
			/* If the beacon conveys EDCA Parameter Set information and if we	*/
			/* are not using an EDCA Parameter Set updated using a previous		*/
			/* beacon, then update our EDCA Parameter Set using the information	*/
			/* in this beacon. Do the same if we are scanning for a new AP and	*/
			/* with this beacon we conclude that the currently evaluated AP is	*/
			/* reliable. Ignore the set if we are scanning and didn't yet		*/
			/* conclude that the evaluated AP is reliable.						*/
			if ((wlan_flags->edca_params_updated == OPC_FALSE  || wlan_flags->scanning == OPC_TRUE) 				  &&				
				pk_bbstruct_ptr->edca_param_set_arr != OPC_NIL && roam_state_ptr->ap_reliability == WLANC_AP_RELIABLE	)
				{
				/* For each category, update the EDCA Parameters.				*/
				for (i = 0; i < WLANC_HCF_AC_COUNT; i++)
					{
					cwmin_arr [i] = pk_bbstruct_ptr->edca_param_set_arr [i].cwmin;
					cwmax_arr [i] = pk_bbstruct_ptr->edca_param_set_arr [i].cwmax;
					aifsn_arr [i] = pk_bbstruct_ptr->edca_param_set_arr [i].aifsn;
					
					/* Convert the TXOP Limit from microseconds to seconds.		*/
					txop_limit_arr [i] = (double) pk_bbstruct_ptr->edca_param_set_arr [i].txop_limit / 1000000;
					
					/* Also set to CW size to CWmin if the current retry count	*/
					/* for this AC is zero.										*/
					if (src_arr [i] + lrc_arr [i] == 0)
						cw_arr [i] = cwmin_arr [i];
					
					/* Compute the new AIFN duration using the new AIFSN value.	*/
					aifs_arr [i] = (double) aifsn_arr [i] * slot_time + sifs_time;
					}
				
				/* Set the flag to prevent redundant updates.					*/
				wlan_flags->edca_params_updated = OPC_TRUE;
				}
			
			/* If we were scanning and found a new AP, and this AP doesn't		*/
			/* advertise EDCA Parameter Set for its BSS, then revert back to	*/
			/* our own EDCA parameter configuration if we were using an			*/
			/* advertised set in our previous BSS.								*/			
			else if (wlan_flags->scanning == OPC_TRUE               && roam_state_ptr->ap_reliability  == WLANC_AP_RELIABLE &&
					 pk_bbstruct_ptr->edca_param_set_arr == OPC_NIL && wlan_flags->edca_params_updated == OPC_TRUE            )
				{
				wlan_flags->edca_params_updated = OPC_FALSE;
				wlan_hcf_edca_parameter_set_read (own_ac_edca_params_objid);
				}
			
			
			
			if(strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")!=0 && strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD")!=0 
				&&strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")!=0 && strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")!=0)
				{
			
				if(fee_lambda_trace_flag)
				{
				sprintf(myString,"I am  %d:fee is being calculated",(int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
				//Loren
				//sprintf(myString,"I am 2, myDebugFlag = %d, myDataFileGenerationFlag = %d, myStringDebug = %d, generatePacketTraceFlag = %d, opencvDebugFlag = %d", myDebugFlag, myDataFileGenerationFlag, myStringDebug, generatePacketTraceFlag, opencvDebugFlag);
				//op_prg_odb_print_major(myString,OPC_NIL);
				}
			
			//start sending state report after finishing estimation
			if (current_time > EAestimationTime && stateReportStarted ==0)
				{
				//Schedule a self interrupt to kick off the state report timer.	
				stateReport_tx_time = op_sim_time() + op_dist_uniform((int)stateReport_int);
				op_intrpt_schedule_self (stateReport_tx_time, WlanC_StateReport_Tx_Time);
				stateReportStarted = 1;
				}
					
			
			
								
				current_lambda = pk_bbstruct_ptr->lambda;
				
								
				if(fee_lambda_trace_flag)
					{
			
					
					//printf("bnadwidth_allocation_method = %s and tempBnadwidth_allocation_method = %s\n",bnadwidth_allocation_method,tempBnadwidth_allocation_method);
					
					sprintf(myString,"I am  %d:Importance is  %f",(int)my_address,(double) importance);
				op_prg_odb_print_major(myString,OPC_NIL);
					
				sprintf(myString,"I am  %d:Lambda is recieved as %e",(int)my_address,(double) current_lambda);
				op_prg_odb_print_major(myString,OPC_NIL);
			
				sprintf(myString,"I am  %d:Frame rate is %5.40f",(int)my_address,(double)op_stat_local_read(APPL_FRAMERATE_INSTAT));
				op_prg_odb_print_major(myString,OPC_NIL);
			
			
				sprintf(myString,"I am  %d:Constant a is %40.40f",(int)my_address,(double)accuracyConstant_a);
				op_prg_odb_print_major(myString,OPC_NIL);
	
				sprintf(myString,"I am  %d:Constant b is %40.40f",(int)my_address,(double)accuracyConstant_b);
				op_prg_odb_print_major(myString,OPC_NIL);
	
				sprintf(myString,"I am  %d:Constant c is %40.40f",(int)my_address,(double)accuracyConstant_c);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				sprintf(myString,"I am  %d:last sent physical rate %f",(int)my_address,(double)last_sent_physicalRate);
				op_prg_odb_print_major(myString,OPC_NIL);
				
				
				}
				
				if(strcmp(bnadwidth_allocation_method,"EDCA")!=0 && current_lambda <=0   && current_time > EAestimationTime+transitionTime)
						op_sim_end ("Invalid LAMBDA recieved", "", "", "");
							
				
				if(strcmp(bnadwidth_allocation_method,"wdis2")==0)
					{
					// Loren: typecast log arguments to double for C++
					f = -1.0/(accuracyConstant_b*last_sent_physicalRate/1000000.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)) *
						log(current_lambda/
							(importance *pow(accuracyConstant_a,2)*(accuracyConstant_b*last_sent_physicalRate/1000000.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT))*log(2.0)))/log(2.0); 
						
					}
				else if(strcmp(bnadwidth_allocation_method,"dist2")==0)
					{
					// Loren: typecast log arguments to double for C++
					f = -1.0/(accuracyConstant_b*last_sent_physicalRate/1000000.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)) *
						log(current_lambda/
							(pow(accuracyConstant_a,2)*(accuracyConstant_b*last_sent_physicalRate/1000000.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT))*log(2.0)))/log(2.0);
					}
					
				else if(strcmp(bnadwidth_allocation_method,"accu")==0 || strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0 || strcmp(bnadwidth_allocation_method,"accu_D2")==0)
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f = tempF;
					
					//double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
					//	/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					//f = tempF;
					
					
					
					}//done
				
				
				else if(strcmp(bnadwidth_allocation_method,"faccu")==0)//accuracy without weight
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f = tempF;
					
					}//done
				
				
				else if(strcmp(bnadwidth_allocation_method,"wdis")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0)
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"dist")==0 ||strcmp(bnadwidth_allocation_method,"dist_app")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0)
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
							/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1));
					//printf("inside if f = %f\n",tempF);
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_app")==0)
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f = tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_link")==0)
					{
					
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(1.0/nodes_no * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
										
					//double tempF = (double)op_stat_local_read(APPL_APPRATEINBITS_INSTAT)/last_sent_physicalRate;
					
					f = tempF;
					}//done
					
				else if(strcmp(bnadwidth_allocation_method,"wdis_app")==0)
					{
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"wdis_link")==0)
					{
					
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(1.0/nodes_no * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					//double tempF = (double)op_stat_local_read(APPL_APPRATEINBITS_INSTAT)/last_sent_physicalRate;
					
					f = tempF;
					}//done
				
				//else if(strcmp(bnadwidth_allocation_method,"dist_app")==0)
				//	{
				//	double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
				//		/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
				//	
				//	f = tempF;
				//	}//done
				else if (strcmp(bnadwidth_allocation_method,"dist_link")==0)
					{
					
					double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
							/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1));
					
					//double tempF = (double)op_stat_local_read(APPL_APPRATEINBITS_INSTAT)/last_sent_physicalRate;
					
					f = tempF;
					}//done
				
				
				///with header
				else if(strcmp(bnadwidth_allocation_method,"accu_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f = tempF;
					}//done
				else if(strcmp(bnadwidth_allocation_method,"wdis_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"dist_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_app_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f = tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_link_H")==0)
					{
					
					
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(1.0/nodes_no * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
									
									
					f = tempF;
					}//done
					
				else if(strcmp(bnadwidth_allocation_method,"wdis_app_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"wdis_link_H")==0)
					{
					
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(1.0/nodes_no * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					//double tempF = (double)op_stat_local_read(APPL_APPRATEINBITS_INSTAT)/last_sent_physicalRate;
					
					f = tempF;
					}//done
				
				else if(strcmp(bnadwidth_allocation_method,"dist_app_H")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					f = tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"dist_link_H")==0)
					{
					
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) - last_sent_protocolOverheadRate)/last_sent_physicalRate; 
					
					//double tempF = (double)op_stat_local_read(APPL_APPRATEINBITS_INSTAT)/last_sent_physicalRate;
					
					f = tempF;
					}//done
				
				//with dropped
				
				else if(strcmp(bnadwidth_allocation_method,"accu_D")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + (last_sent_droppedBRate+last_sent_droppedRRate))/last_sent_physicalRate; 
					
					//double tempF = pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
					//	/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate * pow(last_sent_physicalRate/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),accuracyConstant_b-1)),1/(accuracyConstant_b-1)); 
					
					f = tempF;
					}//done
				else if(strcmp(bnadwidth_allocation_method,"wdis_D")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + (last_sent_droppedBRate+last_sent_droppedRRate))/last_sent_physicalRate; 
					
					f =  tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"dist_D")==0)
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + (last_sent_droppedBRate+last_sent_droppedRRate))/last_sent_physicalRate; 
					
					f =  tempF;
					}//done
				
				
				else if(strcmp(bnadwidth_allocation_method,"app_only")==0 || strcmp(bnadwidth_allocation_method,"link_only")==0)
					{
					
					
					f = importance;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_app_D")==0 || strcmp(bnadwidth_allocation_method,"accu_onlyApp_D")==0 )
					{
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(importance * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + (last_sent_droppedBRate+last_sent_droppedRRate))/last_sent_physicalRate; 
					
					f = tempF;
					}//done
				else if (strcmp(bnadwidth_allocation_method,"accu_link_D")==0|| strcmp(bnadwidth_allocation_method,"accu_onlylink_D")==0)
					{
					
					double tempF = ((double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*pow(-current_lambda*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)
						/(1.0/nodes_no * accuracyConstant_a * accuracyConstant_b * last_sent_physicalRate ),1/(accuracyConstant_b-1)) + (last_sent_droppedBRate+last_sent_droppedRRate))/last_sent_physicalRate; 
									
									
					f = tempF;
					}//done
				
				//else if(strcmp(bnadwidth_allocation_method,"EDCA")==0)
				//	f = 1.0/nodes_no;
								
				
				
				
				if(fee_lambda_trace_flag)
					{
					sprintf(myString,"I am  %d:fee is calculated as %f",(int)my_address,(double) f);
			
					op_prg_odb_print_major(myString,OPC_NIL);
				
					sprintf(myString,"I am  %d:physical rate is %f",(int)my_address,(double) last_sent_physicalRate);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					
					sprintf(myString,"I am  %d:frame rate is %f",(int)my_address,(double)op_stat_local_read(APPL_FRAMERATE_INSTAT));
			
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"I am  %d:protocol overhead rate is %f",(int)my_address,(double)last_sent_protocolOverheadRate);
					
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"I am  %d:nodes number is %d",(int)my_address,(int)nodes_no);
					
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"I am  %d:operational_speed number is %d",(int)my_address,(int)operational_speed);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					}
				
				op_stat_write (fee_stat, (double) f);
					
					
					
				if(strcmp(bnadwidth_allocation_method,"EDCA_estimation")!=0 && strcmp(bnadwidth_allocation_method,"EDCA_estimation_txop")!=0 && (f <=0 || f >1) && (EAcalculatedFlag) && current_time > EAestimationTime+1.5*EACalculationPeriod)
						op_sim_end ("Invalid FEE calculated", "", "", "");
				
				if(EAcalculatedFlag && !totalDataResetedFalg)
					{
					//reset total data sent
					total_data_sent = 0;
					if(current_time > EAestimationTime + transitionTime) //time sensitive
						totalDataResetedFalg = 1;
					}
			
							
			//if(current_time > 10)
			//{
							
				if(strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0||strcmp(bnadwidth_allocation_method,"dist")==0 || strcmp(bnadwidth_allocation_method,"wdis")==0|| strcmp(bnadwidth_allocation_method,"faccu")==0||strcmp(bnadwidth_allocation_method,"accu")==0
					||strcmp(bnadwidth_allocation_method,"wdis_app")==0|| strcmp(bnadwidth_allocation_method,"dist_app")==0|| strcmp(bnadwidth_allocation_method,"accu_app")==0 ||strcmp(bnadwidth_allocation_method,"accu_link")==0
					
					||strcmp(bnadwidth_allocation_method,"dist_H")==0 || strcmp(bnadwidth_allocation_method,"wdis_H")==0|| strcmp(bnadwidth_allocation_method,"accu_H")==0
					||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0|| strcmp(bnadwidth_allocation_method,"dist_app_H")==0|| strcmp(bnadwidth_allocation_method,"accu_app_H")==0
					
					||strcmp(bnadwidth_allocation_method,"accu_D")==0 ||strcmp(bnadwidth_allocation_method,"dist_D")==0||strcmp(bnadwidth_allocation_method,"wdis_D")==0
					||strcmp(bnadwidth_allocation_method,"app_only")==0 
					
					||strcmp(bnadwidth_allocation_method,"accu_link_D")==0 || strcmp(bnadwidth_allocation_method,"accu_app_D")==0
					||strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
					|| strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"accu_D2")==0|| strcmp(bnadwidth_allocation_method,"accu_onlyApp_D")==0 
					 
					
					)
					{
					if(pruning_flag == 1 && current_time > EAestimationTime+transitionTime )
						{
						double tempError, prunedError;
						
						
							
							if(f * last_sent_physicalRate <=0)
								op_sim_end ("f * last_sent_physicalRate - last_sent_droppedBRate is less than 0", "", "", "");
							
							
							
														
							tempFrameSize = (double)( f * last_sent_physicalRate )/8.0/1024.0/1024.0/(double)op_stat_local_read(APPL_FRAMERATE_INSTAT);
							
							
							
							if(strcmp(bnadwidth_allocation_method,"accu")==0)
								tempError = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
							else
								tempError = pow(accuracyConstant_a,2) * pow(2,-accuracyConstant_b*(tempFrameSize));//f(x) = a^2 * 2 ^ (-b*x)
								
											
							sprintf(myString,"I am  %d:frame size before reduction is calculated as %f, accuracy is %f",(int)my_address,(double)tempFrameSize,tempAccuracy);
			
							op_prg_odb_print_major(myString,OPC_NIL);
						
							prunedError = 1-((1-tempError) * pruning_percent/100.0);
						
						
							if(prunedError-accuracyConstant_c <=0)
								op_sim_end ("(tempAccuracy + pruning_percent/100.0*tempAccuracy)-accuracyConstant_c is less than 0", "", "", "");
							
							if(strcmp(bnadwidth_allocation_method,"accu")==0)
								tempFrameSize = exp(log((prunedError-accuracyConstant_c)/accuracyConstant_a)/accuracyConstant_b);
							//else no prunning for any thing else
							//	tempFrameSize = -1/accuracyConstant_b*log((tempAccuracy + pruning_percent/100.0*tempAccuracy)/pow(2,accuracyConstant_a))/log(2);
								
						
							tempAccuracy = accuracyConstant_a*pow(tempFrameSize,accuracyConstant_b)+accuracyConstant_c;
							
							
						
						sprintf(myString,"I am  %d:frame size after reduction is calculated as %f, accuracy is %f",(int)my_address,(double)tempFrameSize,tempAccuracy);
			
						op_prg_odb_print_major(myString,OPC_NIL);
						
						sprintf(myString,"I am  %d:application rate (bit per second) is %f",(int)my_address,(double) f * last_sent_physicalRate);
			
						op_prg_odb_print_major(myString,OPC_NIL);
						
						appRateBits = (double) tempFrameSize*(double)op_stat_local_read(APPL_FRAMERATE_INSTAT)*8*1024*1024;
							
						//appRateBits = (double) f * last_sent_physicalRate - (double) f * last_sent_physicalRate *pruning_percent/100.0;//-last_sent_droppedBRate;
						
						}
					else 
						{
						//sprintf(myString,"I am  %d:sending application rate (bit per second is %f",(int)my_address,(double) f * last_sent_physicalRate);
			
						//op_prg_odb_print_major(myString,OPC_NIL);
						
							appRateBits = (double) f * last_sent_physicalRate;//-last_sent_droppedBRate;
							
							
			
						}
									
					}
				else if(strcmp(bnadwidth_allocation_method,"EDCA")==0)
					{
					appRateBits = (double)max_operational_speed/nodes_no;//-last_sent_droppedBRate;
					}
				else if(strcmp(bnadwidth_allocation_method,"EDCA_estimation")==0 || strcmp(bnadwidth_allocation_method,"EDCA_estimation_txop")==0)
					{
					if(!EAcalculatedFlag)
						appRateBits = (double)max_operational_speed/nodes_no;//-last_sent_droppedBRate;
					else
						appRateBits = (double)max_operational_speed*current_lambda/nodes_no;//-last_sent_droppedBRate;
					}
					
				
				if(current_time > EAestimationTime && (appRateBits <=0 || appRateBits >=200000000) )
								op_sim_end ("Invalid application rate calculated", "", "", "");
				
				
			
				//if(strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0)
				//	ceiling = ceil((double)f * last_sent_physicalRate * (double)beacon_int/Ls);
				//else
					ceiling = ceil((double)f * last_sent_physicalRate * (float)TXOPinterval/Ls);//hoon
					
			
				//for now i will change TXOP of the video catigory only
				
				
		
				if(strcmp(bnadwidth_allocation_method,"dist")==0 || strcmp(bnadwidth_allocation_method,"wdis")==0 || strcmp(bnadwidth_allocation_method,"accu")==0|| strcmp(bnadwidth_allocation_method,"faccu")==0
					||strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0
					||strcmp(bnadwidth_allocation_method,"wdis_link")==0|| strcmp(bnadwidth_allocation_method,"dist_link")==0|| strcmp(bnadwidth_allocation_method,"accu_link")==0
					
					
					||strcmp(bnadwidth_allocation_method,"dist_H")==0 || strcmp(bnadwidth_allocation_method,"wdis_H")==0|| strcmp(bnadwidth_allocation_method,"accu_H")==0
					||strcmp(bnadwidth_allocation_method,"wdis_link_H")==0|| strcmp(bnadwidth_allocation_method,"dist_link_H")==0|| strcmp(bnadwidth_allocation_method,"accu_link_H")==0
					
					||strcmp(bnadwidth_allocation_method,"accu_D")==0 ||strcmp(bnadwidth_allocation_method,"dist_D")==0||strcmp(bnadwidth_allocation_method,"wdis_D")==0
					||strcmp(bnadwidth_allocation_method,"accu_link_D")==0 || strcmp(bnadwidth_allocation_method,"accu_app_D")==0
					|| strcmp(bnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0||  strcmp(bnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
					|| strcmp(bnadwidth_allocation_method,"accu_onlylink_D")==0
					||strcmp(bnadwidth_allocation_method,"EDCA_estimation_txop")==0
					)
					{
					
					
					
					if(maxLoad <last_sent_loadRate)
						maxLoad = last_sent_loadRate;
						
					op_stat_write (maxLoad_stat,(double)maxLoad);
					
					if(current_time <EAestimationTime + 10)
						txop_limit_arr [WlanC_AC_VI] = 0.003008;
						
					else
			
					//txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);//hafeedas TXOP equation
					//my equation follows
					
					
					
					//changed to accomodate RTP overhead. replaced appRateBits by last_sent_loadRate
					//txop_limit_arr [WlanC_AC_VI] = (appRateBits/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/ last_sent_physicalRate /*time to transmit a video frame*/
					//								+ Os * appRateBits/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls/last_sent_physicalRate /*time to transmit the overhead in a video freame*/
					//								+ (2* appRateBits/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls - 1)*sifs_time /*SIFS time for transmitting a video frame */
					//								+ appRateBits/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls * (double)TXTIME_CTRL (WLANC_ACK_LENGTH) /*time to ack each packet in the video frame*/
					//								);///2.0;
					
					//has problems
					//txop_limit_arr [WlanC_AC_VI] = (last_sent_loadRate/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/ last_sent_physicalRate /*time to transmit a video frame*/
					//								+ Os * last_sent_loadRate/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls/last_sent_physicalRate /*time to transmit the overhead in a video freame*/
					//								+ (2* last_sent_loadRate/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls - 1)*sifs_time /*SIFS time for transmitting a video frame */
					//								+ last_sent_loadRate/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls * (double)TXTIME_CTRL (WLANC_ACK_LENGTH) /*time to ack each packet in the video frame*/
					//	);
					
					txop_limit_arr [WlanC_AC_VI] = (maxLoad/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/ last_sent_physicalRate /*time to transmit a video frame*/
													+ Os * maxLoad/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls/last_sent_physicalRate /*time to transmit the overhead in a video freame*/
													+ (2* maxLoad/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls - 1)*sifs_time /*SIFS time for transmitting a video frame */
													+ maxLoad/((double)op_stat_local_read(APPL_FRAMERATE_INSTAT))/Ls * (double)TXTIME_CTRL (WLANC_ACK_LENGTH) /*time to ack each packet in the video frame*/
						);
					
					//txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
					
					
					if(fee_lambda_trace_flag)
					{
					sprintf(myString,"I am  %d:TXOP is being calculated",(int)my_address);
			
					op_prg_odb_print_major(myString,OPC_NIL);
				
					sprintf(myString,"I am  %d:appRateBits is %f",(int)my_address,(double) appRateBits);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					
					sprintf(myString,"I am  %d:Os is %f",(int)my_address,(double)Os);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"I am  %d:Ls is %f",(int)my_address,(double)Ls);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"I am  %d:TXOP is calculated as %f",(int)my_address,(double)txop_limit_arr [WlanC_AC_VI]);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					}
					
					
																																					   
					
					}
			
				else if(strcmp(bnadwidth_allocation_method,"wdis_app")==0/*|| strcmp(bnadwidth_allocation_method,"dist_app")==0*/|| strcmp(bnadwidth_allocation_method,"accu_app")==0
					
					
					||strcmp(bnadwidth_allocation_method,"wdis_app_H")==0|| strcmp(bnadwidth_allocation_method,"dist_app_H")==0|| strcmp(bnadwidth_allocation_method,"accu_app_H")==0)
			
					txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				
				else if(strcmp(bnadwidth_allocation_method,"link_only")==0)
					txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
				else if(strcmp(bnadwidth_allocation_method,"accu_D2")==0 || strcmp(bnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0)
					{
					txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);
					txop_limit_arr [WlanC_AC_VI] += last_calculated_droppedB_prob * txop_limit_arr [WlanC_AC_VI];
					}
				else if (strcmp(bnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0)
					{
					txop_limit_arr [WlanC_AC_VI] = (double)ceiling * (Ls+Os)/last_sent_physicalRate + ( 2.0*ceiling-1.0) * sifs_time + ceiling * (double)TXTIME_CTRL (WLANC_ACK_LENGTH);//hafeedas TXOP equation
					}
					
			
				//txop_limit_arr [WlanC_AC_VI] = 0.7;
				op_stat_write (video_TXOP_stat,(double)txop_limit_arr [WlanC_AC_VI]);
				//if(current_time > 22)
					op_stat_write (mac_appRate_stat, appRateBits);// - (last_sent_loadRate - appRateBits) - last_sent_droppedRRate);//this will ubdate applacation rate 
				//else
				//	{
					
				//	op_stat_write (mac_appRate_stat, appRateBits);
					//printf("in the else\n");
				//	}
				op_stat_write (lambda_stat, current_lambda);
				
				
				if(fee_lambda_trace_flag)
					{
					sprintf(myString,"I am  %d:appRateBits is calculated as %f and written to the application rate",(int)my_address, appRateBits);
			
					op_prg_odb_print_major(myString,OPC_NIL);
					}
				
				
				
					if(strcmp(curve,"accu_quality_GT50_withNI")==0 && (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.381,2) * pow(2,-203.8*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.501,2) * pow(2,-203.8*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 3.487E-16 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-4.748) + 0.04805;
						AFR = 3.487E-16 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-4.748) + 0.04805; 
						
						}
					else if(strcmp(curve,"accu_quality_GT_withoutNI")==0 && (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.031,2) * pow(2,-63.03*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.031,2) * pow(2,-63.03*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 1.936E-10 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-3.191) + 0.02927;
						AFR =1.936E-10 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-3.191) + 0.02927; 
						
						}
					
					else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0 && (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.19,2) * pow(2,-102.6*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.19,2) * pow(2,-102.6*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 1.01E-9 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.78) + 0.02325;
						AFR =1.01E-9 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.78) + 0.02325; 
						
						}
				
					else if(strcmp(curve,"accu_quality_GT50_withNI")==0 && (strcmp(bnadwidth_allocation_method,"dist")==0 || strcmp(bnadwidth_allocation_method,"wdis")==0) )//in Mbytes
						{
												
						dFOPT = 3.216 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.3144) + -8.569;
						DFR = 3.216 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.3144) + -8.569; 
						AFOPT= 8.597e-013 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-3.654) + 0.08355;
						AFR = 8.597e-013 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-3.654) + 0.08355; 
						
						}
					else if(strcmp(curve,"accu_quality_GT50_withNI")==0 && strcmp(bnadwidth_allocation_method,"accu")==0)//in Mbytes
						{
												
						dFOPT = pow(4.381,2) * pow(2,-203.8*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.381,2) * pow(2,-203.8*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 8.597e-013 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-3.654) + 0.08355;
						AFR =8.597e-013 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-3.654) + 0.08355; 
						
						}
					
					else if(strcmp(curve,"accu_quality_GT_withoutNI")==0 && strcmp(bnadwidth_allocation_method,"accu")==0)//in Mbytes
						{
												
						dFOPT = pow(4.031,2) * pow(2,-63.03*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.031,2) * pow(2,-63.03*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 1.936E-10 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-3.191) + 0.02927;
						AFR =1.936E-10 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-3.191) + 0.02927; 
						
						}
					else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0 && strcmp(bnadwidth_allocation_method,"accu")==0)//in Mbytes
						{
												
												
						dFOPT = pow(4.19,2) * pow(2,-102.6*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.19,2) * pow(2,-102.6*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 1.01E-9 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.78) + 0.02325;
						AFR =1.01E-9 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.78) + 0.02325; 
						
						}
				
				
					else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 && (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.501,2) * pow(2,-2668*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.501,2) * pow(2,-2668*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 2.158E-8 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-1.807) + 0.04894;
						AFR = 2.158E-8 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-1.807) + 0.04894; 
						
						}
					
					else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 && (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.338,2) * pow(2,-1481*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.338,2) * pow(2,-1481*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT=9.399e-13 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.997) +   0.005403;
						AFR = 9.399e-13 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.997) +   0.005403;
						
						}
					else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 )//&& (strcmp(bnadwidth_allocation_method,"dist2")==0 || strcmp(bnadwidth_allocation_method,"wdis2")==0) )//in Mbytes
						{
												
						dFOPT = pow(4.165,2) * pow(2,-647.7*(appRateBits/8.0/20.0/1024.0/1024.0));//f(x) = a^2 * 2 ^ (-b*x)
						DFR = pow(4.165,2) * pow(2,-647.7*(double)op_stat_local_read(4)/1024.0/1024.0);
						AFOPT= 1.991e-011 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.732) +0.01739;
						AFR = 1.991e-011 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.732) + 0.01739; 
						
						}
						
					
					
					else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0)//in Mbytes
						{
						
						
						dFOPT = 6.783 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.1983) + -23.1;
						DFR = 6.783 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.1983) + -23.1;
						AFOPT= 2.158E-8 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-1.807) + 0.04894;
						AFR = 2.158E-8 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-1.807) + 0.04894; 
						
						}
			
			
					else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0)//in Mbytes
						{
						
						dFOPT = 0.3801 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.1966) + -1.142;
						DFR = 0.3801 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.1966) + -1.142;
						AFOPT=9.399e-13 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.997) +   0.005403;
						AFR = 9.399e-13 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.997) +   0.005403;
						
						
						}
								
					else if(strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//in Mbytes
						{
						
						dFOPT = 6.783 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.1983) + -23.1;
						DFR = 6.783 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.1983) + -23.1;
						AFOPT=2.301E-8 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-1.8) +  0.04801;
						AFR = 2.301E-8 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-1.8) +  0.04801;
						}
			
					else if(strcmp(curve,"accu_quality_cmumit_withNI")==0)
						{
						
						if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
							{
							dFOPT = pow(4.501,2) * pow(2,-2668 * appRateBits/8.0/1024.0/1024.0);
							DFR = pow(4.501,2) * pow(2,-2668 * (double)op_stat_local_read(4)/8.0/1024.0/1024.0);
							}
						else
							{
							dFOPT = 17.93 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.143) + -23.72;
							DFR = 17.93 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.143) + -23.72;
							}
						AFOPT=9.623E-9 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.86) +   0.2071;
						AFR = 9.623E-9 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.86) +   0.2071;
						
						
						}
					else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
						{
						
						if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
							{
							dFOPT = pow(4.501,2) * pow(2,-2668 * appRateBits/8.0/1024.0/1024.0);
							DFR = pow(4.501,2) * pow(2,-2668 * (double)op_stat_local_read(4)/8.0/1024.0/1024.0);
							}
						else
							{
							dFOPT = 17.93 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.143) + -23.72;
							DFR = 17.93 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.143) + -23.72;
							}
						AFOPT=2.138E-6 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.006) +    0.05754;
						AFR = 2.138E-6 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.006) +    0.05754;
									
						}
					
					else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
						{
						
						dFOPT = pow(3.944,2) * pow(2,-94 * appRateBits/8.0/1024.0/1024.0);
						DFR = pow(3.944,2) * pow(2,-94 * (double)op_stat_local_read(4)/8.0/1024.0/1024.0);
							
						
						AFOPT=9.963E-6 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-1.725) +    0.1813;
						AFR = 9.963E-6 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-1.725) +    0.1813;
									
						}
					else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
						{
						
						dFOPT = 9.545 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-0.1845) + -15.41;
						DFR = 9.545 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-0.1845) + -15.41;
							
						
						AFOPT=4.977e-008 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-2.346) +    0.09305;
						AFR = 4.977e-008 * pow((double)op_stat_local_read(4)/1024.0/1024.0,-2.346) +    0.09305;
									
						}
					
				if(myDataFileGenerationFlag == 1 && current_time > EAestimationTime + EACalculationPeriod)
					{
					
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					//fprintf(MyExcecutionTrace,"I am %d at Time %f:Importance=%f,a=%20.20f,b=%f,c=%f,FR=%f,PR=%f,LAMBDA=%10.10f,fee=%f,AR=%f,TXOP=%f,LS=%f,OS=%f,SIFS=%f,BI=%f,ta=%f,load=%f,droppedB=%f,droppedR=%f,sent=%f\n",hoon
					fprintf(MyExcecutionTrace,"%d\t%f\t%f\t%20.20f\t%f\t%f\t%f\t%f\t%10.10f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n",
						(int)my_address,(double)op_sim_time(),importance,accuracyConstant_a , accuracyConstant_b , accuracyConstant_c,(double)op_stat_local_read(APPL_FRAMERATE_INSTAT),last_sent_physicalRate,current_lambda,f,appRateBits,(double)txop_limit_arr [WlanC_AC_VI],Ls,Os,(double)sifs_time,(double)beacon_int,(double)TXTIME_CTRL (WLANC_ACK_LENGTH),(double)last_sent_loadRate,(double)last_sent_droppedBRate,(double)last_sent_droppedRRate,(double)last_sent_sentRate,last_calculated_average_TXOP_displasement,bits_sent_in_the_last_TXOP, TXOP_counter,appRateBits/8.0/20.0,(double)op_stat_local_read(4),dFOPT, DFR, AFOPT, AFR, total_data_sent);
					fclose(MyExcecutionTrace);
					}
				
				}
			
			}
				
		
		
		/* If we belong to an nQBSS and if the AP is PCF enabled, then the		*/
		/* received beacon may indicate the start (or continuation) of a CFP.	*/
		/* If this is the case, then update our NAV until the end of the CFP.	*/
		if ((pk_bbstruct_ptr->cf_par.cfp_count == 0) && 
			((pk_bbstruct_ptr->timestamp + pk_bbstruct_ptr->cf_par.cfp_durremaining) > nav_duration))
			{
			nav_duration = pk_bbstruct_ptr->timestamp + pk_bbstruct_ptr->cf_par.cfp_durremaining;

			/* Set the flag that indicates updated NAV value.					*/
			wlan_flags->nav_updated = OPC_TRUE;			
			}
		
		/* Update nav duration if the received NAV duration is greater than the	*/
		/* current nav duration.							  					*/    	
		else if ((last_rcvd_duration < 32768) && (nav_duration < (last_rcvd_duration + current_time)))
			{
			nav_duration = last_rcvd_duration + current_time;

			/* Set the flag that indicates updated NAV value.					*/
			wlan_flags->nav_updated = OPC_TRUE;			
			}

		/* Destroy beacon body since no longer needed.							*/
		op_pk_destroy (seg_pkptr);
		
		/* Printing out information to ODB.										*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("Beacon frame is received.", OPC_NIL);
		 	}
		
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:I am receiving a beacon packet (type %d) DONE",(int)my_address,(int)rcvd_frame_type);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		}
	
	
	//hoon el receive(mohammad)
	else if	(rcvd_frame_type == WlanC_StateReport)
		{
		
		
		//mohammad
		if(myDebugFlag)
			{
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f I am receiving a stateReport packet (type %d)\n",op_sim_time(),(int)rcvd_frame_type);
			fclose(MyExcecutionTrace);
		
		
			
			}
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:I am receiving a stateReport packet (type %d)",(int)my_address,(int)rcvd_frame_type);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		//end mohammad
		
		/* Address information, sequence control fields, and the	*/
		/* data is extracted from the rcvd packet.					*/
		
		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_HEADER_FD, (const void **) &pk_dhstruct_ptr);

		/*this address should be our address if we are an access point*/
		dest_addr = pk_dhstruct_ptr->address1;			
		
		/* Store the address of the station transmitting the stateReport.		*/
		remote_sta_addr = pk_dhstruct_ptr->address2;	
		rcvd_sta_bssid = pk_dhstruct_ptr->address3;		

		/* Store the duration information.							*/
		last_rcvd_duration = pk_dhstruct_ptr->duration;
				
		//not needed
		/* If roaming enabled, update the reliability of the signal	*/
		/* from the AP that sent this Beacon, which we received		*/
		/* successfully.											*/
		//if (roam_state_ptr->enable_roaming && roam_state_ptr->scan_type == WlanC_Scan_Type_Beacon)
			//wlan_ap_reliability_eval (wlan_rcvd_frame_ptr, OPC_TRUE, roam_state_ptr);
		
		//not needed
		/* If the STA is scanning for a new BSS, then save the BSS ID of the beacon transmitter. */
		//if (roam_state_ptr->scan_mode)
			//eval_bss_id = rcvd_sta_bssid;

		/* For now there is no ack for stateReoprt packet. this thing may be changed		*/
		fresp_to_send = WlanC_None; 
		
		/* Extracting the stateReport Body packet.						*/
		/*Loren
		printf("I am  %d: getting seg_pkptr stateReport\n",(int)my_address);
		*/
		op_pk_fd_get_pkt (wlan_rcvd_frame_ptr, WLANC_DATA_BODY_FD, &seg_pkptr);

		/* Extracting the stateReport Body structure from packet.		*/
		
		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (seg_pkptr, WLANC_STATEREPORT_BODY_FD, (const void **) &pk_srstruct_ptr);

		if (expected_frame_type != WlanC_None) 
			{
			/* Since the station did not receive the expected frame	*/
			/* it has to retransmit the packet.						*/

			/* Increment the short retry count if the transmission	*/
			/* of an RTS frame or a data frame smaller than RTS/CTS	*/
			/* threshold has failed; otherwise increment the long	*/
			/* retry count.											*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr [cur_tx_ac] += 1;
			else
				lrc_arr	[cur_tx_ac] += 1;
			
			/* Also reset the rts_sent flag since we will recontend.*/
			wlan_flags->rts_sent = OPC_FALSE;
			}
			
		/*If stateReport is intended for this BSS and it is intended for us , store all the data locally to do the calculations.	*/
		//for now i have no idea how to do the calculation and when
		if (rcvd_sta_bssid == bss_id && dest_addr == my_address) 
			{
			
			
			
			/* Update received management traffic statistics. Write the	*/
			/* appropriate values for start and end of the reception.	*/
			op_stat_write_t (mgmt_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
			op_stat_write (mgmt_traffic_rcvd_handle_inbits, 0.0);
			op_stat_write_t (mgmt_traffic_rcvd_handle, 1.0, rx_start_time);
			op_stat_write (mgmt_traffic_rcvd_handle, 0.0);
		
		
			++received_stateReport_count;
			op_stat_write_t (received_stateReport_count_stat, received_stateReport_count,op_sim_time ());
			
			if(myDebugFlag)
				{
				sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
				MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			
				fprintf(MyExcecutionTrace,"Time %f I received stateReport packet from %d in bss %d and it is for me\n",op_sim_time(),remote_sta_addr,rcvd_sta_bssid);
				fclose(MyExcecutionTrace);
			
				
				}
			if(myStringDebug)
				{
				sprintf(myString,"I am %d: I received stateReport packet from %d in bss %d and it is for me",(int)my_address,(int)remote_sta_addr,(int)rcvd_sta_bssid);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
			/* Set stateReport interval */
			stateReport_int = pk_srstruct_ptr->pk_stateReport_intv;
			
			//get the entry of the sending station from the peers hash table to ubdate its information
			
			peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_remove (peer_info_hash_tbl, (void *) &remote_sta_addr);
			
			if(peer_info_ptr == PRGC_NIL)
				op_sim_end ("receive stateReport:peer info are not available. chech the code that add to the hash table", "", "", ""); 
			
			peer_info_ptr -> peer_addr 		= remote_sta_addr;
			peer_info_ptr -> peer_a 				= pk_srstruct_ptr -> pk_a;
			peer_info_ptr -> peer_b 				= pk_srstruct_ptr -> pk_b;
			peer_info_ptr -> peer_c 				= pk_srstruct_ptr -> pk_c;
			peer_info_ptr -> peer_importance		= pk_srstruct_ptr -> pk_importance;
			peer_info_ptr -> peer_physicalRate 	= pk_srstruct_ptr -> pk_physicalRate;
			peer_info_ptr -> peer_frameRate 		= pk_srstruct_ptr -> pk_frameRate;
			peer_info_ptr -> peer_averageProtocolOverhead = pk_srstruct_ptr->pk_averageProtocolOverhead;
			peer_info_ptr -> peer_droppedBRate = pk_srstruct_ptr->pk_droppedBRate;
			
			peer_info_ptr -> peer_droppedRRate = pk_srstruct_ptr->pk_droppedRRate;
			
			peer_info_ptr -> peer_TXOP = pk_srstruct_ptr->pk_TXOP;
			peer_info_ptr -> peer_appRate = pk_srstruct_ptr-> pk_appRate;
			
			frameSizeOfNode [(int)remote_sta_addr] = peer_info_ptr -> peer_appRate/peer_info_ptr -> peer_frameRate;
			
			
			prg_bin_hash_table_item_insert (peer_info_hash_tbl, (void *) &remote_sta_addr, peer_info_ptr, &dummy_ptr);
			
			if(myStringDebug)
				{
			
			sprintf(myString,"I am  %d:importance of %d is recieved via stateReport and it is %f",(int)my_address,(int)remote_sta_addr,peer_info_ptr -> peer_importance);
			op_prg_odb_print_major(myString,OPC_NIL);
			
			
			sprintf(myString,"I am  %d:number of items in the hash table before the operation is %d",(int)my_address,(int)prg_bin_hash_table_num_items_get(peer_info_hash_tbl));
			op_prg_odb_print_major(myString,OPC_NIL);
			sprintf(myString,"I am  %d:number of items in the hash table after the operation is %d",(int)my_address,(int)prg_bin_hash_table_num_items_get(peer_info_hash_tbl));
			op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			
			
			/* moved to beacon send
			if(current_time - last_DataRate_reset_time > calculationPeriod)
				{
				
				for(i= 0; i < prg_bin_hash_table_num_items_get(peer_info_hash_tbl);i++)
					{
					if(i==0)
						continue;
					i_address = (OpT_Int64)i;
					
					peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &i_address);
					
					
					if(myStringDebug)
						{
						sprintf(myString,"I am  %d:Data Rate of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamDataRate[i]/(double) (current_time-last_DataRate_reset_time));
						op_prg_odb_print_major(myString,OPC_NIL);
					
					
						sprintf(myString,"I am  %d:Accuracy of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamAccuracy[i]);
						op_prg_odb_print_major(myString,OPC_NIL);
					
						sprintf(myString,"I am  %d:Distortion of the stream recieved from station %d is %f",(int)my_address,i,(double)peerStreamDistortion[i]);
						op_prg_odb_print_major(myString,OPC_NIL);
						}
					
					if(myDataFileGenerationFlag = 1)
						{
						sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\%s_traceFile_node_%d.txt",bnadwidth_allocation_method,my_address);
						MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
						fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f\n",
							(double)op_sim_time(),(int)i_address,(double)peerStreamDataRate[i]/(double) (current_time-last_DataRate_reset_time),(double)peerStreamAccuracy[i],(double)peerStreamDistortion[i]);
						fclose(MyExcecutionTrace);
						}
					
					dataRateSum += peerStreamDataRate[i];
					accuracySum +=peerStreamAccuracy[i];
					
					weighted_sum += peerStreamAccuracy[i]*peer_info_ptr -> peer_importance;
					
					distortionSum +=peerStreamDistortion[i];
					
					peerStreamDataRate[i] = 0;
					peerStreamAccuracy[i] = 0;
					peerStreamDistortion[i] = 0;
					}
							
				
				if(myStringDebug)
					{
					sprintf(myString,"I am  %d:weighted Accuracy sum is %f",(int)my_address,(double)weighted_sum);
					op_prg_odb_print_major(myString,OPC_NIL);
			
					sprintf(myString,"I am  %d:Average Data Rate of the stream recievedis %f",(int)my_address,(double)dataRateSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1)/(double) (current_time-last_DataRate_reset_time));
					op_prg_odb_print_major(myString,OPC_NIL);
					
					//op_sim_end ("mesh rade yetba3", "", "", "");
			
					sprintf(myString,"I am  %d:Average Accuracy of the stream recieved is %f",(int)my_address,(double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
					op_prg_odb_print_major(myString,OPC_NIL);
				
					sprintf(myString,"I am  %d:Average Distortion of the stream recieved is %f",(int)my_address,(double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
					op_prg_odb_print_major(myString,OPC_NIL);
					}
				
				if(myDataFileGenerationFlag = 1)
					{
					sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\%s_traceFile_node_%d.txt",bnadwidth_allocation_method,my_address);
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					fprintf(MyExcecutionTrace,"AVERAGE At Time %f:AverageDaraRate=%f,AverageAccuracy=%f,AverageDistortion=%f,WeightedAccuracy=%f\n",
						(double)op_sim_time(),(double)dataRateSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1)/(double) (current_time-last_DataRate_reset_time),(double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1),(double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1),(double)weighted_sum);
					fclose(MyExcecutionTrace);
					}
			
				op_stat_write (average_accuracy, (double)accuracySum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				op_stat_write (average_distortion, (double)distortionSum/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				
				op_stat_write (weighted_accuracy_sum, (double)weighted_sum);
			
				op_stat_write (average_stream_DataRate, (double)dataRateSum/(current_time - last_DataRate_reset_time)/(prg_bin_hash_table_num_items_get(peer_info_hash_tbl)-1));
				
				
			
				last_DataRate_reset_time = current_time;
				dataRateSum = 0;
				accuracySum =0;
				distortionSum =0;
				weighted_sum = 0;
			
				}*/
				
	
			}
		
		
	
		/* Update nav duration if the received NAV duration is greater than the	*/
		/* current nav duration.							  					*/    	
		if ((last_rcvd_duration < 32768) && (nav_duration < (last_rcvd_duration + current_time)))
			{
			nav_duration = last_rcvd_duration + current_time;
			
			/* Set the flag that indicates updated NAV value.					*/
			wlan_flags->nav_updated = OPC_TRUE;			
			}

		/* Destroy stateReport body since no longer needed.							*/
		op_pk_destroy (seg_pkptr);
		
		/* Printing out information to ODB.										*/
		if (wlan_trace_active == OPC_TRUE)
			{
			op_prg_odb_print_major ("StateReport frame is received.", OPC_NIL);
		 	}
		
		
		if(myStringDebug)
			{
			sprintf(myString,"I am %d:I am receiving a stateReport packet (type %d) DONE",(int)my_address,(int)rcvd_frame_type);
			op_prg_odb_print_major(myString,OPC_NIL);
			}
		
		
		}
	
		

	else if	(rcvd_frame_type == WlanC_Rts)
		{
		/* Update received control traffic statistics. Write the		*/
		/* appropriate values for start and end of the reception.		*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		/* Access the header fields of the control frame.				*/

		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr);			
		dest_addr = pk_chstruct_ptr->rx_addr;
		remote_sta_addr = pk_chstruct_ptr->tx_addr;
			
		/* Store the duration information.								*/
		last_rcvd_duration = pk_chstruct_ptr->duration;
				
		/* Is the RTS frame destined to us?								*/
		if (my_address == dest_addr)
			{
			
			++received_RTS_count;//mohammad
			op_stat_write_t (received_RTS_count_stat, received_RTS_count,op_sim_time ());//mohammad
			
			
			/* RTS is destined to us. We will respond with a CTS if our	*/
			/* NAV duration is not larger than the current simulation	*/
			/* time.													*/
			if (current_time >= nav_duration)
				{
				/* Only if the receiver is idle do we respond to the 	*/
				/* RTS frame.											*/
				if (wlan_flags->receiver_busy == OPC_FALSE)
					{
					/* Set the frame response field to CTS.				*/
					fresp_to_send     = WlanC_Cts;
					response_sta_addr = remote_sta_addr;
			
					/* Printing out information to ODB.					*/
					if (wlan_trace_active == OPC_TRUE)
						op_prg_odb_print_major ("RTS is received and CTS will be transmitted.", OPC_NIL);
					}
				
				/* Printing out information to ODB.						*/
				else if (wlan_trace_active == OPC_TRUE)
					{
					op_prg_odb_print_major ("RTS is received and ignored due to busy receiver.", OPC_NIL);
					}
				}
			else if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("RTS is received and ignored due to active NAV.", OPC_NIL);
			}
		else
			{
			/* RTS is not destined to us. Update nav_duration if the	*/
			/* received duration is greater than the current			*/
			/* nav_duration.											*/
			if (nav_duration < (last_rcvd_duration + current_time))
				{
				double tmp_drate;
			
				nav_duration = last_rcvd_duration + current_time;

				/* Set the flag that indicates updated NAV value.		*/
				wlan_flags->nav_updated = OPC_TRUE;
			
				/* Since we are updating our NAV based on an RTS we		*/
				/* received, we can reset it if we don't detect any		*/
				/* activity on the medium for a "2 SIFS + 2 SLOT +		*/
				/* CTS_TX" time, as described in section 9.2.5.4. Hence	*/
				/* schedule	a self interrupt for NAV reset time.		*/
				tmp_drate = rcvd_frame_drate;
				nav_reset_evh = op_intrpt_schedule_self (current_time + 2 * sifs_time + TXTIME_CTRL_DR (WLANC_CTS_LENGTH, tmp_drate) + 2 * slot_time,
														 WlanC_NAV_Reset_Time);
			
				/* Printing out information to ODB.						*/
				if (wlan_trace_active == OPC_TRUE)
					op_prg_odb_print_major ("RTS is received and NAV updated.", OPC_NIL);
				}				
			else if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("RTS is received and discarded.", OPC_NIL);
			}			
					
		if (expected_frame_type != WlanC_None)
			{				
			/* Since the station did not receive the expected frame it	*/
			/* has to retransmit the packet. Increment the appropriate	*/
			/* retry count. Increment the short retry count if the		*/
			/* transmission	of an RTS frame or a data frame smaller		*/
			/* than RTS/CTS	threshold has failed; otherwise increment	*/
			/* the long	retry count.									*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr	[cur_tx_ac] += 1;
			else
				lrc_arr [cur_tx_ac] += 1;
			
			/* Also reset the rts_sent flag since we will recontend.	*/
			wlan_flags->rts_sent = OPC_FALSE;
				
			/* Reset the expected frame type variable since we will		*/
			/* retransmit.												*/
			fresp_to_send = WlanC_None;
			}
		}		
	
	else if	(rcvd_frame_type == WlanC_Cts)
		{
		/* Update received control traffic statistics. Write the		*/
		/* appropriate values for start and end of the reception.		*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		/* Access the fields of the CTS message.							*/
		
		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr);
		dest_addr = pk_chstruct_ptr->rx_addr;

		/* Store the duration information.									*/
		last_rcvd_duration = pk_chstruct_ptr->duration;
				
		/* If the frame is destined for this station and the station is		*/
		/* expecting CTS frame then set appropriate indicators.				*/
		if ((dest_addr == my_address) && (expected_frame_type == rcvd_frame_type) &&
			(wlan_flags->receiver_busy == OPC_FALSE))
			{
			/* The receipt of CTS frame indicates that RTS is successfully	*/
			/* transmitted and the station can now respond with Data frame.	*/
			fresp_to_send = WlanC_QoS_Data;

			/* Reset the CW due to successfully received CTS.				*/
			cw_arr [cur_tx_ac] = cwmin_arr [cur_tx_ac];
			
			/* Set the flag indicating that Rts is successfully transmitted.*/
			wlan_flags->rts_sent = OPC_TRUE;

			/* Reset the transmitted frame type information, since the		*/
			/* expected response is received.								*/
			txframe_type = WlanC_None;
		
			/* Printing out information to ODB.								*/
			if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("CTS is received in response to transmitted RTS.", OPC_NIL);
			}
		else
			{
			/* Printing out information to ODB.								*/
			if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("CTS is received and discarded.", OPC_NIL);

			/* Check whether we were expecting another frame. If yes then	*/
			/* we need to retransmit the frame for which we were expecting	*/
			/* a reply.														*/
			if (expected_frame_type != WlanC_None)
				{				
				/* Since the station did not receive the expected frame it	*/
				/* has to retransmit the packet. Increment the appropriate	*/
				/* retry count. Increment the short retry count if the		*/
				/* transmission	of an RTS frame or a data frame smaller		*/
				/* than RTS/CTS	threshold has failed; otherwise increment	*/
				/* the long	retry count.									*/
				if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
					src_arr [cur_tx_ac] += 1;
				else
					lrc_arr [cur_tx_ac] += 1;
					
				/* Also reset the rts_sent flag since we will recontend.	*/
				wlan_flags->rts_sent = OPC_FALSE;
				}
			}
						
		/* If network allocation vector is less than the received duration	*/
		/* value then update its value, unless CTS is addressed to us.		*/
		if (nav_duration < (last_rcvd_duration + current_time) && dest_addr != my_address)
			{
			nav_duration = last_rcvd_duration + current_time;				
			
			/* Set the flag that indicates updated NAV value.				*/
			wlan_flags->nav_updated = OPC_TRUE;
			}			
		}
	
	else if	(rcvd_frame_type == WlanC_Ack)
		{
		
		
		if(LorenDebugFlag)
		{
			printf("calling op_pk_fd_access_read_only_ptr 16.\n");
		}
		
		//Loren: Function gets called from here in normal operation.	
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr); 		
		dest_addr = pk_chstruct_ptr->rx_addr;
		
		/* Store the duration information.									*/
		last_rcvd_duration = pk_chstruct_ptr->duration;
				
		/* Update received control traffic statistics. Write the			*/
		/* appropriate values for start and end of the reception.			*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		/* If an ACK is expected, and a DCF ACK is received addresses to	*/
		/* us, then process the received ACK. In very rare cases, even		*/
		/* though we are expecting a BA from the peer, it may respond with	*/
		/* an ACK (if it has torn down the BA agreement due to inactivity). */
		/* Hence, also consider this possibility.							*/
		if (dest_addr == my_address && (expected_frame_type == WlanC_Ack || expected_frame_type == WlanC_BA))
			{
			
			/*if the recieved AcK is for a data frame, calculate physical bit rate */
			//code to calculate over period
			if(last_tx_frtype_arr [cur_tx_ac] == WlanC_QoS_Data )//mohammad 
				{
				data_frames_sent_in_the_last_stateREport_int_count ++;
				
				if(current_time - last_sent_video_frame_time - sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH) > 0 && data_frames_sent_in_the_last_stateREport_int_count > 0)
					{
					
					//sprintf (myString, "I am %d: ack received, dataRate = %f,data_frames_sent_in_the_last_stateREport_int_count = %d, last_sent_video_frame_size_without_header = %f,time taken to send packet = %f, temp_ph_rate = %f\n",(int)my_address ,last_sent_video_frame_size_without_header /(double)(current_time - last_sent_video_frame_time- sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH)),data_frames_sent_in_the_last_stateREport_int_count,last_sent_video_frame_size_without_header,current_time - last_sent_video_frame_time - sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH),temp_ph_rate);
					//op_prg_odb_print_major (myString, OPC_NIL);
					
					//temp_ph_rate =  (temp_ph_rate * (double)(data_frames_sent_in_the_last_stateREport_int_count-1) + (last_sent_video_frame_size_without_header )/(double)(current_time - last_sent_video_frame_time- sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH)))/(double) data_frames_sent_in_the_last_stateREport_int_count;
					//temp_ph_rate += last_sent_video_frame_size_without_header /(double)(current_time - last_sent_video_frame_time- sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH));//data physical rate
 
					temp_ph_rate += last_sent_video_frame_size /(double)(current_time - last_sent_video_frame_time- sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH));
					}
				
				//op_stat_write (physicalRate_stat, temp_ph_rate);
				
				}
			
			/*if(last_tx_frtype_arr [cur_tx_ac] == WlanC_QoS_Data )//mohammad 
				{
				
				if(current_time - last_sent_video_frame_time - sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH) > 0 && data_packet_sent_count > 0)
				temp_ph_rate =  (temp_ph_rate * (double)(data_packet_sent_count-1) + (last_sent_video_frame_size + WLANC_ACK_LENGTH)/(double)(current_time - last_sent_video_frame_time - sifs_time - TXTIME_CTRL (WLANC_ACK_LENGTH)))/(double) data_packet_sent_count;
				//op_stat_write (physicalRate_stat, temp_ph_rate);
				
				}*/
			
			
			
			/* Printing out information to ODB.								*/
			if (wlan_trace_active == OPC_TRUE)
				{
				sprintf (msg_string, "ACK received for packet " OPC_PACKET_ID_FMT ".", served_pk_id_arr [cur_tx_ac]);
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}			
			
			/* Write the number of retransmission attempts into its			*/
			/* statistics.													*/
			total_retries = (double) (src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac]);
			op_stat_write (retrans_handle,        total_retries);
			op_stat_write (global_retrans_handle, total_retries);
			
			/* Reset the retry counts and the retry bit flag as the			*/
			/* expected frame is received.									*/
			if (total_retries > 0.0)
				{
				src_arr [cur_tx_ac] = 0;
				lrc_arr [cur_tx_ac] = 0;
				}
			
			/* If the ACKed frame was a BAR, then start inactivity timer,	*/
			/* to tear down the BA agreement if we don't receive a BA.		*/
			if (txframe_type == WlanC_BAR)
				{
				/* Access the information record of the frame.				*/
				hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [cur_tx_ac], OPC_LISTPOS_HEAD);
			
				/* Access the BA state information of the BAR.				*/
				ba_state_info_ptr = hld_info_ptr->addr1_info_ptr->ba_state_ptr_arr [hld_info_ptr->up];
				
				/* If used, start the timer.								*/	
				if (tc_config_arr [hld_info_ptr->up].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
					{
					op_ev_state_install (ba_state_info_ptr, OPC_NIL);
					ba_state_info_ptr->inactivity_evh = 
						op_intrpt_schedule_self (current_time + tc_config_arr [hld_info_ptr->up].ba_timeout_value, WlanC_BA_Inactive_Tout_Init);				
					op_ev_state_install (OPC_NIL, OPC_NIL);
					}
				
				/* Reset the BAR transmission timer since it is ACKed, and	*/
				/* record the current time.									*/
				ba_state_info_ptr->bar_tx_time  = 0.0;
				ba_state_info_ptr->bar_ack_time = current_time;
				
				/* Set the flag indicating that we are awaiting a delayed	*/
				/* BA.														*/
				ba_state_info_ptr->awaiting_delayed_ba = OPC_TRUE;
				}
			
			/* Else if the ACKed frame was an ADDBA request, start the		*/
			/* corresponding ADDBA response timeout timer.					*/
			else if (txframe_type == WlanC_Action)
				{
				/* Access the information record of the MMPDU.				*/
				hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [cur_tx_ac], OPC_LISTPOS_HEAD);
			
				/* Is this MMPDU an ADDBA request?							*/
				if (hld_info_ptr->mmpdu_cat_action_tid >>  WLANC_MMPDU_TID_FD_SIZE == 
					(WlanC_Category_Block_ACK << WLANC_MMPDU_ACTION_FD_SIZE) + WlanC_Action_ADDBA_Request)
					{
					/* Access the BA state information of the ADBBA request.*/
					ba_state_info_ptr = hld_info_ptr->addr1_info_ptr->ba_state_ptr_arr [hld_info_ptr->mmpdu_cat_action_tid & WLANC_MMPDU_TID_BIT_MASK];
					
					/* Schedule an interrupt for the expiry of the timer.	*/
					/* Check the validity of the state information, since	*/
					/* in extreme rare cases with noisy environment and		*/
					/* very short inactivity timeout value, we may fail to	*/
					/* receive an earlier ACK from the peer, but then		*/
					/* receive an ADDBA response, even a DELBA, while we	*/
					/* are still trying to retransmit our ADDBA request.	*/
					if (ba_state_info_ptr != OPC_NIL && ba_state_info_ptr->status != WlanC_BA_Established)
						{
						op_ev_state_install (ba_state_info_ptr, OPC_NIL);
						ba_state_info_ptr->addba_resp_timeout_evh = op_intrpt_schedule_self (current_time + ADDBA_FAILURE_TIMEOUT, WlanC_ADDBA_Failure_Timeout);				
						op_ev_state_install (OPC_NIL, OPC_NIL);
						}
					}
				}
			
			/* Decrement number of fragment count because one fragment is	*/
			/* successfully transmitted.									*/
			num_fragments_arr [cur_tx_ac] -= 1;				
			
			/* Is this the initial frame of the current TXOP?				*/
			if (wlan_flags->not_first_in_txop == OPC_FALSE)
				{
				/* This is the initial frame. Are there any more fragments	*/
				/* to send?													*/
				if (num_fragments_arr [cur_tx_ac] == 0)
					{
					/* We have sent the last fragment of the first frame.	*/
					/* Start the transmission of the next frame if we are	*/
					/* allowed due to sufficient time left in our TXOP.		*/
					if (wlan_flags->txop_on == OPC_TRUE)
						{
						if (wlan_trace_active)
							op_prg_odb_print_major ("Complete trasmission of the first frame. Time is still left in our TXOP.", OPC_NIL);

						fresp_to_send = WlanC_QoS_Data;						
						wlan_flags->not_first_in_txop = OPC_TRUE;

						/* Reset the CW since we have a successful			*/
						/* transmission within the TXOP.					*/
						cw_arr [cur_tx_ac] = cwmin_arr [cur_tx_ac];
						}
					else
						{
						/* We are done with our transmissions in the 		*/
						/* current TXOP. Reset the RTS, which may have set.	*/
						wlan_flags->rts_sent = OPC_FALSE;
						
						/* Set the contention window flag. Since the ACK	*/
						/* for the last fragment indicates a successful		*/
						/* transmission of the entire data, we need to		*/
						/* back-off for a contention window	period.			*/
						wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
						}
					
					/* Remove the higher layer packet from the queue since	*/
					/* its transmission is complete.						*/
					wlan_hcf_hlpk_dequeue (cur_tx_ac, 0);
					}
				else
					{
					/* Send the next fragment of the initial frame if there	*/
					/* is no activity on the medium.						*/
					if (wlan_flags->receiver_busy == OPC_FALSE)
						fresp_to_send = WlanC_QoS_Data;
					else
						{
						/* Our fragment was ACKed, but medium is busy. So	*/
						/* we will defer and re-contend instead of sending	*/
						/* the next fragment after SIFS. Reset the RTS flag	*/
						/* which may be set.								*/
						wlan_flags->rts_sent = OPC_FALSE;
						}

					/* Reset the CW since we have a successful transmission	*/
					/* within the TXOP.										*/
					cw_arr [cur_tx_ac] = cwmin_arr [cur_tx_ac];
					}
				}
			else
				{
				/* This is not the initial frame of the TXOP. We will send	*/
				/* another fragment or start the transmission of another	*/
				/* frame only if there is time left in our TXOP.			*/
				if (wlan_flags->txop_on == OPC_TRUE)
					{
					/* We will continue with our transmissions.				*/					
					if (wlan_trace_active)
						op_prg_odb_print_major ("Complete trasmission of the subsequent frame or frags. Time is still left in our TXOP.", OPC_NIL);
					
					fresp_to_send = WlanC_QoS_Data;
					}
				else
					{
					/* We are done with our transmissions in the current	*/
					/* TXOP. Reset the RTS, which may have set.				*/
					wlan_flags->rts_sent = OPC_FALSE;
					
					/* Set the contention window flag. Since the TXOP 		*/
					/* completed successfully, we need to back-off for a	*/
					/* contention window period.							*/
					wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
					}
				
				/* If the ACK was for the last fragment of the current		*/
				/* frame, then remove the higher layer packet from the		*/
				/* queue since its transmission is complete.				*/
				if (num_fragments_arr [cur_tx_ac] == 0)
					wlan_hcf_hlpk_dequeue (cur_tx_ac, 0);
				}
			
			/* Data packet is successfully delivered to remote station,		*/
			/* since no further retransmission is needed the copy of the	*/
			/* data packet will be destroyed.								*/
			op_pk_destroy (mpdu_retx_copy_arr [cur_tx_ac]);
			mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
			
			/* Reset the last transmitted frame type information, which is	*/
			/* used in the frame discard function called at the end of this	*/
			/* function.													*/
			txframe_type = WlanC_None;
			}
		
		else
			{
			/* Printing out information to ODB.								*/
			if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("ACK is received and discarded.", OPC_NIL);

			/* Check whether we were expecting another frame. If yes then	*/
			/* we need to retransmit the frame for which we were expecting	*/
			/* a reply.														*/
			if (expected_frame_type != WlanC_None)
				{				
				/* Since the station did not receive the expected frame it	*/
				/* has to retransmit the packet. Increment the appropriate	*/
				/* retry count. Increment the short retry count if the		*/
				/* transmission	a frame smaller than RTS/CTS threshold has	*/
				/* failed; otherwise increment the long retry count.		*/
				if (wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac])
					lrc_arr [cur_tx_ac] += 1;
				else
					src_arr [cur_tx_ac] += 1;
					
				/* Also reset the rts_sent flag since we will recontend.	*/
				wlan_flags->rts_sent = OPC_FALSE;
				}
			}

		/* If network allocation vector is less than the received duration		*/
		/* value then update its value, unless the packet is destined to us.	*/
		if (dest_addr != my_address && nav_duration < (last_rcvd_duration + current_time))
			{
			nav_duration = last_rcvd_duration + current_time;

			/* Set the flag that indicates updated NAV value.					*/
			wlan_flags->nav_updated = OPC_TRUE;
			}		
		}

	else if (rcvd_frame_type == WlanC_BAR)
		{
		/* We received a block ACK request message. Update the received control	*/
		/* traffic statistics.													*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		/* Access the header fields of the control frame.						*/
		//loren: not normally called from here.
		//printf("calling op_pk_fd_access_read_only_ptr 17.\n");
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr);

		/* Store the duration information.										*/
		last_rcvd_duration = pk_chstruct_ptr->duration;		
		
		/* Was the BAR message sent to us?										*/
		if (pk_chstruct_ptr->rx_addr == my_address)
			{
			/* Process the block ACK request and respond with a block ACK or	*/
			/* ACK, based on the block ACK policy agreed with the peer.			*/
			wlan_hcf_bar_process (pk_chstruct_ptr->tx_addr, wlan_rcvd_frame_ptr);
			}
		else
			{
			/* BAR is not destined to us. Update nav_duration if the received	*/
			/* duration is greater than the current nav_duration.				*/
			if (nav_duration < (last_rcvd_duration + current_time))
				{
				nav_duration = last_rcvd_duration + current_time;

				/* Set the flag that indicates updated NAV value.				*/
				wlan_flags->nav_updated = OPC_TRUE;
			
				/* Printing out information to ODB.								*/
				if (wlan_trace_active == OPC_TRUE)
					op_prg_odb_print_major ("BAR is received and NAV updated.", OPC_NIL);
				}				
			else if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("BAR is received and discarded.", OPC_NIL);
			}			
					
		if (expected_frame_type != WlanC_None)
			{				
			/* Since the station did not receive the expected frame it has to	*/
			/* retransmit the packet. Increment the appropriate	retry count.	*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr	[cur_tx_ac] += 1;
			else
				lrc_arr [cur_tx_ac] += 1;
			
			/* Also reset the rts_sent flag since we will recontend.			*/
			wlan_flags->rts_sent = OPC_FALSE;
				
			/* Only if the BAR is not for us, reset the expected frame type 	*/
			/* variable since we will retransmit.								*/
			if (pk_chstruct_ptr->rx_addr != my_address)
				fresp_to_send = WlanC_None;
			}
		}
	
	else if (rcvd_frame_type == WlanC_BA)
		{
		/* We received a block ACK message. Update the received control traffic	*/
		/* statistics.															*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		/* Access the header fields of the control frame.						*/
		//loren: not normally called from here.
		//printf("calling op_pk_fd_access_read_only_ptr 18.\n");
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr);

		/* Store the duration information.										*/
		last_rcvd_duration = pk_chstruct_ptr->duration;
		
		/* Was the BA message sent to us?										*/
		if (pk_chstruct_ptr->rx_addr == my_address)
			{	
			/* If this is a delayed block ACK then we need to respond with an	*/
			/* ACK message.														*/
			if (expected_frame_type != WlanC_BA)
				{
				fresp_to_send     = WlanC_Ack;
				response_sta_addr = pk_chstruct_ptr->tx_addr;
				}
			else
				{
				/* We received the expected response to our BAR.				*/
				expected_frame_type = WlanC_None;
				
				/* Write the number of retransmission attempts into its			*/
				/* statistics.													*/
				total_retries = (double) (src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac]);
				op_stat_write (retrans_handle,        total_retries);
				op_stat_write (global_retrans_handle, total_retries);
				
				/* Reset the retry counts and the retry bit flag as the			*/
				/* expected frame is received.									*/
				if (total_retries > 0.0)
					{
					src_arr [cur_tx_ac] = 0;
					lrc_arr [cur_tx_ac] = 0;
					}
				
				/* Check the flag that indicates whether there is time for the	*/
				/* next transmission in TXOP.									*/
				if (wlan_flags->txop_on == OPC_TRUE)
					{
					if (wlan_trace_active)
						op_prg_odb_print_major ("Received BA. Time is still left in our TXOP.", OPC_NIL);
							
					fresp_to_send = WlanC_QoS_Data;
					wlan_flags->not_first_in_txop = OPC_TRUE;
					
					/* Reset the AC's CW since we had a successful transmission	*/
					/* within the TXOP.											*/
					cw_arr [cur_tx_ac] = cwmin_arr [cur_tx_ac];
					}
				else
					{
					/* We are done with our transmissions in the current TXOP.	*/
					/* Reset the RTS, which may have set.						*/
					wlan_flags->rts_sent = OPC_FALSE;
					
					/* Set the contention window flag. Since the ACK for the	*/
					/* last fragment indicates a successful	transmission of the	*/
					/* entire data, we need to back-off for a contention window	*/
					/* period.													*/
					wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
					}
				
				/* Dequeue the entity for the BAR in the AC's transmission		*/
				/* buffer.														*/
				wlan_hcf_hlpk_dequeue (cur_tx_ac, 0);
				
				/* Destroy the copy of the message we kept for retransmissions.	*/
				op_pk_destroy (mpdu_retx_copy_arr [cur_tx_ac]);
				mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
				
				/* Reset the last transmitted frame type information, which is	*/
				/* used in the frame discard function called at the end of this	*/
				/* function.													*/
				txframe_type = WlanC_None;
				}
			
			/* Process the block ACK.											*/
			wlan_hcf_ba_process (pk_chstruct_ptr->tx_addr, wlan_rcvd_frame_ptr);
			}
		else
			{
			/* BA is not destined to us. Update nav_duration if the received	*/
			/* duration is greater than the current nav_duration.				*/
			if (nav_duration < (last_rcvd_duration + current_time))
				{
				nav_duration = last_rcvd_duration + current_time;

				/* Set the flag that indicates updated NAV value.				*/
				wlan_flags->nav_updated = OPC_TRUE;
			
				/* Printing out information to ODB.								*/
				if (wlan_trace_active == OPC_TRUE)
					op_prg_odb_print_major ("Block ACK is received and NAV updated.", OPC_NIL);
				}				
			else if (wlan_trace_active == OPC_TRUE)
				op_prg_odb_print_major ("Block ACK is received and discarded.", OPC_NIL);
			}			
					
		if (expected_frame_type != WlanC_None)
			{				
			/* Since the station did not receive the expected frame it has to	*/
			/* retransmit the packet. Increment the appropriate	retry count.	*/
			if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
				src_arr	[cur_tx_ac] += 1;
			else
				lrc_arr [cur_tx_ac] += 1;
			
			/* Also reset the rts_sent flag since we will recontend.			*/
			wlan_flags->rts_sent = OPC_FALSE;
				
			/* Reset the expected frame type variable since we will retransmit.	*/
			fresp_to_send = WlanC_None;
			}
		}

	/* Next check whether we received an action MMPDU.							*/
	else if (rcvd_frame_type == WlanC_Action)
		{
		/* Update received management traffic statistics. Write the appropriate	*/
		/* values for start and end of the reception.							*/
		op_stat_write_t (mgmt_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (mgmt_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (mgmt_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (mgmt_traffic_rcvd_handle, 0.0);
		
		/* Address information, sequence control fields, and the data is		*/
		/* extracted from the received packet.									*/\
		
		//loren: not normally called from here.
		//printf("calling op_pk_fd_access_read_only_ptr 19.\n");
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_HEADER_FD, (const void **) &pk_dhstruct_ptr);

		/* Obtain the destination this packet id addressed to.					*/
		dest_addr       = pk_dhstruct_ptr->address1;	
		remote_sta_addr = pk_dhstruct_ptr->address2;
				
		/* Store the duration information.										*/
		last_rcvd_duration = pk_dhstruct_ptr->duration;
				
		/* Process frame only if it is destined for this station.				*/
		if	(dest_addr == my_address)
			{			
			/* Data packet id of the received data frame is extracted.			*/
			op_pk_fd_get_pkid (wlan_rcvd_frame_ptr, WLANC_DATA_PKID_FD, &data_pkt_id);

			/* Extracting the MMPDU (or MMPDU fragment) from the packet.		*/
			/*Loren
			printf("I am  %d: getting seg_pkptr MMPDU\n",(int)my_address);
			*/
	
			op_pk_fd_get_pkt (wlan_rcvd_frame_ptr, WLANC_DATA_BODY_FD, &seg_pkptr);

			/* Acknowledge the MMPDU.											*/
			fresp_to_send     = WlanC_Ack;
			response_sta_addr = remote_sta_addr;
				
			/* If there is a timer running for NAV expiry, then cancel it since	*/
			/* we will be leaving the "MEDIUM BUSY" state.						*/
			if (nav_duration > current_time && op_ev_valid (nav_end_evh))
				op_ev_cancel (nav_end_evh);
			             	
			/* If its a duplicate packet then destroy it and do nothing,		*/
			/* otherwise insert it in the defragmentation list.					*/
			if (wlan_hcf_tuple_find (rcvd_frame_type, 0, remote_sta_addr, pk_dhstruct_ptr->sequence_control, dest_addr, 
									 pk_dhstruct_ptr->retry, &src_sta_info_ptr, &prev_seq_num) == OPC_FALSE)
				{
				/*Loren
				printf("I am %d, calling wlan_hcf_data_process function 2.\n", (int)my_address);
				*/
				wlan_hcf_data_process (rcvd_frame_type, seg_pkptr, dest_addr, remote_sta_addr, 0, pk_dhstruct_ptr->hl_protocol,
					pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK, pk_dhstruct_ptr->more_frag, data_pkt_id, 0, src_sta_info_ptr);
				}
			else
				{
				/* Destroy the duplicate packet without any processing.			*/
				op_pk_destroy (seg_pkptr);
				}
			}
		else
			{
			/* The received data packet is not destined to us. Update NAV	*/
			/* duration if the received NAV duration is greater	than the	*/
			/* current NAV duration.							  			*/    	
			if (last_rcvd_duration < 32768 && nav_duration < (last_rcvd_duration + current_time))
				{
				nav_duration = last_rcvd_duration + current_time;

				/* Set the flag that indicates updated NAV value.			*/
				wlan_flags->nav_updated = OPC_TRUE;
				}
			}
		
		if (expected_frame_type == WlanC_Ack)
			{
			/* A frame has not been properly acknowledged and requires				*/
			/* retransmission. Did the data transmission fail in spite of a			*/
			/* successful RTS/CTS exchange?											*/
			if (wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac])
				/* Increment the long retry count.									*/
				lrc_arr [cur_tx_ac] += 1;
			else
				/* Increment the short retry count.									*/
				src_arr [cur_tx_ac] += 1;
			
			/* Reset the rts_sent flag since we will recontend for the medium.		*/
			wlan_flags->rts_sent = OPC_FALSE;					
			}	

		if (expected_frame_type == WlanC_Cts) 
			{
			/* Since the station did not receive the expected frame it has to		*/
			/* retransmit the packet.												*/
			src_arr [cur_tx_ac] += 1;
			}			
		}

	/* Check whether we received a PCF frame of type data, which is			*/
	/* possible if we are associated with a PCF-enabled legacy AP.			*/
	else if	(rcvd_frame_type & WLANC_DATA_TYPE_BIT)
		{
				
		//mohammad
		if(myDebugFlag)
			{
			sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
			MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
			fprintf(MyExcecutionTrace,"Time %f The reveived packet(%d) is a DATA Packet\n",op_sim_time(),(int)rcvd_frame_type);
			fclose(MyExcecutionTrace);
		
		
			
			}
		if(myStringDebug)
				{
			
			
				sprintf(myString,"I am %d:The reveived packet(%d) is a DATA Packet",(int)my_address,(int)rcvd_frame_type);
				op_prg_odb_print_major(myString,OPC_NIL);
				}
		//end mohammad
		
		/* Update the data traffic received statistic since the 802.11		*/
		/* standard considers all the frame types as data frames. Write the	*/
		/* appropriate values for start and end of the reception.			*/
		op_stat_write_t (data_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (data_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (data_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (data_traffic_rcvd_handle, 0.0);
		
		/* Access the MAC header of the packet.								*/
		
		//loren: not normally called from here. 
		//printf("calling op_pk_fd_access_read_only_ptr 20.\n");
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_DATA_HEADER_FD, (const void **) &pk_dhstruct_ptr);

		/* Obtain the destination this packet id addressed to.				*/
		dest_addr = pk_dhstruct_ptr->address1;	
		remote_sta_addr = pk_dhstruct_ptr->address2;
				
		/* This MAC should not receive any PCF frames, because as being a QSTA, it	*/
		/* is not configured to be polled by a PCF-enabled legacy AP.				*/
		if (dest_addr == my_address)
			wlan_error_print ("Unexpected PCF frame with own address received.", 
							  "QSTAs are not expected to be polled by a PCF-enabled nQAP during CFP.", OPC_NIL);
		
		/* Store the duration information.											*/
		last_rcvd_duration = pk_dhstruct_ptr->duration;
		
		/* Process frame only if it is a broadcast frame and if it is containing	*/
		/* data.																	*/
		if (dest_addr < 0 && !(rcvd_frame_type & WLANC_NULL_DATA_BIT))
			{	
			/* Extracting the MSDU from the packet only if the packet is destined	*/
			/* for this station.*/
			/*Loren
		    printf("I am  %d: getting seg_pkptr MSDU 1\n",(int)my_address);
			*/
			op_pk_fd_get_pkt (wlan_rcvd_frame_ptr, WLANC_DATA_BODY_FD, &seg_pkptr);

			/* If its a duplicate packet then destroy it and do nothing, otherwise 	*/
			/* insert it in the defragmentation list.								*/
			if (wlan_hcf_tuple_find (rcvd_frame_type, 0, remote_sta_addr, pk_dhstruct_ptr->sequence_control, dest_addr, 
									 pk_dhstruct_ptr->retry, &src_sta_info_ptr, &prev_seq_num) == OPC_FALSE)
				{
	           	/* If congestion area analysis is enabled and this is a tracer		*/
				/* packet update the congestion area info.							*/ 
				if (CONGESTION_AREAS_ENABLED && op_pk_encap_flag_is_set (seg_pkptr, OMSC_BGUTIL_ENCAP_FLAG_INDEX))
					wlan_support_congestion_area_info_update (seg_pkptr, rx_state_info_ptr);
				
				/* Insert the packet into reassembling buffer. If it completes an	*/
				/* MSDU or MMPDU then process it and send to the higher layer.		*/
				/*Loren
				printf("I am %d, calling wlan_hcf_data_process function 3.\n", (int)my_address);
				*/
				
				op_pk_fd_get_pkid (wlan_rcvd_frame_ptr, WLANC_DATA_PKID_FD, &data_pkt_id);
				wlan_hcf_data_process (rcvd_frame_type, seg_pkptr, dest_addr, remote_sta_addr, pk_dhstruct_ptr->address3, pk_dhstruct_ptr->hl_protocol,
					pk_dhstruct_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK, pk_dhstruct_ptr->more_frag, data_pkt_id, WLANC_nQSTA_DATA_UP, src_sta_info_ptr);
				}
			else
				{
				/* Destroy the duplicate packet without any processing.				*/
				op_pk_destroy (seg_pkptr);
				}
			}
			
		if (expected_frame_type == WlanC_Ack)
			{
			/* If an ACK is expected, and a PCF ACK is received, regardless of whom	*/  
			/* the frame is	addressed to, process the received ACK.					*/
			if (rcvd_frame_type & WLANC_ACK_BIT)
				{
				/* Printing out information to ODB.									*/
				if (wlan_trace_active == OPC_TRUE)
					{
					sprintf (msg_string, "ACK received for data packet " OPC_PACKET_ID_FMT ".", served_pk_id_arr [cur_tx_ac]);
					op_prg_odb_print_major (msg_string, OPC_NIL);
					}			

				/* Record the number of retransmissions performed for the MPDU that	*/
				/* was ACKed.														*/
				op_stat_write (retrans_handle,        (double) (src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac]));
				op_stat_write (global_retrans_handle, (double) (src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac]));				

				/* Reset the retry counts and retry bit flag as the expected frame	*/
				/* is received.														*/
				src_arr [cur_tx_ac] = 0;
				lrc_arr [cur_tx_ac] = 0;
				
				/* Similarly reset the rts_sent flag that may have been set and		*/
				/* used for this transmission during the DCF period that proceeded	*/
				/* current PCF period.												*/
				wlan_flags->rts_sent = OPC_FALSE;
				
				/* Data packet is successfully delivered to remote station,			*/
				/* since no further retransmission is needed the copy of the data	*/
				/* packet will be destroyed.										*/
				if (mpdu_retx_copy_arr [cur_tx_ac] != OPC_NIL) 
					{
					op_pk_destroy (mpdu_retx_copy_arr [cur_tx_ac]);
					mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
					}
				
				/* Decrement number of fragment count because one fragment is		*/
				/* successfully transmitted.										*/
				num_fragments_arr [cur_tx_ac] -= 1;				
				
				/* Dequeue the MSDU/MMPDU if all of its fragments are transmitted.	*/
				if (num_fragments_arr [cur_tx_ac] == 0)
					wlan_hcf_hlpk_dequeue (cur_tx_ac, 0);				
				
				/* Start of a CFP indicates the end of our TXOP.					*/
				wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];
				}	
			else
				{
				/* A frame has not been properly acknowledged and requires			*/
				/* retransmission. Did the data transmission fail in spite of a		*/
				/* successful RTS/CTS exchange?										*/
				if (wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac])
					/* Increment the long retry count.								*/
					lrc_arr [cur_tx_ac] += 1;
				else
					/* Increment the short retry count.								*/
					src_arr [cur_tx_ac] += 1;
				
				/* Reset the rts_sent flag since we will recontend for the medium.	*/
				wlan_flags->rts_sent = OPC_FALSE;					
				}
			}

		if (expected_frame_type == WlanC_Cts) 
			{
			/* Since the station did not receive the expected frame it has to		*/
			/* retransmit the packet.												*/
			src_arr [cur_tx_ac] += 1;
			}
			
		/* Update NAV duration if the received NAV duration is greater than the		*/
		/* current NAV duration.							  						*/
		if ((last_rcvd_duration < 32768) && 
			(nav_duration < (last_rcvd_duration + current_time)))
			{
			nav_duration = last_rcvd_duration + current_time;

			/* Set the flag that indicates updated NAV value.						*/
			wlan_flags->nav_updated = OPC_TRUE;
			}
		}

	/* The frame can be a control packet from a nQAP announcing end of CFP.	*/
	else if	(rcvd_frame_type == WlanC_Cf_End || rcvd_frame_type == WlanC_Cf_End_A)
		{
		/* Retrieve the packet header and destination information.		*/
		
		//loren: not normally called from here. 
		//printf("calling op_pk_fd_access_read_only_ptr 21.\n");
	
		op_pk_fd_access_read_only_ptr (wlan_rcvd_frame_ptr, WLANC_CNTL_HEADER_FD, (const void **) &pk_chstruct_ptr);
			
		dest_addr = pk_chstruct_ptr->rx_addr;
					
		/* Store the duration information.								*/
		last_rcvd_duration = pk_chstruct_ptr->duration;
		
		/* Update received control traffic statistics. Write the		*/
		/* appropriate values for start and end of the reception.		*/
		op_stat_write_t (ctrl_traffic_rcvd_handle_inbits, rcvd_pk_size, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle_inbits, 0.0);
		op_stat_write_t (ctrl_traffic_rcvd_handle, 1.0, rx_start_time);
		op_stat_write (ctrl_traffic_rcvd_handle, 0.0);

		if (expected_frame_type == WlanC_Ack)
			{
			/* If CF_END+ACK is received, accept it as the expected ACK.*/
			if (rcvd_frame_type == WlanC_Cf_End_A)
				{
				/* Printing out information to ODB.	*/
				if (wlan_trace_active == OPC_TRUE)
					{
					sprintf (msg_string, "ACK received for data packet " OPC_PACKET_ID_FMT ".", served_pk_id_arr [cur_tx_ac]);
					op_prg_odb_print_major (msg_string, OPC_NIL);
					}			

				/* Write the number of retransmission attempts into its			*/
				/* statistic.													*/
				total_retries = (double) (src_arr [cur_tx_ac] + lrc_arr [cur_tx_ac]);
				op_stat_write (retrans_handle,        total_retries);
				op_stat_write (global_retrans_handle, total_retries);				
				
				/* Reset the retry counts and the retry bit flag as the			*/
				/* expected frame is received.									*/
				if (total_retries > 0.0)
					{
					src_arr [cur_tx_ac] = 0;
					lrc_arr [cur_tx_ac] = 0;
					}
				
				/* Decrement number of fragment count because one fragment is successfully transmitted.	*/
				num_fragments_arr [cur_tx_ac] -= 1;				

				/* When there are no more fragments to transmit then disable the RTS sent flag	*/
				/* if it was enabled because the contention period due to RTS/CTS exchange is 	*/
				/* over and another RTS/CTS exchange is needed for next contention period.		*/
				if (num_fragments_arr [cur_tx_ac] == 0)
					{
					wlan_flags->rts_sent = OPC_FALSE;
					
					/* Set the contention window flag. Since the ACK for the last 		*/
					/* fragment indicates a	successful transmission of the entire data,	*/
					/* we need to back-off for a contention window period.				*/
					if (rcvd_frame_type == WlanC_Ack)
						wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [cur_tx_ac];					
					}

				/* Data packet is successfully delivered to remote station,			*/
				/* since no further retransmission is needed the copy of the data	*/
				/* packet will be destroyed.										*/
				if (mpdu_retx_copy_arr [cur_tx_ac] != OPC_NIL) 
					{
					op_pk_destroy (mpdu_retx_copy_arr [cur_tx_ac]);
					mpdu_retx_copy_arr [cur_tx_ac] = OPC_NIL;
					}
				}
			else
				{
				/* We didn't receive the ACK we were expecting.			*/
				/* Increment the long retry count if the transmission	*/
				/* of a data frame larger than RTS/CTS threshold has	*/
				/* failed; otherwise increment the short retry count.	*/
				if (wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac])
					lrc_arr [cur_tx_ac] += 1;
				else 
					src_arr [cur_tx_ac] += 1;
				
				/* Also reset the rts_sent flag since we will recontend.*/
				wlan_flags->rts_sent = OPC_FALSE;
				
				/* Printing out information to ODB.						*/
				if (wlan_trace_active == OPC_TRUE)
					{
					op_prg_odb_print_major ("The expected ACK is not received.", OPC_NIL);
					}
				}
			}

		if (expected_frame_type == WlanC_Cts) 
			{
			/* Since the station did not receive the expected frame it	*/
			/* has to retransmit the packet. 							*/
			src_arr [cur_tx_ac] += 1;
			}
		
		/* A CF-End(+)ACK message received from any BSS resets the NAV	*/
		/* (section 9.3.2.2).											*/
		nav_duration = current_time;
		
		/* Set the flag that indicates updated NAV value.				*/
		wlan_flags->nav_updated = OPC_TRUE;
		
		/* Printing out information to ODB.								*/
		if (wlan_trace_active == OPC_TRUE)
			{
			if (rcvd_frame_type == WlanC_Cf_End)
				op_prg_odb_print_major ("CF-End frame is received.",     OPC_NIL);
			else
				op_prg_odb_print_major ("CF-End+Ack frame is received.", OPC_NIL);
			}						
		}

	else 
		{
		/* Unknown frame type so declare error.								*/
		wlan_error_print ("Unexpected frame type received.", OPC_NIL, OPC_NIL);
		}
   
	/* Check whether further retries are possible or	*/
	/* the data frame needs to be discarded.			*/
	wlan_hcf_frame_discard (cur_tx_ac);

	/* Set the expected frame type to None because either the 	*/
	/* expected frame is received or the station will have to 	*/
	/* retransmit the frame										*/
	expected_frame_type = WlanC_None;
	
	/* Destroying the received frame once relevant information is taken out of it.	*/
	
	//mohammad
	if(myDebugFlag)
		{
		sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
		MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
		fprintf(MyExcecutionTrace,"Time %f The reveived packet (%d) was processed\n",op_sim_time(),(int)rcvd_frame_type);
		fclose(MyExcecutionTrace);
	
		
		}
	if(myStringDebug)
		{
			
			
		sprintf(myString,"I am %d:The reveived packet (%d) was processed",(int)my_address,(int)rcvd_frame_type);
		op_prg_odb_print_major(myString,OPC_NIL);
		}
	//end mohammad
	op_pk_destroy (wlan_rcvd_frame_ptr);														

	FOUT;
	}

static Boolean
wlan_hcf_tuple_find (WlanT_Mac_Frame_Type type, int tid, OpT_Int64 sta_addr, int seq_control, OpT_Int64 dest_addr, Boolean retry, 
					 WlanT_HCF_Peer_Info** src_sta_info_pptr, OpT_uInt16 * prev_seq_num_ptr)
	{
	WlanT_HCF_Peer_Info*	src_sta_info_ptr;
	OpT_uInt16*				last_rcvd_seq_cntl_ptr;
	
	/** This function checks whether the last received frame is a		**/
	/** duplicate or not using the source address, sequence number, and	**/
	/** fragmentation number information of the frame. It returns the	**/
	/** result of this check.											**/
	FIN (wlan_hcf_tuple_find (type, tid, sta_addr, seq_control, dest_addr, retry, src_sta_info_pptr, prev_seq_num_ptr));

	/* We receive packets only from our AP if we belong to an			*/
	/* infrastructure BSS, in which case we don't maintain a Hash table	*/
	/* for peer records.												*/
	if (peer_info_hash_tbl != OPC_NIL)
		{
		/* First make sure that the source STA belongs to our BSS.		*/
		src_sta_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(sta_addr));
		if (src_sta_info_ptr != OPC_NIL)
			{
			/* Get the sequence control number in record for			*/
			/* comparison. If this is a unicast QoS data frame, then	*/
			/* obtain the TID specific record.							*/
			if (type == WlanC_QoS_Data && dest_addr >= 0)
				last_rcvd_seq_cntl_ptr = &(src_sta_info_ptr->tid_rcvd_seq_cntl_arr [tid]);
			else
				last_rcvd_seq_cntl_ptr = &(src_sta_info_ptr->seq_cntl);
			
			/* Also return the sequence number of the previous MPDU.	*/
			*prev_seq_num_ptr = *last_rcvd_seq_cntl_ptr >> WLANC_FRAG_NUM_SIZE;
			
			/* Check whether the latest received frame is a duplicate.	*/
			if (retry == OPC_TRUE && *last_rcvd_seq_cntl_ptr >> WLANC_FRAG_NUM_SIZE == seq_control >>  WLANC_FRAG_NUM_SIZE && 
				!(SEQ_A_GREATER_THAN_SEQ_B (seq_control, *last_rcvd_seq_cntl_ptr, 64)))
				duplicate_entry = OPC_TRUE;
			else
				{
				duplicate_entry = OPC_FALSE;
				
				/* Since this is not a duplicate, update the recorded	*/
				/* information for this source.							*/
				*last_rcvd_seq_cntl_ptr = (OpT_uInt16) seq_control;
				}
			
			/* Return the result and a handle to the source STA's 		*/
			/* information record.										*/
			*src_sta_info_pptr = src_sta_info_ptr;
			FRET (duplicate_entry);
			}
		}
	else
		{
		/* Make sure that the frame is coming from our AP.				*/
		if (sta_addr == ap_mac_address)
			{
			/* Get the sequence control number in record for			*/
			/* comparison. If this is a unicast QoS data frame, then	*/
			/* obtain the TID specific record.							*/
			if (type == WlanC_QoS_Data && dest_addr >= 0)
				last_rcvd_seq_cntl_ptr = &(ap_peer_info_ptr->tid_rcvd_seq_cntl_arr [tid]);
			else
				last_rcvd_seq_cntl_ptr = &(ap_peer_info_ptr->seq_cntl);
			
			/* Also return the sequence number of the previous MPDU.	*/
			*prev_seq_num_ptr = *last_rcvd_seq_cntl_ptr >> WLANC_FRAG_NUM_SIZE;
			
			/* Check whether the latest received frame is a duplicate.	*/
			if (retry == OPC_TRUE && *last_rcvd_seq_cntl_ptr >> WLANC_FRAG_NUM_SIZE == seq_control >>  WLANC_FRAG_NUM_SIZE && 
				!(SEQ_A_GREATER_THAN_SEQ_B (seq_control, *last_rcvd_seq_cntl_ptr, 64)))
				duplicate_entry = OPC_TRUE;
			else
				{
				duplicate_entry = OPC_FALSE;
				
				/* Since this is not a duplicate, update the recorded	*/
				/* information for this source.							*/
				*last_rcvd_seq_cntl_ptr = (OpT_uInt16) seq_control;
				}
			
			/* Return the result and a handle to the source STA's 		*/
			/* information record.										*/
			*src_sta_info_pptr = ap_peer_info_ptr;
			FRET (duplicate_entry);
			}
		}
	
	/* If we come to this point, then either the source STA is not in	*/
	/* our BSS or we received a direct transmission from a peer			*/
	/* bypassing the AP in the BSS. In either case, this is an			*/
	/* unexpected event indicating an error condition, unless the		*/
	/* packet is a broadcast packet.									*/
	if (dest_addr == my_address)
		{
		wlan_error_print ("Receiving packet from a station that does not exist in this BSS",
						  "Possibly wrong destination address", "Please check the configuration");
		}
	else
		{
		/* We may receive broadcast packets that are not originated in	*/
		/* our BSS, if there are other BSSs in the vicinity	that uses	*/
		/* the exact same physical channel with our own	BSS. In such	*/
		/* cases, return OPC_TRUE, like we received a duplicate			*/
		/* message, so that the caller function destroys the packet		*/
		/* without any processing.										*/
		FRET (OPC_TRUE);
		}

	/* This line won't be reached.										*/
	FRET (OPC_TRUE);				
	}
	
static void
wlan_hcf_data_process (WlanT_Mac_Frame_Type frame_type, Packet* seg_pkptr, OpT_Int64 dest_addr, OpT_Int64 sta_addr, OpT_Int64 final_dest_addr, int protocol_type,
					   int frag_num, int more_frag, OpT_Packet_Id pkt_id, short tid, WlanT_HCF_Peer_Info* src_sta_info_ptr)
	{
	int	 							current_index;
	int 							list_index;
	int 							list_size;
	WlanT_HCF_Access_Category		tx_ac = WLANC_UP_TO_AC_MAPPING_ARRAY [tid];
	WlanT_HCF_Defragmentation_Info*	defrag_ptr = OPC_NIL;
	char							msg_string [128];
	
	/** This routine handles defragmentation process and also sends		**/
	/** data to the higher layer if all the fragments have been			**/
	/** received by the station.										**/
	FIN (wlan_hcf_data_process (frame_type, seg_pkptr, dest_addr, sta_addr, final_dest_addr, protocol_type, frag_num, more_frag, pkt_id, tid, src_sta_info_ptr));

	/* First check for the case where the received segment contains the	*/
	/* entire data packet, i.e. the data is transmitted as a single		*/
	/* fragment.														*/
	if (frag_num == 0 && more_frag == 0)
		{
		/* Insert the segment into our "common" reassembly buffer that	*/
		/* is used for such single-fragment transmission.				*/
		op_sar_rsmbuf_seg_insert (common_rsmbuf_ptr, seg_pkptr);
		}
	
	else
		{
		/* The original packet is being transmitted in multiple			*/
		/* fragments. Insert fragments into the reassembly buffer.		*/
		/* There are two possible cases:								*/
		/* 1. The remote station has just started sending the 			*/
		/* fragments and it doesn't exist in the list.					*/
		/* 2. The remote station does exist in the list and the 		*/
		/* and the new fragment is a series of fragments for the data 	*/
		/* packet.													  	*/
		printf("packet transmitted in multiple fragments.\n");
		/* Get the size of the defragmentation list.					*/
		list_size = op_prg_list_size (defragmentation_list_ptr);
		printf("List size = %d\n", list_size);
		/* Initialize the current node index which will indicate		*/
		/* whether the entry for the station exists in the list.		*/
		current_index = -1;

		/* Searching through the list to find if the remote station		*/
		/* address exists i.e. the source station has received			*/
		/* fragments for this data packet before. Also, removing		*/
		/* entries from the defragmentation buffer which has reached	*/
		/* its maximum receive lifetime.								*/
		for (list_index = 0; list_index < list_size; )
			{
			/* Accessing node of the list for search purposes.			*/						
			defrag_ptr = (WlanT_HCF_Defragmentation_Info *) op_prg_list_access (defragmentation_list_ptr, list_index);

			/* Removing station entry if the receive lifetime has		*/
			/* expired.													*/
			if ((current_time - defrag_ptr->time_rcvd) >= max_receive_lifetime)
				{
				/* Removing the partially completed fragment once its	*/
				/* lifetime has reached.								*/
				defrag_ptr = (WlanT_HCF_Defragmentation_Info *) op_prg_list_remove (defragmentation_list_ptr, list_index);
				op_sar_buf_destroy (defrag_ptr->reassembly_buffer_ptr);					
				op_prg_mem_free (defrag_ptr);	

				/* Updating the total list size.						*/
				list_size = list_size - 1;
				}

			/* If the station entry already exists in the list then		*/
			/* store its index for future use.							*/
			else if (sta_addr == defrag_ptr->tx_station_address && tx_ac == defrag_ptr->tx_ac)
				{
				current_index = list_index;
			
				/* Exit the loop since we have found the entry we were	*/
				/* looking for.											*/
				list_index = list_size;	
				}
		
			/* Otherwise move to the next element in the list.			*/
			else
				list_index++;
			}                             						

		/* If remote station entry doesn't exist then create new node.	*/
		if (current_index == -1)											
			{
			/* If the entry of the station does not exist in the defrag	*/
			/* list and the fragment received is not the first fragment	*/
			/* of the packet then it implies that the maximum receive	*/
			/* lifetime of the packet has expired. In this case the		*/
			/* received packet will be destroyed and the				*/
			/* acknowledgement is sent to the receiver as specified by	*/
			/* the protocol.											*/
			if (frag_num > 0)
				{
				op_pk_destroy (seg_pkptr);
				FOUT;
				}

			/* Creating struct type for defragmentation structure.		*/  						
			defrag_ptr = (WlanT_HCF_Defragmentation_Info *) op_prg_mem_alloc (sizeof (WlanT_HCF_Defragmentation_Info));

			/* Store source node and AC information to find the entry	*/
			/* when the following fragment(s) arrive.					*/
			defrag_ptr->tx_station_address = sta_addr;
			defrag_ptr->tx_ac              = tx_ac;
			
			/* For new node creating a reassembly buffer.				*/
			defrag_ptr->reassembly_buffer_ptr = op_sar_buf_create (OPC_SAR_BUF_TYPE_REASSEMBLY, OPC_SAR_BUF_OPT_DEFAULT);
			op_prg_list_insert (defragmentation_list_ptr, defrag_ptr, OPC_LISTPOS_TAIL);
			}

		else if (frag_num == 0)
			{
			/* We have found a defragmentation buffer for the MAC		*/
			/* address-AC tuple, although this is the first fragment of	*/
			/* a transmission sequence. This is a rare case and			*/
			/* indicates that we were receiving another fragmented MSDU	*/
			/* from the same source, which the source completed sending	*/
			/* though we could not receive all the fragments. Hence,	*/
			/* flush the defragmentation buffer since we will never		*/
			/* receive the missing fragment(s) of the MSDU that is		*/
			/* already in the buffer.									*/
			op_sar_rsmbuf_pk_flush (defrag_ptr->reassembly_buffer_ptr, 0.0);
			}
		
		/* Record the received time of this fragment.					*/
		defrag_ptr->time_rcvd = current_time;
					
		/* Insert fragment into the reassembly buffer.					*/
		op_sar_rsmbuf_seg_insert (defrag_ptr->reassembly_buffer_ptr, seg_pkptr);
		}

	/* If this is the last fragment then send the data to higher layer.	*/
	if (more_frag == 0)
		{
		/* Pick the correct reassembly buffer based on the fragment		*/
		/* type.														*/
		if (frag_num > 0)
			seg_pkptr = op_sar_rsmbuf_pk_remove (defrag_ptr->reassembly_buffer_ptr);
 		else
			seg_pkptr = op_sar_rsmbuf_pk_remove (common_rsmbuf_ptr);
		
		/* Make sure that we really have all the fragments. Otherwise	*/
		/* it indicates an internal operational error probably at the	*/
		/* source node.													*/
		if (seg_pkptr == OPC_NIL)
			wlan_error_print ("Reassembly error at the destination MAC.", "Probably, source MAC sent an MPDU with empty payload.", OPC_NIL);
		
		/* Process the received frame. If it is a data frame, forward	*/
		/* it to the higher	layer or to its final destination in our	*/
		/* BSS.															*/
		if (frame_type == WlanC_Action)
		{
			wlan_hcf_action_mmpdu_process (seg_pkptr, sta_addr, src_sta_info_ptr);
		}
		else
		{
			/*Loren */
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, Entering completed frame forward function from here.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			wlan_hcf_completed_frame_forward (seg_pkptr, sta_addr, dest_addr, final_dest_addr, protocol_type, pkt_id, tid);	
		}
		
		/* If any used, destroyed any defragmentation entry and			*/
		/* reassembly buffer, since the fragments of frame were			*/
		/* completed and the data was sent to the higher layer.			*/
		if (defrag_ptr != OPC_NIL)
			{
			defrag_ptr = (WlanT_HCF_Defragmentation_Info *) op_prg_list_remove (defragmentation_list_ptr, current_index);
			op_sar_buf_destroy (defrag_ptr->reassembly_buffer_ptr);					
			op_prg_mem_free (defrag_ptr);
			}
		}
	else
		{
		/* Printing out information to ODB.	*/
		if (wlan_trace_active == OPC_TRUE)
			{			
			sprintf (msg_string, "Data packet " OPC_PACKET_ID_FMT " is received and waiting for more fragments ", pkt_id);
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}
		}

	FOUT;
	}

static void
wlan_hcf_ba_data_process (WlanT_Mac_Frame_Type frame_type, Packet* mpdu_body_pkptr, OpT_Int64 peer_addr, WlanT_HCF_Peer_Info* peer_info_ptr, OpT_Int64 final_dest_addr, 
						  int tid, int sequence_control, int more_frag, int protocol_type, OpT_Packet_Id data_pkt_id, WlanT_HCF_Ack_Policy ack_policy, OpT_uInt16 last_seq_num)
	{
	WlanT_HCF_BA_State*		ba_info_ptr;
	WlanT_BA_Buffered_MSDU*	msdu_info_ptr;
	WlanT_BA_Buffered_MSDU*	prev_msdu_ptr;
	WlanT_BA_Buffered_MPDU* mpdu_info_ptr;
	WlanT_BA_Buffered_MPDU* temp_mpdu_info_ptr;
	Packet*					msdu_pkptr;
	int						seq_num_diff, bitmap_location, map_shift;
	int						mpdu_seq_num, mpdu_frag_num;
	char					msg_string [256];
	
	/** This function is called when an MPDU is received from a peer-	**/
	/** TID	pair with there is an active block-ACK agreement in			**/
	/** incoming direction, to insert it into the reordering buffer.	**/
	/** If the reordering buffer is full, then it reassembles the MSDU	**/
	/** with the lowest sequence number and forward it to the higher	**/
	/** to open some space in the buffer as specified in the 802.11e	**/
	/** standard.														**/
	FIN (wlan_hcf_ba_data_process (frame_type, mpdu_body_pkptr, peer_addr, peer_info_ptr, final_dest_addr, tid, sequence_control, more_frag, protocol_type, data_pkt_id, ack_policy, last_seq_num));
	
	/* Get a handle to the BA state information for this source and TID.*/
	ba_info_ptr = peer_info_ptr->ba_state_ptr_arr [tid];
	
	/* If we actually don't have a BA agreement with this peer/TID, in	*/
	/* which we are the recipient (this is possible if we have just		*/
	/* torn down the agreement due to inactivity, and tried and failed	*/
	/* to inform the peer with a DELBA message), discard the message	*/
	/* and enqueue a DELBA frame.										*/
	if (ba_info_ptr == OPC_NIL || ba_info_ptr->peer_block_size == 0)
		{
		op_pk_destroy (mpdu_body_pkptr);
		wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_DELBA, tid, peer_addr, 0, OPC_FALSE);
		FOUT;
		}
	
	/* If this is the first ever MPDU of the block-ACK agreement,		*/
	/* adjust the starting sequence number if necessary, since the		*/
	/* sequence numbers may have advanced with this peer/tid while BA	*/
	/* agreement was being established.									*/
	if (ba_info_ptr->first_mpdu_rcvd == OPC_FALSE)
		{
		ba_info_ptr->first_mpdu_rcvd = OPC_TRUE;
		
		/* If we receved the ADDBA request while aslo receiving the 	*/
		/* fragments of the same MSDU (very rare), adjustment is not 	*/
		/* needed. Otherwise do the adjustment without checking its		*/
		/* need, since the check has the same cost of doing it.			*/
		if (ba_info_ptr->peer_starting_seq_num != last_seq_num)
			ba_info_ptr->peer_starting_seq_num = (last_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
		}
	
	/* Decompose the sequence control number into local variables for	*/
	/* quick access.													*/	
	mpdu_seq_num  = sequence_control >> WLANC_FRAG_NUM_SIZE;
	mpdu_frag_num = sequence_control & WLANC_FRAG_NUM_BIT_MASK;
	seq_num_diff  = wlan_hcf_seq_a_minus_seq_b (mpdu_seq_num, ba_info_ptr->peer_starting_seq_num, ba_info_ptr->peer_block_size);

	/* If the MPDU's sequence number is beyond the range of our local	*/
	/* status bitmap (this is possible but should be extremely rare)	*/
	/* then shift our status bitmap in order to include this new MSDU	*/
	/* as well.															*/
	if (seq_num_diff >= WLANC_BA_RECIPIENT_SB_MAX_MSDU)
		{
		wlan_hcf_ba_status_bitmap_shift (ba_info_ptr, seq_num_diff - WLANC_BA_RECIPIENT_SB_MAX_MSDU + 1);
		seq_num_diff = WLANC_BA_RECIPIENT_SB_MAX_MSDU - 1;
		}
	
	/* Make sure that the MPDU is not a duplicate.						*/
	if (ba_info_ptr->status_bitmap [seq_num_diff] & (1 << mpdu_frag_num))
		{
		/* This is a duplicate. Simply destroy it without processing.	*/
		op_pk_destroy (mpdu_body_pkptr);
		duplicate_entry = OPC_TRUE;
		
		/* If enabled, write an ODB message.							*/
		if (wlan_trace_active)
			op_prg_odb_print_major ("A duplicate block MPDU has been received. Discarding.", OPC_NIL);

		FOUT;
		}
	
	/* First check whether the reordering buffer is full.				*/
	if (ba_info_ptr->rcvd_mpdu_count == ba_info_ptr->peer_block_size)
		{
		/* If enabled, write an ODB message.								*/
		if (wlan_trace_active)
			{				
			sprintf (msg_string, "BA reordering buffer for source STA "OPC_INT64_FMT" and TID %d is full.", ba_info_ptr->peer_addr, ba_info_ptr->tid); 
			op_prg_odb_print_major (msg_string, OPC_NIL);
			}
	
		/* Remove the complete MSDU with the lowest sequence number to	*/
		/* open some space in the reordering buffer. First find the		*/
		/* first MSDU that is complete.	Also, if any, skip the complete	*/
		/* MSDU that are already reassembled and forwarded, which may	*/
		/* be the case if we executed this task before again to open	*/
		/* some space in the reordering buffer.							*/
		for (msdu_info_ptr = ba_info_ptr->reordering_buffer_ptr; 
			 msdu_info_ptr != OPC_NIL && (msdu_info_ptr->complete == OPC_FALSE || msdu_info_ptr->mpdu_lptr == OPC_NIL); 
			 msdu_info_ptr = msdu_info_ptr->next_msdu_ptr)
			prev_msdu_ptr = msdu_info_ptr;
			
		if (msdu_info_ptr != OPC_NIL)
			{
			/* Reassemble the MSDU.										*/
			msdu_pkptr = wlan_hcf_buffered_ba_msdu_reassemble (msdu_info_ptr);
			
			/* Decrease the number of MPDUs in the reordering buffer.	*/
			ba_info_ptr->rcvd_mpdu_count -= msdu_info_ptr->num_fragments;
			
			/* Process the reassembled MSDU: forward to the higher		*/
			/* layer or enqueue it to transmit to its final destination	*/
			/* in the BSS.	`											*/
			
			/*Loren: function is not normally called from here.
			sprintf(myString,"I am %d, starting frame forward function 3.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			*/
			
			wlan_hcf_completed_frame_forward (msdu_pkptr, peer_addr, my_address, msdu_info_ptr->final_dest_addr, msdu_info_ptr->hl_protocol, msdu_info_ptr->pkt_id, tid);

			/* If the forwarded MSDU was at the head of the reordering	*/
			/* buffer and if it was sent using Normal-ACK instead of	*/
			/* Block-ACK policy, destroy the MSDU record and advance	*/
			/* the status bitmap to the next MSDU if necessary.			*/
			if (msdu_info_ptr == ba_info_ptr->reordering_buffer_ptr && msdu_info_ptr->ack_policy == WlanC_Normal_ACK)
				{
				ba_info_ptr->reordering_buffer_ptr = msdu_info_ptr->next_msdu_ptr;
				op_prg_mem_free (msdu_info_ptr);
				if (!(SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->peer_starting_seq_num, msdu_info_ptr->sequence_number, ba_info_ptr->peer_block_size)))
					{
					map_shift = wlan_hcf_seq_a_minus_seq_b (msdu_info_ptr->sequence_number, ba_info_ptr->peer_starting_seq_num, ba_info_ptr->peer_block_size) + 1;
					wlan_hcf_ba_status_bitmap_shift (ba_info_ptr, map_shift);
					
					/* Since we have shifted the bitmap, adjust the		*/
					/* the offset of the current packet with respect to	*/
					/* the starting point of the bitmap.				*/
					seq_num_diff -= map_shift;
					}
				}
			}
		else	
			{
			/* If enabled, write an ODB message.						*/
			if (wlan_trace_active)
				op_prg_odb_print_major ("No complete MSDUs in the reordering buffer! Discarding the MPDUs of the oldest MSDU.", OPC_NIL);
			
			/* If there is no complete MSDU, which is extremely			*/
			/* unlikely to happen, destroy the MPDUs of the MSDU at the	*/
			/* head of the buffer.										*/
			for (mpdu_info_ptr = ba_info_ptr->reordering_buffer_ptr->mpdu_lptr; mpdu_info_ptr != OPC_NIL; )
				{
				op_pk_destroy (mpdu_info_ptr->mpdu_data_pkptr);
				temp_mpdu_info_ptr = mpdu_info_ptr;
				mpdu_info_ptr = mpdu_info_ptr->next_mpdu_ptr;
				op_prg_mem_free (temp_mpdu_info_ptr);
			
				/* Decrement the MPDU count of the buffer.				*/
				ba_info_ptr->rcvd_mpdu_count--;
				}
			
			/* Update the status bitmap.								*/
			bitmap_location = wlan_hcf_seq_a_minus_seq_b (ba_info_ptr->reordering_buffer_ptr->sequence_number, 
														  ba_info_ptr->peer_starting_seq_num, ba_info_ptr->peer_block_size);
			ba_info_ptr->status_bitmap [bitmap_location] = 0;
			
			/* Remove the MSDU record.									*/
			msdu_info_ptr = ba_info_ptr->reordering_buffer_ptr;
			ba_info_ptr->reordering_buffer_ptr = ba_info_ptr->reordering_buffer_ptr->next_msdu_ptr;
			op_prg_mem_free (msdu_info_ptr);
			}
		}
	
	/* Check whether the MPDU is the first of its MSDU.					*/
	if (ba_info_ptr->status_bitmap [seq_num_diff] == 0)
		{
		/* Create a record for this new MSDU.							*/
		msdu_info_ptr = (WlanT_BA_Buffered_MSDU *) op_prg_pmo_alloc (ba_info_ptr->buffered_msdu_pmh);
		msdu_info_ptr->sequence_number = mpdu_seq_num;
		msdu_info_ptr->frame_type      = frame_type;
		msdu_info_ptr->final_dest_addr = final_dest_addr;
		msdu_info_ptr->hl_protocol	   = protocol_type;
		msdu_info_ptr->pkt_id          = data_pkt_id;
		msdu_info_ptr->ack_policy	   = ack_policy;
		
		/* The MSDU is complete of if this is its only MPDU.			*/
		if (more_frag == 0 && mpdu_frag_num == 0)
			{
			msdu_info_ptr->complete      = OPC_TRUE;
			msdu_info_ptr->num_fragments = 1;
			}
		else 
			{
			msdu_info_ptr->complete = OPC_FALSE;
			msdu_info_ptr->num_fragments = (more_frag == 0) ? mpdu_frag_num + 1 : FRAG_NUM_UNKNOWN;
			}
		
		/* Now create a record for the received MPDU and store it under	*/
		/* the MSDU record.												*/
		mpdu_info_ptr = (WlanT_BA_Buffered_MPDU *) op_prg_pmo_alloc (ba_info_ptr->buffered_mpdu_pmh);
		mpdu_info_ptr->mpdu_data_pkptr = mpdu_body_pkptr;
		mpdu_info_ptr->next_mpdu_ptr   = OPC_NIL;
		msdu_info_ptr->mpdu_lptr       = mpdu_info_ptr;
		
		/* Insert the MSDU record into reordering buffer.				*/
		if (ba_info_ptr->reordering_buffer_ptr == OPC_NIL)
			{
			/* Buffer is empty. The new MSDU will be the only entry in	*/
			/* it.														*/
			ba_info_ptr->reordering_buffer_ptr = msdu_info_ptr;
			ba_info_ptr->last_rcvd_msdu_ptr    = msdu_info_ptr;			
			}
		else
			{
			/* If the new MSDU has a sequence number less than the		*/
			/* previous one then start searching from top of the buffer.*/
			if (SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->last_rcvd_msdu_ptr->sequence_number, mpdu_seq_num, ba_info_ptr->peer_block_size))
				{
				/* Check for the special case when the new MSDU has to	*/
				/* be added to the top of the buffer.					*/
				if (SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->reordering_buffer_ptr->sequence_number, mpdu_seq_num, ba_info_ptr->peer_block_size))
					{
					/* Add the new MSDU to the head.					*/
					msdu_info_ptr->next_msdu_ptr =  ba_info_ptr->reordering_buffer_ptr;
					ba_info_ptr->reordering_buffer_ptr = msdu_info_ptr;
					ba_info_ptr->last_rcvd_msdu_ptr    = msdu_info_ptr;
					}
				else
					/* Start the search from top.						*/
					ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
				}
			
			/* Search the buffer. Although this search is sequential,	*/
			/* in most cases we add the new MSDU to the end of the list	*/
			/* and we start searching with the last element of the		*/
			/* list. Hence, most of the time, the loop below will be	*/
			/* iterated only once.										*/
			while (ba_info_ptr->last_rcvd_msdu_ptr != msdu_info_ptr)
				{
				if (ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr == OPC_NIL)
					{
					/* We are adding the new MSDU to the end.			*/
					msdu_info_ptr->next_msdu_ptr = OPC_NIL;
					ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr = msdu_info_ptr;
					ba_info_ptr->last_rcvd_msdu_ptr = msdu_info_ptr;
					}
				else if (SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr->sequence_number, mpdu_seq_num, ba_info_ptr->peer_block_size))
					{
					/* We are adding the new MSDU to the middle.		*/
					msdu_info_ptr->next_msdu_ptr = ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr;
					ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr = msdu_info_ptr;
					ba_info_ptr->last_rcvd_msdu_ptr = msdu_info_ptr;
					}
				else
					{
					/* Move to the next entry in the buffer.			*/
					ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr;
					}
				}
			}
		
		/* Update the status bitmap.									*/
		ba_info_ptr->status_bitmap [seq_num_diff] |= (0x1 << mpdu_frag_num);
		}
	else
		{
		/* Find the record of MPDU's MSDU. It is likely to belong to	*/
		/* the same MSDU with the previous MPDU. If the sequence number	*/
		/* of the new one is smaller than the previous one, start the	*/
		/* search from the head of the buffer since this likely to be a	*/
		/* retransmission.												*/
		if (mpdu_seq_num != ba_info_ptr->last_rcvd_msdu_ptr->sequence_number)
			{
			if (SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->last_rcvd_msdu_ptr->sequence_number, mpdu_seq_num, ba_info_ptr->peer_block_size))
				ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
			while (mpdu_seq_num != ba_info_ptr->last_rcvd_msdu_ptr->sequence_number)
				ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->last_rcvd_msdu_ptr->next_msdu_ptr;			
			}
		
		/* Update the status bitmap.									*/
		ba_info_ptr->status_bitmap [seq_num_diff] |= (0x1 << mpdu_frag_num);

		/* Record the number of the fragments of this is the last		*/
		/* (tail) fragment.												*/
		if (more_frag == 0)
			ba_info_ptr->last_rcvd_msdu_ptr->num_fragments = mpdu_frag_num + 1;
		
		/* Does this MPDU complete its MSDU?							*/
		if (ba_info_ptr->last_rcvd_msdu_ptr->num_fragments != FRAG_NUM_UNKNOWN && 
			(((0xFFFF << ba_info_ptr->last_rcvd_msdu_ptr->num_fragments) ^ ba_info_ptr->status_bitmap [seq_num_diff]) & 0xFFFF) == 0xFFFF)
			ba_info_ptr->last_rcvd_msdu_ptr->complete = OPC_TRUE;
		
		/* Create an MPDU record and add it to the MPDU list of the		*/
		/* MSDU.														*/
		mpdu_info_ptr = (WlanT_BA_Buffered_MPDU *) op_prg_pmo_alloc (ba_info_ptr->buffered_mpdu_pmh);
		mpdu_info_ptr->mpdu_data_pkptr = mpdu_body_pkptr;
		mpdu_info_ptr->next_mpdu_ptr   = ba_info_ptr->last_rcvd_msdu_ptr->mpdu_lptr;
		ba_info_ptr->last_rcvd_msdu_ptr->mpdu_lptr = mpdu_info_ptr;		
		}
	
	/* Increment the MPDU counter.										*/
	ba_info_ptr->rcvd_mpdu_count++;
	
	/* If running, reset the inactivity timer, unless the ACK policy	*/
	/* was not block-ACK.												*/
	if (ack_policy == WlanC_Block_ACK && ba_info_ptr->peer_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
		{
		op_ev_cancel (ba_info_ptr->peer_inactivity_evh);
		op_ev_state_install (ba_info_ptr, OPC_NIL);
		ba_info_ptr->peer_inactivity_evh = 
			op_intrpt_schedule_self (current_time + ba_info_ptr->peer_timeout_value, WlanC_BA_Inactive_Tout_Rcpt);
		op_ev_state_install (OPC_NIL, OPC_NIL);
		}
	
	FOUT;
	}

static void
wlan_hcf_bar_process (OpT_Int64 peer_addr, Packet* rcvd_frame_pkptr)
	{
	WlanT_BA_Control_Fields*	ba_cntl_fields_ptr;
	WlanT_HCF_BA_State*			ba_info_ptr;
	WlanT_BA_Buffered_MSDU*		current_msdu_ptr;
	WlanT_BA_Buffered_MPDU*		temp_mpdu_ptr;
	Packet*						msdu_pkptr;
	int							bar_seq_num, cur_seq_num;
	int							seq_num_shift;
	char						msg_string [256];
	
	/** This function processes the given BAR message and prepares the	**/
	/** BA response message (immediate or delayed) with respect to the	**/
	/** rules specified in the 802.11e standard.						**/
	FIN (wlan_hcf_bar_process (peer_addr, rcvd_frame_pkptr));
	
	/* Remove the BAR specific fields of the control frame. We will use	*/
	/* the same structure in our block ACK.								*/
	op_pk_fd_get_ptr (rcvd_frame_pkptr, WLANC_CNTL_BA_FD, (void **) &ba_cntl_fields_ptr);
	
	/* Get the BA state information with this peer and TID.				*/
	if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
		ba_info_ptr = ap_peer_info_ptr->ba_state_ptr_arr [ba_cntl_fields_ptr->tid];
	else
		ba_info_ptr = 
			((WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(peer_addr)))->ba_state_ptr_arr [ba_cntl_fields_ptr->tid];
	
	/* First, make sure that we received this BAR from a peer/TID, with	*/
	/* which we have a BA agreement, which may not be the case if we	*/
	/* have torn down the agreement due to inactivity and the peer is	*/
	/* not aware of that.												*/
	if (ba_info_ptr == OPC_NIL || ba_info_ptr->peer_block_size == 0)
		{
		/* Respond with an ACK.											*/
		fresp_to_send = WlanC_Ack;
		response_sta_addr = peer_addr;
		
		/* If enabled, write an ODB message.							*/
		if (wlan_trace_active)
			{				
			sprintf (msg_string, "Received a BAR from STA "OPC_INT64_FMT" for TID %d despite a nonexistent BA agreement.", peer_addr, ba_cntl_fields_ptr->tid); 
			op_prg_odb_print_major (msg_string, "Discarding BAR and enqueuing a DELBA message for this STA.", OPC_NIL);
			}
		
		/* Enqueue a DELBA message for this peer/TID.					*/
		wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_DELBA, ba_cntl_fields_ptr->tid, peer_addr, 0, OPC_FALSE);
		
		/* Discard the information received with the BAR message.		*/
		op_prg_mem_free (ba_cntl_fields_ptr);
		
		FOUT;
		}
	
	/* Check for duplicates or erroneous cases.							*/
	if (ba_info_ptr->block_ack_fields_ptr != OPC_NIL)
		{
		if (ba_info_ptr->peer_policy == WlanC_Delayed_BA)
			{
			/* This is a BAR we are receiving as a duplicate. Discard	*/
			/* it without processing; though we still need to respond	*/
			/* with an ACK.												*/
			fresp_to_send = WlanC_Ack;
			response_sta_addr = peer_addr;
			op_prg_mem_free (ba_cntl_fields_ptr);
		
			/* If enabled, write an ODB message.						*/
			if (wlan_trace_active)
				{				
				sprintf (msg_string, "Received a duplicate BAR from STA "OPC_INT64_FMT" for TID %d! Discarding.", ba_info_ptr->peer_addr, ba_info_ptr->tid); 
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}

			FOUT;
			}
		else
			{
			/* This indicates that we could not send our BA to the last	*/
			/* BAR we received from this peer for this TID because of	*/
			/* an activity on the medium during our SIFS waiting time.	*/
			/* Clear the information kept from previous BAR, since we	*/
			/* will now	respond to this BAR.							*/
			op_prg_mem_free (ba_info_ptr->block_ack_fields_ptr);
			}
		}

	/* If enabled, write an ODB message.								*/
	if (wlan_trace_active)
		{				
		sprintf (msg_string, "Received a BAR from STA "OPC_INT64_FMT" for TID %d.", ba_info_ptr->peer_addr, ba_info_ptr->tid); 
		op_prg_odb_print_major (msg_string, OPC_NIL);
		}
		
	/* Store the BAR's starting sequence number into a local variable	*/
	/* for quick access.												*/
	bar_seq_num = ba_cntl_fields_ptr->starting_seq_num;
	
	/* First forward any complete MSDUs in our reordering buffer whose	*/
	/* sequence numbers are smaller than the starting sequence number	*/
	/* of the BAR.														*/
	while (ba_info_ptr->reordering_buffer_ptr != OPC_NIL && 
		   SEQ_A_GREATER_THAN_SEQ_B (bar_seq_num, ba_info_ptr->reordering_buffer_ptr->sequence_number, ba_info_ptr->peer_block_size))
		{
		/* Is the MSDU complete? Some complete MSDUs may have their		*/
		/* MPDUs already reassembled and forwarded in case sometime		*/
		/* earlier the reordering buffer was full when a new MPDU was	*/
		/* received and some complete MSDUs were reassembled to free	*/
		/* some space in the buffer.									*/
		current_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
		if (current_msdu_ptr->complete == OPC_TRUE && current_msdu_ptr->mpdu_lptr != OPC_NIL)
			{
			/* Reassemble the MSDU.										*/
			msdu_pkptr = wlan_hcf_buffered_ba_msdu_reassemble (current_msdu_ptr);
			
			/* Decrease the number of MPDUs in the reordering buffer.	*/
			ba_info_ptr->rcvd_mpdu_count -= current_msdu_ptr->num_fragments;
			
			/* Process the reassembled MSDU: forward to the higher		*/
			/* layer or enqueue it to transmit to its final destination	*/
			/* in the BSS.												*/
			
			/*Loren
			sprintf(myString,"I am %d, starting frame forward function 4.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			*/
			
			wlan_hcf_completed_frame_forward (msdu_pkptr, peer_addr, my_address, current_msdu_ptr->final_dest_addr, 
											  current_msdu_ptr->hl_protocol, current_msdu_ptr->pkt_id, ba_cntl_fields_ptr->tid);
			}
		else if (current_msdu_ptr->complete == OPC_FALSE)
			{
			/* Print an ODB trace message if enabled.					*/
			if (wlan_trace_active)
				{				
				sprintf (msg_string, "Destroying the MPDUs of the incomplete MSDU in reordering buffer with seq # = %d.", current_msdu_ptr->sequence_number);
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			
			/* Destroy the buffered MPDUs of the MSDU, if any, which	*/
			/* can't be completed.										*/
			while (current_msdu_ptr->mpdu_lptr != OPC_NIL)
				{
				temp_mpdu_ptr = current_msdu_ptr->mpdu_lptr;
				current_msdu_ptr->mpdu_lptr = temp_mpdu_ptr->next_mpdu_ptr;
				op_pk_destroy (temp_mpdu_ptr->mpdu_data_pkptr);
				op_prg_mem_free (temp_mpdu_ptr);

				/* Decrement the number of MPDUs in the reordering		*/
				/* buffer.												*/
				ba_info_ptr->rcvd_mpdu_count--;			
				}
			}
		
		/* Destroy the MSDU record since we are done with this MSDU.	*/
		ba_info_ptr->reordering_buffer_ptr = current_msdu_ptr->next_msdu_ptr;
		op_prg_mem_free (current_msdu_ptr);
		}
		
	/* Now forward all the complete MSDU at the head of the reordering	*/
	/* buffer until the first uncomplete MSDU. Adjust the starting		*/
	/* sequence number if BAR's starting number is behind the sequence	*/
	/* number of the MSDU that we forwarded last when we received the	*/
	/* previous BAR.													*/
	cur_seq_num = (SEQ_A_GREATER_THAN_SEQ_B (bar_seq_num , ba_info_ptr->last_fwd_seq_num, ba_info_ptr->peer_block_size)) ? 
				  bar_seq_num : (ba_info_ptr->last_fwd_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
	while (ba_info_ptr->reordering_buffer_ptr != OPC_NIL && ba_info_ptr->reordering_buffer_ptr->sequence_number == cur_seq_num &&
		   ba_info_ptr->reordering_buffer_ptr->complete == OPC_TRUE)
		{
		/* Some complete MSDUs may have their MPDUs already reassembled	*/
		/* and forwarded in case sometime earlier the reordering buffer	*/
		/* was full when a new MPDU was	received and some complete		*/
		/* MSDUs were reassembled to free some space in the buffer.		*/
		current_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
		if (current_msdu_ptr->mpdu_lptr != OPC_NIL)
			{
			/* Reassemble the MSDU.										*/
			msdu_pkptr = wlan_hcf_buffered_ba_msdu_reassemble (current_msdu_ptr);
			
			/* Decrease the number of MPDUs in the reordering buffer.	*/
			ba_info_ptr->rcvd_mpdu_count -= current_msdu_ptr->num_fragments;
			
			/* Process the reassembled MSDU: forward to the higher		*/
			/* layer or	enqueue it to transmit to its final destination	*/
			/* in the BSS.												*/
			
			/*Loren
			sprintf(myString,"I am %d, starting frame forward function 5.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			*/
			
			wlan_hcf_completed_frame_forward (msdu_pkptr, peer_addr, my_address, current_msdu_ptr->final_dest_addr, current_msdu_ptr->hl_protocol,
											  current_msdu_ptr->pkt_id, ba_cntl_fields_ptr->tid);
			}

		/* Destroy the MSDU record since we are done with this MSDU.	*/
		ba_info_ptr->reordering_buffer_ptr = current_msdu_ptr->next_msdu_ptr;
		op_prg_mem_free (current_msdu_ptr);
		
		/* Update the sequence number for the next expected MSDU.		*/
		cur_seq_num = (cur_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
		}
	
	/* Record the sequence number of last forwarded MSDU.				*/
	ba_info_ptr->last_fwd_seq_num = (cur_seq_num == 0) ? WLANC_SEQ_NUM_WRAP_VALUE - 1 : cur_seq_num - 1;
	
	/* Make the last received MSDU point to the head of reordering		*/
	/* buffer. If the buffer is not empty then the first MPDU we will	*/
	/* receive will most likely belong to the first missing/incomplete	*/
	/* MSDU, which is/will become actually the head of the reordering	*/
	/* buffer.															*/
	ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
	
	/* If enabled, write an ODB message.								*/
	if (wlan_trace_active)
		{
		if (ba_info_ptr->reordering_buffer_ptr == OPC_NIL)
			op_prg_odb_print_major ("After processing the BAR, reordering buffer was emptied.", OPC_NIL);
		else
			{
			sprintf (msg_string, "%d MPDU(s), and first missing sequence number is %d.", ba_info_ptr->rcvd_mpdu_count, cur_seq_num); 
			op_prg_odb_print_major ("After processing the BAR reordering buffer contains", msg_string, OPC_NIL);
			}
		}
		
	/* Shift our status bitmap in order to start with the new sequence	*/
	/* control. 														*/
	seq_num_shift = wlan_hcf_seq_a_minus_seq_b (bar_seq_num, ba_info_ptr->peer_starting_seq_num, ba_info_ptr->peer_block_size);
	if (seq_num_shift > 0)
		wlan_hcf_ba_status_bitmap_shift (ba_info_ptr, seq_num_shift);
	
	/* Prepare our response. Set the recipient of our response and the	*/
	/* corresponding TID.												*/
	response_sta_addr = peer_addr;
	rcvd_bar_tid      = ba_cntl_fields_ptr->tid;
	
	/* We will respond with a block ACK or regular ACK depending on the	*/
	/* policy.															*/
	if (ba_info_ptr->peer_policy == WlanC_Immediate_BA)
		{
		/* We will respond with a block ACK.							*/
		fresp_to_send = WlanC_BA;
		
		/* Copy the status bitmap into BA control structure since we	*/
		/* will send our block ACK message immediately.					*/
		op_prg_mem_copy (ba_info_ptr->status_bitmap, &(ba_cntl_fields_ptr->status_bitmap), WLANC_BA_STATUS_BITMAP_SIZE);
		}
	else
		{
		/* Our immediate response will be a regular ACK.				*/
		fresp_to_send = WlanC_Ack;
		
		/* Enqueue an entry in the Voice AC transmission buffer for the	*/
		/* block ACK we need to send.									*/
		wlan_hcf_ba_control_enqueue (WlanC_BA, peer_addr, (OpT_uInt8) ba_cntl_fields_ptr->tid, WlanC_AC_VO);
		}
	
	/* Keep a handle in the BA state information record to the BA		*/
	/* control structure, which will include in our block ACK message.	*/
	ba_info_ptr->block_ack_fields_ptr = ba_cntl_fields_ptr;
	
	/* If running, reset the BA inactivity timer.						*/
	if (ba_info_ptr->peer_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
		{
		op_ev_cancel (ba_info_ptr->peer_inactivity_evh);
		op_ev_state_install (ba_info_ptr, OPC_NIL);
		ba_info_ptr->peer_inactivity_evh = 
			op_intrpt_schedule_self (current_time + ba_info_ptr->peer_timeout_value, WlanC_BA_Inactive_Tout_Rcpt);
		op_ev_state_install (OPC_NIL, OPC_NIL);
		}
	
	FOUT;
	}

static void
wlan_hcf_ba_status_bitmap_shift (WlanT_HCF_BA_State* ba_info_ptr, int seq_num_shift_amount)
	{
	OpT_uInt16*					new_status_bitmap;
	OpT_uInt16*					new_start_ptr;
	int							i;

	/** This function shifts the starting point of the sequence numbers	**/
	/** represented in the given block-ACK status bitmap by the given	**/
	/** amount and updates the status bitmap accordingly.				**/
	FIN (wlan_hcf_ba_status_bitmap_shift (ba_info_ptr, seq_num_shift_amount));
	
	/* Create a new bitmap.												*/
	new_status_bitmap = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_BA_RECIPIENT_SB_MAX_MSDU * sizeof (OpT_uInt16));
	
	/* Get the starting point of the new bitmap on the old bitmap.		*/
	new_start_ptr = &(ba_info_ptr->status_bitmap [seq_num_shift_amount]);
		
	/* Copy the common parts from old bitmap to the new bitmap.			*/
	op_prg_mem_copy (new_start_ptr, new_status_bitmap, (WLANC_BA_RECIPIENT_SB_MAX_MSDU - seq_num_shift_amount) * sizeof (OpT_uInt16));
	
	/* Reset the new part of the new bitmap.							*/
	for (i = WLANC_BA_RECIPIENT_SB_MAX_MSDU - seq_num_shift_amount; i < WLANC_BA_RECIPIENT_SB_MAX_MSDU; i++)
		new_status_bitmap [i] = 0;
	
	/* Destroy the old bitmap and switch to the new one.				*/
	op_prg_mem_free (ba_info_ptr->status_bitmap);
	ba_info_ptr->status_bitmap = new_status_bitmap;
	ba_info_ptr->peer_starting_seq_num = (ba_info_ptr->peer_starting_seq_num + seq_num_shift_amount) % WLANC_SEQ_NUM_WRAP_VALUE;
	
	FOUT;
	}

static void
wlan_hcf_delayed_ba_complete_msdu_check (WlanT_HCF_BA_State* ba_info_ptr)
	{
	WlanT_BA_Buffered_MSDU*	current_msdu_ptr;
	Packet*					msdu_pkptr;
	
	/** This function is called only by the recipient of a block-ACK	**/
	/** agreement when the policy is "delayed BA". It checks whether	**/
	/** there are any complete MSDUs in the reordering buffer that		**/
	/** were received after the BAR until now and allowed to be			**/
	/** forwarded to the higher layer. If any such MSDU is found, it is	**/
	/** reassembled and forwarded.										**/
	FIN (wlan_hcf_delayed_ba_complete_msdu_check (ba_info_ptr));
	
	/* Reassemble and forward any MSDU that is at the head of the		*/
	/* reordering buffer, the next MSDU expected by the higher layer,	*/
	/* and complete.													*/
	while (ba_info_ptr->reordering_buffer_ptr != OPC_NIL && ba_info_ptr->reordering_buffer_ptr->complete == OPC_TRUE &&
		   ba_info_ptr->reordering_buffer_ptr->sequence_number == (ba_info_ptr->last_fwd_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE)
		{
		/* Reassemble the MSDU unless it has been already done.			*/	
		current_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
		if (current_msdu_ptr->mpdu_lptr != OPC_NIL)
			{
			/* Reassemble the MSDU.										*/
			msdu_pkptr = wlan_hcf_buffered_ba_msdu_reassemble (current_msdu_ptr);
			
			/* Decrease the number of MPDUs in the reordering buffer.	*/
			ba_info_ptr->rcvd_mpdu_count -= current_msdu_ptr->num_fragments;
			
			/* Process the reassembled MSDU: forward to the higher		*/
			/* layer or	enqueue it to transmit to its final destination	*/
			/* in the BSS.												*/
			
			/*Loren
			sprintf(myString,"I am %d, starting frame forward function 6.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
			*/
			
			wlan_hcf_completed_frame_forward (msdu_pkptr, ba_info_ptr->peer_addr, my_address, current_msdu_ptr->final_dest_addr, 
											  current_msdu_ptr->hl_protocol, current_msdu_ptr->pkt_id, ba_info_ptr->tid);
			}

		/* Destroy the MSDU record since we are done with this MSDU.	*/
		ba_info_ptr->reordering_buffer_ptr = current_msdu_ptr->next_msdu_ptr;
		op_prg_mem_free (current_msdu_ptr);
		
		/* Update the sequence number for the last forwarded MSDU.		*/
		ba_info_ptr->last_fwd_seq_num = (ba_info_ptr->last_fwd_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
		}

	/* Make the last received MSDU point to the head of reordering		*/
	/* buffer. 															*/
	ba_info_ptr->last_rcvd_msdu_ptr = ba_info_ptr->reordering_buffer_ptr;
	
	FOUT;
	}

static Packet*
wlan_hcf_buffered_ba_msdu_reassemble (WlanT_BA_Buffered_MSDU* msdu_info_ptr)
	{
	WlanT_BA_Buffered_MPDU*		temp_mpdu_ptr;
	char						msg_string [128];

	/** This function reassembles the MSDU, whose record is provided,	**/
	/** using its MPDU(s) in the reordering buffer. It assumes that all	**/
	/** MPDUs of the MSDU were received.								**/
	FIN (wlan_hcf_buffered_ba_msdu_reassemble (msdu_info_ptr));
	
	/* Reassemble the MSDU using the common reassembly buffer.			*/
	do
		{
		temp_mpdu_ptr = msdu_info_ptr->mpdu_lptr;
		msdu_info_ptr->mpdu_lptr = temp_mpdu_ptr->next_mpdu_ptr;
		op_sar_rsmbuf_seg_insert (common_rsmbuf_ptr, temp_mpdu_ptr->mpdu_data_pkptr);
		op_prg_mem_free (temp_mpdu_ptr);
		} while (msdu_info_ptr->mpdu_lptr != OPC_NIL);
	
	/* Print an ODB trace message if enabled.							*/
	if (wlan_trace_active)
		{				
		sprintf (msg_string, "Reassembling MSDU in reordering buffer with sequence number = %d.", msdu_info_ptr->sequence_number);
		op_prg_odb_print_major (msg_string, OPC_NIL);
		}
	
	/* Return the completed packet.										*/
	FRET (op_sar_rsmbuf_pk_remove (common_rsmbuf_ptr));
	}


void faceDetection( IplImage* img, char * in,char * d,double *accu, double *error,double truthArray[][2] )
{
    int scale = 1;
    CvPoint pt1, pt2;
    int i;
	int detectedFaces = 0, fulseError = 0, foundflag = 0, ff=0,fc=0;
	FILE * truthFile;
	char truthFileName[300] = "";

	FIN (faceDetection (img, in, d, accu, error, truthArray[][2]));

    // Clear the memory storage which was used before
    cvClearMemStorage( storage );
	
	if(opencvDebugFlag)
		{
		
		//printf("%f,%f\n",truthArray[0][0],truthArray[0][1]);
		printf("%s\n",cascade_name);
		
		opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
		fprintf(opencvDebugFile,"face detection called\n");
		fclose(opencvDebugFile);
		}

	// Find whether the cascade is loaded, to find the faces. If yes, then:
    if( cascade )
    {

        // There can be more than one face in an image. So create a growable sequence of faces.
        // Detect the objects and store them in the sequence
        CvSeq* faces = cvHaarDetectObjects( img, cascade, storage,
                                            1.1, 2, CV_HAAR_DO_CANNY_PRUNING,
                                            cvSize(24, 24),cvSize(0, 0));
		
		if(opencvDebugFlag)
		{
			opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
			fprintf(opencvDebugFile,"detected face number %d\n",(faces ? faces->total : 0));
			fclose(opencvDebugFile);
		}
			


		//strcat(imageName,"_results.txt");
		//myfile = fopen(imageName,"w");
		
		if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0 || 
			strcmp(curve,"accu_quality_GT_withoutNI")==0 || strcmp(curve,"accu_quality_GT_withoutNI")==0 )
			;//truth data is already in truthArray
		else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\SCFace\\groundTruth\\distance1\\%s\\%s.txt",d,in);
		else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\SCFace\\groundTruth\\distance2\\%s\\%s.txt",d,in);
		else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\SCFace\\groundTruth\\distance3\\%s\\%s.txt",d,in);
		else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\CMU_MIT\\cmumitGroundTruth\\%s\\%s.txt",d,in);
		else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\CMU_MIT\\cmumitGroundTruth\\%s\\%s.txt",d,in);
		else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
			sprintf(truthFileName,"C:\\facedatabase\\CMU_MIT\\cmumitGroundTruth\\%s\\%s.txt",d,in);
		
		
		
		if(opencvDebugFlag)
		{
			opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
			fprintf(opencvDebugFile,"truth file name is %s\n",truthFileName);
			fclose(opencvDebugFile);
		}
			
		if(strcmp(curve,"accu_quality_GT50_withNI")!=0 && strcmp(curve,"accu_quality_GT50_withoutNI")!=0 
			&& strcmp(curve,"accu_quality_GT_withoutNI")!=0 && strcmp(curve,"accu_quality_GT75_withoutNI")!=0)//truth data is already in truth file
			{
			truthFile = fopen(truthFileName,"r");
			fc = 0;
			while(fgets(truthFileName, sizeof truthFileName, truthFile))
				{
			
				if(sscanf(truthFileName, "%lf,%lf", &truthArray[fc][0], &truthArray[fc][1]) == 2)
					{
					if(opencvDebugFlag)
						{
						opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
						fprintf(opencvDebugFile,"reading information from truth file for face number %d\n",fc);
						fclose(opencvDebugFile);
						}
					
					++fc;	
					}
				}
			fclose(truthFile);
			}
		else 
			fc = 1;
		
		if(fc != 0)
			{
				
			// Loop the number of faces found.
			for( i = 0; i < (faces ? faces->total : 0); i++ )
				{							
				// Create a new rectangle for drawing the face
				CvRect* r = (CvRect*)cvGetSeqElem( faces, i );
				// Find the dimensions of the face,and scale it if necessary
				pt1.x = r->x;
				pt2.x = (r->x+r->width);
				pt1.y = r->y;
				pt2.y = (r->y+r->height);
				
				
				if(opencvDebugFlag)
					{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"start checking truth for face number %d\n",i);
					fclose(opencvDebugFile);
					}

				for (ff = 0 ; ff < fc;ff++)
					if(truthArray[ff][0] > pt1.x && truthArray[ff][1] > pt1.y && truthArray[ff][0] < pt2.x && truthArray[ff][1] < pt2.y)
						{
						detectedFaces = detectedFaces+1;
						foundflag=1;//truth(ff,1)=0;truth(ff,2)=0;
						truthArray[ff][0] = 0;//we do not need it to be counted again
						truthArray[ff][1] = 0;
											
						break;
						}
				if(opencvDebugFlag)
					{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"end checking truth for face number %d\n",i);
					fclose(opencvDebugFile);
					}
                
				if (!foundflag)
					fulseError = fulseError + 1; 
				foundflag = 0;
		
				}
			//added to check the cumulative detection accuracy for this algorithm.
			totalDetectedFaces += detectedFaces;
			totalActualFaces += fc;
			totalDetectionAccuracy = ((double)totalDetectedFaces/(double)totalActualFaces)*100;
			
			//get the instantaneous accuracy and error.
			*accu = (double) detectedFaces/fc;
			*error = (double) fulseError/fc;
			printf("Face Detection Accuracy = %.5f%%\nCurrent Accuracy = %.5f\n", totalDetectionAccuracy, *accu);
			}
		else
			{
			//total detected faces and accuracy.
			totalDetectedFaces += faces->total;
			totalDetectionAccuracy = ((double)totalDetectedFaces/(double)totalActualFaces)*100;
			
			//instantaneous accuracy and error.
			*accu = (double) (faces ? 0 : 1);
			*error = (double) (faces ? faces->total : 0);
			printf("Face Detection Accuracy = %.5f%%\n", *accu);
			}
			
	}
	FOUT;
}

// Loren added
// Reads the csv associated with the training files and places the images and names into vectors
// added "std::" before vector to allow c++ to use vector types.
static void read_csv(const string& filename, std::vector<cv::Mat>& images, std::vector<int>& labels, char separator = ';') {

	FIN (read_csv (filename, images, labels,separator));
	
    std::ifstream file(filename.c_str(), std::ifstream::in);
    if (!file) {
        std::string error_message = "No valid input file was given, please check the given filename.";
        CV_Error(CV_StsBadArg, error_message);
    }
    std::string line, path, classlabel;
    while (getline(file, line)) {
        stringstream liness(line);
        getline(liness, path, separator);
        getline(liness, classlabel);
        if(!path.empty() && !classlabel.empty()) {
			//sprintf(myString, "%s", path.c_str());
			//op_prg_odb_print_major(myString,OPC_NIL);
            images.push_back(cv::imread(path, 0));
            labels.push_back(atoi(classlabel.c_str()));
			/*
			cv::Mat m = cv::imread(path, 1);
			imshow("gathered Image", m);
			cv::Mat m2;
			cv::cvtColor(m,m2,CV_BGR2GRAY);
			images.push_back(m2);
			*/
        }
    }
	FOUT;
}



static void trainFaces(int src_addr)
{
	using namespace cv;
	
	std::string fn_csv;
	FIN (trainFaces (scr_addr));
	
	// Get the path to your CSV:
	if((int)src_addr == 1)
	{
		fn_csv = "G:\\Masters_Thesis_Files\\Honda1.csv"; 
	}

	else if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0 || 
	   strcmp(curve,"accu_quality_GT_withoutNI")==0 || strcmp(curve,"accu_quality_GT_withoutNI")==0)
		{
			//sprintf(fn_csv,"C:\\facedatabase\\gt_db50.csv");
			fn_csv = "C:\\facedatabase\\gt_db50.csv"; // select georgia tech csv.
		}
	else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0 ||
		    strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0 ||
		    strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)
			{
				sprintf(myString,"Error: scface files do not exist.");
				op_prg_odb_print_major(myString,OPC_NIL);
				return;// this wont work std::string fn_csv = "C:\facedatabase\gt_db50.csv"; // select scface csv.
			}

	else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0 ||
		    strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0 || strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
			{
				//sprintf(fn_csv,"C:\\facedatabase\\CMU_MIT.csv");
				fn_csv = "C:\\facedatabase\\CMU_MIT.csv"; // select georgia tech csv.
			}
	else
		{
			sprintf(myString,"Error: csv could not be selected.");
			op_prg_odb_print_major(myString,OPC_NIL);
			return;
		}
			

    //string fn_haar = cascade);		// we don't need to load the xml because it is a global assigned elsewhere.
    
    if(LorenDebugFlag)
	{
		printf("CSV file Path: %s\n", fn_csv.c_str());
	}
	
    // These vectors hold the images and corresponding labels:
	// added "std::" before vector to allow c++ to use vector types.
    std::vector<cv::Mat> images;
    std::vector<int> labels;
	

	//sprintf(myString, "Just read the input image width (%d), height (%d), and type (%d).", cols, rows, type);
	//op_prg_odb_print_major(myString,OPC_NIL);	
	if(LorenDebugFlag)
	{
		sprintf(myString,"In face recognition about to read csv.");
		op_prg_odb_print_major(myString,OPC_NIL);
	}
	
    // Read in the data (fails if no valid input filename is given, but you'll get an error message):
    try 
	{
        read_csv(fn_csv, images, labels);
	}
	catch (cv::Exception& e) 
	{
		sprintf(myString,"Error csv could not be read. Reason %s.", e.msg);
		op_prg_odb_print_major(myString,OPC_NIL);
		return;
    }
	
	/*
    // Get the height from the first image. We'll need this
    // later in code to reshape the images to their original
    // size AND we need to reshape incoming faces to this size:
    im_width = images[0].cols;
    im_height = images[0].rows;
	sprintf(myString, "Just read the image width (%d) and height (%d).", im_width, im_height);
	op_prg_odb_print_major(myString,OPC_NIL);
	*/
	// Create a FaceRecognizer and train it on the given images:
    //model = cv::createFisherFaceRecognizer();
	
	if(LorenDebugFlag)
	{
		sprintf(myString,"Just created fisher face model about to train images.");
		op_prg_odb_print_major(myString,OPC_NIL);
	}	
		
	model->train(images, labels);
	
	if(LorenDebugFlag)
	{
		sprintf(myString,"Created FaceRecognizer object.");
		op_prg_odb_print_major(myString,OPC_NIL);
	}
	
	FOUT;
	
}



// Loren start face recognition
void faceRecognition( IplImage* img, cv::Mat& testImg,char * d, int src_addr)
{
	using namespace cv;
	cv::Mat gray;
	char pred[5] = "s00";
	int prediction = 0;
	
	// Min and max face sizes used to speed up face detection.
    int min_face_size = 150;
    int max_face_size = 250;

    // Image height and width for the resized image used in prediction.
    // These values match the dimensions of the training images to improve
    // recognition accuracy.
    im_width =	75;	//images[0].cols;
    im_height =	75;	//images[0].rows;

	FIN (faceRecognition (img, testImg, d, src_addr));
	
	//Loren
	if(LorenDebugFlag)
	{
		sprintf(myString,"Entering face recognition function with image from node %d", (int)src_addr);
		op_prg_odb_print_major(myString,OPC_NIL);
	}
			

	// loop structure to loop through the four frontal face cascades included with OpenCV.
	//for(int j = 0; j<4; j++)
	//{
		// check if the pointer for img is NULL. If it is something went wrong and we should exit the loop.
		if(img == NULL)
		{
			opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
			fprintf(opencvDebugFile,"Image pointer is null, this is bad.\n");
			fclose(opencvDebugFile);
			printf("Image pointer is null, this is bad.\n");
			FOUT;
		}
		
		// create the container for the face cascade classifiers.
		cv::CascadeClassifier haar_cascade;
		
		/*
		//load the xml global assigned elsewhere
		switch(j)
		{
			case 0:
					haar_cascade.load("C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt_tree.xml");// cascade_name was in here.
					sprintf(myString,"Loaded the xml file into the haar_cascade, case 0");
					op_prg_odb_print_major(myString,OPC_NIL);
					break;
			case 1:
					haar_cascade.load("C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");// cascade_name was in here.
					sprintf(myString,"Loaded the xml file into the haar_cascade, case 1");
					op_prg_odb_print_major(myString,OPC_NIL);
					break;
			case 2:
					haar_cascade.load("C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt2.xml");// cascade_name was in here.
					sprintf(myString,"Loaded the xml file into the haar_cascade, case 2");
					op_prg_odb_print_major(myString,OPC_NIL);
					break;
			case 3:
			default:
					haar_cascade.load("C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_default.xml");// cascade_name was in here.
					sprintf(myString,"Loaded the xml file into the haar_cascade, case 3");
					op_prg_odb_print_major(myString,OPC_NIL);
		}*/			
	
		//sprintf(myString,"Loaded the xml file into the haar_cascade");
		//op_prg_odb_print_major(myString,OPC_NIL);
		haar_cascade.load("C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt_tree.xml");// cascade_name was in here.
		
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"Loaded the xml file into the haar_cascade, case 0");
			op_prg_odb_print_major(myString,OPC_NIL);
		}


		
		if((int)src_addr == 1)
		{
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"About to clone testImg into gray");
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			gray = testImg.clone();
			
			if(LorenDebugFlag)
			{
				sprintf(myString,"About to print images");
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			if(imwriteFlag == 0)
			{
				imwrite("G:\\Masters_Thesis_Files\\Honda_Database\\Database1\\Training\\videos\\behzad\\testImg.jpg", testImg);
				imwrite("G:\\Masters_Thesis_Files\\Honda_Database\\Database1\\Training\\videos\\behzad\\gray_image.jpg", gray);
				imwriteFlag = 1;
			}
			
			if(LorenDebugFlag)
			{
				sprintf(myString,"passed print image instructions, about to get gray image type.");
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			int type = gray.type();
			
			if(LorenDebugFlag)
			{
				sprintf(myString,"got gray image type, about to check it. (%d)", type);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			if(type)
			{
				printf("about to call cvtcolor\n");
				cvtColor(gray, gray, CV_BGR2GRAY);
				printf("just called cvtcolor\n");
			}
		}
		else
		{
			// convert input image into Mat format
			cv::Mat frame(img);

			// find the type of the image so that we can check if it is already grayscale.
			int type = frame.type();
			// begin by populating gray with the contents of frame.
			gray = frame.clone();
			if(type)
			{
				printf("about to call cvtcolor\n");
				cvtColor(frame, gray, CV_BGR2GRAY);
				printf("just called cvtcolor\n");
			}
		}
		
		/*
		// if the image is grayscale already there is no need to convert it again.
		if(type)
		{
			printf("about to call cvtcolor\n");
			cvtColor(frame, gray, CV_BGR2GRAY);
			printf("just called cvtcolor\n");
		}
		*/
		
		//deallocate frame data since it is no longer needed.
		//frame.deallocate();
	
		
		if(LorenDebugFlag)
		{
			sprintf(myString,"finished initializing gray image.");
			op_prg_odb_print_major(myString,OPC_NIL);
		}
		// Find the faces in the frame:
		std::vector< cv::Rect_<int> > faces;
		
		
		if(LorenDebugFlag)
		{
			sprintf(myString,"About to detect faces.");
			op_prg_odb_print_major(myString,OPC_NIL);
		}
		//haar_cascade.detectMultiScale(gray, faces);
		
		haar_cascade.detectMultiScale(gray, faces, 1.2, 6, 0|CV_HAAR_SCALE_IMAGE, Size(min_face_size, min_face_size),Size(max_face_size, max_face_size) );
		
		// At this point you have the position of the faces in
		// faces. Now we'll get the faces, make a prediction and
		// annotate it in the video. Cool or what?
	
		int size = (int)faces.size();
		
		// print number of detected faces
		sprintf(myString,"Number of detected faces this loop = %d", size);
		op_prg_odb_print_major(myString,OPC_NIL);

		if(size != 0)
		{
			// loop through all of the faces in the image.
			for(int i = 0; i < size; i++) 
			{
				// Process face by face:
				cv::Rect face_i = faces[i];
				
				// Crop the face from the image. So simple with OpenCV C++:
				cv::Mat face = gray(face_i);
				
				// Resizing the face is necessary for Eigenfaces and Fisherfaces. You can easily
				// verify this, by reading through the face recognition tutorial coming with OpenCV.
				// Resizing IS NOT NEEDED for Local Binary Patterns Histograms, so preparing the
				// input data really depends on the algorithm used.
				//
				// I strongly encourage you to play around with the algorithms. See which work best
				// in your scenario, LBPH should always be a contender for robust face recognition.
				//
				// Since I am showing the Fisherfaces algorithm here, I also show how to resize the
				// face you have just found:
		
				cv::Mat face_resized;
				cv::resize(face, face_resized, cv::Size(im_width, im_height), 1.0, 1.0, cv::INTER_CUBIC);
		
				// Now perform the prediction, see how easy that is:
		
				prediction = model->predict(face_resized);
				
				//release the data for these image objects since they are done being used.
				face.release();
				face_resized.release();
				
				// adjust prediciton to be the same as it's corresponding directory name.
				prediction = prediction + 1;
		
				// size of character array "pred"
				int n = sizeof(pred) / sizeof(pred[0]);
				
				// populate pred, hopefully it won't overflow by using snprintf rather than sprintf.
				snprintf(pred,n,"s%02d", prediction);
				sprintf(myString,"Prediction = %d", prediction);
				op_prg_odb_print_major(myString,OPC_NIL);
				pred[4] = '\0';
				printf("prediction string = %s\n", pred);
				printf("directory string = %s\n", d);
				
				// check if d is a NULL pointer before using it.
				if(d == NULL)
				{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"This is not good #2.\n");
					fclose(opencvDebugFile);
					printf("This is not good #2.\n");
					break;
				}
		
						
				sprintf(myString,"compare prediction");
				op_prg_odb_print_major(myString,OPC_NIL);
				
				//only want the prediction of the first face recognized correctly.
				if(strncmp(d, pred, 4) == 0)
				{
					sprintf(myString,"prediction correct, break from loop");
					op_prg_odb_print_major(myString,OPC_NIL);
					break;
				}
			}
		}
	//}
	
		
	//gray.deallocate();
		
	// check if d is a NULL pointer before using it.
	if(d == NULL)
	{
		opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
		fprintf(opencvDebugFile,"This is not good #3.\n");
		fclose(opencvDebugFile);
		printf("This is not good #3\n");
		FOUT;
	}
	
	if((int)src_addr == 1)
	{
		if(prediction == 1)
		{
			node1total = node1total + 1.0;
			node1correct = node1correct + 1.0;
			printf("node 1 correct recognition predicted, node 1 total recognitions = %d, node 1 correct recognitions = %d", node1total, node1correct);
		}
		else
		{
			node1total = node1total + 1.0;
			printf("node 1 incorrect recognition predicted, node 1 total recognitions = %d, node 1 correct recognitions = %d", node1total, node1correct);
		}
		node1accuracy = (((double)node1correct/(double)node1total)*(double)100);
		// print out accuracy to the simulation console.
		sprintf(myString,"node 1 Face Recognition Accuracy = %.5f%%", node1accuracy);
		op_prg_odb_print_major(myString,OPC_NIL);
		
		// print out the results to the opencv trace file.
		opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
		fprintf(opencvDebugFile,"Prediction = %d\n node 1 Face Recognition Accuracy = %.5f%%\n",prediction, node1accuracy);
		fclose(opencvDebugFile);
	}
	
	else
	{
	// check if the recognition was correct.
	if(strncmp(d, pred, 4) == 0)
	{
		// there was a correct recognition, increment the number, always increment total recogntion count.
		totalRecognitions = totalRecognitions + 1.0;
		correctRecognitions = correctRecognitions + 1.0;
		printf("correct recognition predicted, total recognitions = %d, correct recognitions = %d", totalRecognitions, correctRecognitions);
	}
	
	else
	{
		// increment the total number of recognitions
		totalRecognitions = totalRecognitions + 1.0;
		printf("incorrect recognition predicted, total recognitions = %d, correct recognitions = %d", totalRecognitions, correctRecognitions);
	}
	
	// find current total recogntion accuracy for the simulation so far.  Also protect for divide by zero condition.
	recognitionAccuracy = (((double)correctRecognitions/(double)totalRecognitions)*(double)100);
		
	// print out accuracy to the simulation console.
	sprintf(myString,"Face Recognition Accuracy = %.5f%%", recognitionAccuracy);
	op_prg_odb_print_major(myString,OPC_NIL);
		
	// print out the results to the opencv trace file.
	opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
	fprintf(opencvDebugFile,"Prediction = %d\nFace Recognition Accuracy = %.5f%%\n",prediction, recognitionAccuracy);
	fclose(opencvDebugFile);
	}
	//Loren
	if(LorenDebugFlag)
	{
		sprintf(myString,"Exiting face recognition function with image from node %d", (int)src_addr);
		op_prg_odb_print_major(myString,OPC_NIL);
	}
	
	FOUT;
}








static void
wlan_hcf_completed_frame_forward (Packet* seg_pkptr, OpT_Int64 src_addr, OpT_Int64 dest_addr, OpT_Int64 final_dest_addr, int protocol_type, 
								  OpT_Packet_Id pkt_id, int tid)
	{
	Packet*							copy_pkptr;
	Boolean							send_to_higher;
	WlanT_HCF_Access_Category		tx_ac = WLANC_UP_TO_AC_MAPPING_ARRAY [tid];
	OpT_Packet_Size					pkt_size;
	char							msg_string [128];
	cv::Mat	m;
	
	
	//Loren: Added for running ffmpeg process.
	//cv:: Size s;
	//int rows = 0, cols = 0;
	
	double truthArray[100][2];
	FILE * truthFile;
	char truthFileName[300] = "";

	/*
	HANDLE hPipe;
    DWORD dwWritten;
	*/

	/** This function processes MSDUs that are fully received through	**/
	/** the physical layer, reassembled, and destined to this MAC.		**/
	/** Based on their final destinations, such packets are either		**/
	/** forwarded to the MAC client, enqueued for transmission to its	**/
	/** final destination in the BSS (by APs) or both (in case of		**/
	/** broadcast).														**/
	FIN (wlan_hcf_completed_frame_forward (seg_pkptr, src_addr, dest_addr, final_dest_addr, protocol_type, pkt_id, tid));
	
	
	/*Loren */
	if(LorenDebugFlag)
	{
		sprintf(myString,"I am %d, starting frame forward function. ap_flag = %d", (int)my_address, (int)ap_flag);
		op_prg_odb_print_major(myString,OPC_NIL);
	}
	
	/* Named Pipe Stuff */
	
	/*
	hPipe = CreateFile(TEXT("\\\\.\\pipe\\Pipe"), 
                       GENERIC_READ | GENERIC_WRITE, 
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if (hPipe != INVALID_HANDLE_VALUE)
    {
        WriteFile(hPipe,
                  "Hello Pipe\n",
                  12,   // = length of string + terminating '\0' !!!
                  &dwWritten,
                  NULL);
		
        CloseHandle(hPipe);
    }
	*/
	
	/* End Named Pipe Stuff */
	
if (ap_flag == OPC_BOOLINT_ENABLED) 
	{
	/* If the address is not found in the address list then access	*/
	/* point will sent the data to higher layer for address			*/
	/* resolution. Note that if destination address is same as AP's	*/
	/* address then the packet is sent to higher layer for address	*/
	/* resolution. If the destination address is broadcast address	*/
	/* then the packet is both transmitted within the BSS and also	*/
	/* forwarded to the higher layer.								*/
	if (final_dest_addr == MAC_BROADCAST_ADDR ||
		(final_dest_addr != my_address && prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(final_dest_addr)) != PRGC_NIL))
		{
		
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"I am %d, frame forward function, transmitting data.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
		}
			
		/* Printing out information to ODB.							*/
		if (wlan_trace_active == OPC_TRUE)
			{
			sprintf (msg_string, "All fragments of data packet " OPC_PACKET_ID_FMT " is received by the AP", pkt_id);
			op_prg_odb_print_major (msg_string, "and enqueued for transmission within the BSS.", OPC_NIL);
			}
		
		/* If the destination address is broadcast address then we	*/
		/* need to send a copy also to the higher layer.			*/
		if (final_dest_addr == MAC_BROADCAST_ADDR)
			{
			copy_pkptr = op_pk_copy (seg_pkptr);
			send_to_higher = OPC_TRUE;
			}
		else
			{
			copy_pkptr = seg_pkptr;
			send_to_higher = OPC_FALSE;
			}
		
		/* Enqueuing packet for transmission within a subnet. First	*/
		/* register the outgoing traffic statistics for	the AC of	*/
		/* the packet, if necessary and check whether we have		*/
		/* sufficient buffer space to store the packet.				*/
		if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [tx_ac]))
			wlan_hcf_ac_statistics_register (tx_ac, OPC_TRUE);
		
		/* Check the availability of the buffer space.				*/
		pkt_size = op_pk_total_size_get (copy_pkptr);
		if (total_hlpk_size + pkt_size > hld_max_size)
			{
			/* Buffer is too full to accept the packet.				*/
			wlan_hcf_hl_packet_drop (copy_pkptr, pkt_size, tx_ac);
			}
		else
			{
			/* Enqueue the packet.									*/
			wlan_hcf_hlpk_enqueue (copy_pkptr, tx_ac, final_dest_addr, src_addr, tid, protocol_type, pkt_size, PRGC_NIL);
			}
		}
	else //this packet is coming to the access point
	{

		char tempFileName[1001]="";
		char originalFileName[300] = "";
		int frameN, packetN, packetStatus,FrameSizeInPackets,imageLineNumber,q,i,myDatasize = 0;
		int frameNew = 0;
		double sendingTime;
		IplImage * cvImage, *originalImage;

		double accuracy = 0;
		double accuracyError = 0;
			
		double mse = 255 * 255, psnr = 0;
			
		double startTime = 0;
		int rows = 0, cols = 0;
		int ret, got_picture;
		cv::Size s_source;
		
		
		AVFrame				 *pFrame;
		uint8_t				 *out_buffer;
		AVPacket			 *recv_ffmpeg_packet;
		AVFrame				 dst;

		struct SwsContext    *convert_ctx;
	
		
		
		
		recv_ffmpeg_packet=(AVPacket *)av_malloc(sizeof(AVPacket));
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"I am %d, packet is coming to access point.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);	
		}
		
		if(opencvDebugFlag)
		{
			sprintf(myString,"I am  %d:accuracy is being calculated\n",(int)my_address,(int)my_address, importance);
			op_prg_odb_print_major(myString,OPC_NIL);
		}
		
		printf("I am %d: got packet from node %d.\n", (int)my_address, (int)src_addr);
		
		send_to_higher = OPC_TRUE;
		
		op_pk_format(seg_pkptr, fmt_name);
		//Loren
		printf("I am  %d: seg_pkptr is of type %s\n",(int)my_address, fmt_name);
		
		//printf("pFormatcontext max delay = %d\n", (int)pFormatCtx->max_delay);
		printf("filepath: %s\n", filepath);
		
		//hoon the code that read the data from the packet.
			
		sendingTime = 0;
		
		//op_pk_print(seg_pkptr);
		
		if(strcmp(fmt_name, "my_rtp_pkt") == 0)
		{
			if(LorenDebugFlag)
			{
				printf("entered formatted packet statement\n\n");
			}
			op_pk_nfd_get(seg_pkptr, "frame_counter", &frameN);
			if(LorenDebugFlag)
			{
				printf("got frame counter\n\n");
			}
			op_pk_nfd_get(seg_pkptr, "packet_counter", &packetN);
			if(LorenDebugFlag)
			{
				printf("got packet counter\n\n");
			}
			op_pk_nfd_get(seg_pkptr, "packet_status", &packetStatus);
			if(LorenDebugFlag)
			{
				printf("got packet status\n\n");
			}
			op_pk_nfd_get(seg_pkptr, "FrameSizeInPackets", &FrameSizeInPackets);
			if(LorenDebugFlag)
			{
				printf("got frame size in packets\n\n");
			}
		
		}
		else
		{
		//op_pk_fd_get (seg_pkptr, 0, &sendingTime);
			if(LorenDebugFlag)
			{
				printf("entered unformatted packet statement\n\n");
			}
			op_pk_fd_get (seg_pkptr, 1, &frameN);
			op_pk_fd_get (seg_pkptr, 2, &packetN);
			op_pk_fd_get (seg_pkptr, 3, &packetStatus);
			op_pk_fd_get (seg_pkptr, 4, &FrameSizeInPackets);
		}	
			
		printf("I am %d: got packet from node %d. Frame Number = %d  Packet Number = %d  Frame Size in Packets = %d\n", (int)my_address, (int)src_addr, (int)frameN, (int)packetN, (int)FrameSizeInPackets);
		
		
		if(current_time > EAestimationTime+1)// time sensitive
		{
			//loren debugging
			if(LorenDebugFlag)
			{
				op_pk_print(seg_pkptr);
			}
			
			op_pk_nfd_get (seg_pkptr, "image_line_number", &imageLineNumber);
			
			//loren, debugging
			if(LorenDebugFlag)
			{
				printf("after getting image line number\n");
			}
			
			op_pk_nfd_get (seg_pkptr, "quality", & q);
			
			//loren, debugging
			if(LorenDebugFlag)
			{
				printf("I am %d: got quality, about to load image pointer.\n", (int)my_address);
			}
			
			
			//Loren commment this out if switching to actual image
			op_pk_nfd_get (seg_pkptr, "total_packet_size", &myDatasize);
			
			//loren, debugging
			if(LorenDebugFlag)
			{
				printf("after getting data size.\n");
			}
			
			//unsigned char *getArray = new unsigned char [myDatasize];
			
			//Loren, debugging
			if(LorenDebugFlag)
			{
				printf("after getting creating array.\n");
			}
			
			
			/* don't want to do this right now */
			op_pk_nfd_get (seg_pkptr, "data", &recv_ffmpeg_packet);
			 
			
			//loren, debugging
			if(LorenDebugFlag)
			{
				printf("after getting data array.\n");
			}
			
			
			if((int)src_addr == 1)
			{
				pFrame=av_frame_alloc();
				
				out_buffer=(uint8_t *)av_malloc(avpicture_get_size(dst_pixfmt, pCodecCtx->width, pCodecCtx->height));
				
				avpicture_fill((AVPicture *)&dst, out_buffer, dst_pixfmt, pCodecCtx->width, pCodecCtx->height);
				
				convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, pCodecCtx->pix_fmt, pCodecCtx->width, 
					                         pCodecCtx->height, dst_pixfmt, SWS_FAST_BILINEAR, NULL, NULL, NULL);
				
				printf("packet = %d\n", sizeof(recv_ffmpeg_packet->data));
				printf("packet size = %d\n", recv_ffmpeg_packet->size);
				printf("got packet, checking stream index. it equals: %d. videoindex = %d\n", (int)recv_ffmpeg_packet->stream_index, videoindex);
				
				if(recv_ffmpeg_packet->stream_index==videoindex)
				{
					printf("about to decode packet.\n");
					ret = avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, recv_ffmpeg_packet);
					printf("frame type = %d, return value = %d got_picture = %d\n", (int)pFrame->pict_type, ret, got_picture);
					if(ret < 0)
					{
						printf("Decode Error.\n");
						//break;
						//return -1;
					}
					printf("got_picture = %d\n", got_picture);
					if(got_picture)
					{
						if(convert_ctx == NULL)
						{
							printf("Cannot initialize the conversion context!\n");
							//break;
							//exit(1);
						}
						else
						{
						//printf("pFrame pkt_size = %d\n", pFrame->pkt_size);
						//printf("pFrame picture size = %d\n", avpicture_get_size(dst_pixfmt, pFrame->width, pFrame->height));
						sws_scale(convert_ctx, (const uint8_t* const*)pFrame->data, pFrame->linesize, 0, pFrame->height,
						          dst.data, dst.linesize);
				
						s_source = m.size();
						rows = s_source.height;
						cols = s_source.width;
						
						printf("I am %d: First Frame height = %d, Frame width = %d\n", (int)my_address, rows, cols);
									
									
						m = cv::Mat(pFrame->height, pFrame->width, CV_8UC1, dst.data[0], dst.linesize[0]);
									
						s_source = m.size();
						rows = s_source.height;
						cols = s_source.width;
						printf("I am %d: Second Frame height = %d, Frame width = %d\n", (int)my_address, rows, cols);
						
						//break;
						}
					}
				}
				printf("I am %d: freeing packet.\n", (int)my_address);
				av_free_packet(recv_ffmpeg_packet);
				printf("I am %d: freeing codec context and format context.\n", (int)my_address);
				sws_freeContext(convert_ctx);
				av_frame_free(&pFrame);
			//av_free_packet(ffmpeg_packet);
			}
			
	
						
			
			
			//avcodec_close(pCodecCtx);
			//avformat_close_input(&pFormatCtx);
			
			/*
			if(!cap.isOpened())
				{
				printf("Attempting to capture stream.\n");
				cap.open("C:\\Users\\Loren\\Documents\\Visual Studio 2012\\Projects\\OpencvSetup\\OpencvSetup\\test.sdp");
				if(!cap.isOpened()) {
					printf("Capture cannot be opened.\n");
					}
				}
			
			
			cv::Mat frame;
			
			printf("Capturing frame from stream.\n");
			cap >> frame;
			
			s = frame.size();
			rows = s.height;
			cols = s.width;
			printf("Frame height = %d, Frame width = %d\n", rows, cols);
			*/
		}
		
		//Loren
		//printf("got test value (%d)\n", testValue);
		
		if(current_time < EAestimationTime - 5)// time sensitive
		{
			op_pk_fd_get (seg_pkptr, 6, &startTime);
			start_times[(int)src_addr] = startTime;
			//printf("after reading  6\n");
					
			//printf("start time for %d is %f\n",(int)src_addr, startTime);
		}
		
				
		if(generatePacketTraceFlag == 1)
		{
				
			sprintf(tempFileName,"C:\\opnetTraceFiles\\received_%d_%s_%s_PacketTrace_node_%d_pf%d_TI%1.2f_BS%d.txt",nodes_no,curve,tempBnadwidth_allocation_method,(int)src_addr,(int)pruning_flag,(float)TXOPinterval,(int)hld_max_size/1000);
			if(frameN==0)
			{
				receivedPacketTrace = fopen(tempFileName,"w");
			}
			else
			{
				receivedPacketTrace = fopen(tempFileName,"a");
			}
			
			fprintf(receivedPacketTrace,"%d\t%d\t%d\t%d\t%d\t%f\t%f\t%d\t%d\n",(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)op_pk_id (seg_pkptr),(int)packetStatus,(float)sendingTime,(float)current_time,imageLineNumber,q);
			if(opencvDebugFlag)
			{
				opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
				fprintf(opencvDebugFile,"frome %d:frameN = %d\tpacketN=%d\tFrameSizeInPackets=%d\tID=%d\tpacketStatus=%d\tsendingTime=%f\tcurrent_time=%f\timageLineNumber=%d\tq=%d\tpacketCounter=%d\tmyDatasize=%d\n",
				(int)src_addr,(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)op_pk_id (seg_pkptr),(int)packetStatus,(float)sendingTime,(float)current_time,imageLineNumber,q,packetCounter[(int)src_addr],myDatasize);
				fclose(opencvDebugFile);
					
				printf("frome %d:frameN = %d\tpacketN=%d\tFrameSizeInPackets=%d\tID=%d\tpacketStatus=%d\tsendingTime=%f\tcurrent_time=%f\timageLineNumber=%d\tq=%d\tpacketCounter=%d\tmyDatasize=%d\n",
				(int)src_addr,(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)op_pk_id (seg_pkptr),(int)packetStatus,(float)sendingTime,(float)current_time,imageLineNumber,q,packetCounter[(int)src_addr],myDatasize);
			}
				
			fclose(receivedPacketTrace);
		}
		
		
		//Loren
		printf("from %d:frameN = %d\tpacketN=%d\tFrameSizeInPackets=%d\tID=%d\tpacketStatus=%d\tsendingTime=%f\tcurrent_time=%f\timageLineNumber=%d\tq=%d\tpacketCounter=%d\tmyDatasize=%d\n",
				(int)src_addr,(int)frameN,(int)packetN,(int)FrameSizeInPackets,(int)op_pk_id (seg_pkptr),(int)packetStatus,(float)sendingTime,(float)current_time,imageLineNumber,q,packetCounter[(int)src_addr],myDatasize);
		
		//fill lost packets array
							
		if(frameN == lastFrameN[(int)src_addr])                //if some packet are lost in between
		{
			if(packetN - lastPacketN[(int)src_addr] > 1)
			{			
				for(i=1;i<packetN - lastPacketN[(int)src_addr];i++)
				{
					lostPackets[(int)src_addr][lostPacketsCounter[(int)src_addr]++] = lastPacketN[(int)src_addr] + i;
				}
				//Loren added for debug
				printf("from %d:in filling lost packets inbetween current frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
				if(opencvDebugFlag)
				{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"from %d:in filling lost packets inbetween current frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
					printf("from %d:in filling lost packets inbetween current frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
					fclose(opencvDebugFile);
				}
			}
		}

		
		
		if(lastFrameN[(int)src_addr] != -1 && frameN != lastFrameN[(int)src_addr] && lastPacketN[(int)src_addr] +1 != lastFrameSizeInPackets[(int)src_addr])//if some packets are lost from the end of the frame
		{
			for(i=1;i<=lastFrameSizeInPackets[(int)src_addr] - (lastPacketN[(int)src_addr] +1);i++)
			{
				lostPackets[(int)src_addr][lostPacketsCounter[(int)src_addr]++] = lastPacketN[(int)src_addr] + i;
			}
			//Loren added for debug
			printf("from %d:in filling lost packets from the end of the previous frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tlastPacketN=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],lastPacketN[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
			if(opencvDebugFlag)
			{
				opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
				fprintf(opencvDebugFile,"from %d:in filling lost packets from the end of the previous frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tlastPacketN=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],lastPacketN[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
				printf("from %d:in filling lost packets from the end of the previous frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tlastPacketN=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],lastPacketN[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
				fclose(opencvDebugFile);
			}
		}
		//end of fill lost packets array
			
		
		//Loren
		sprintf(myString, "About to compare, frameN = %d, lastframeN = %d", (int)frameN, lastFrameN[(int)src_addr]);
		op_prg_odb_print_major(myString,OPC_NIL);
		
		if(lastFrameN[(int)src_addr] != -1 && frameN != lastFrameN[(int)src_addr] )
		{
			for(i = 0; i < frameN - lastFrameN[(int)src_addr] - 1;i++)    //to handle missed frames
			{
					if(current_time > EAestimationTime+transitionTime)
					{
						totalFrames[(int)src_addr]++;
						missedFrames[(int)src_addr]++;
						op_stat_write (CVAccuracyA, 0);
						if(myDataFileGenerationFlag == 1)
						{
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							//fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DataRate=%f,Accuracy=%f,Distortion=%f\n",
							fprintf(MyExcecutionTrace,"3At Time %f,from Node %d:DataRate=0,Accuracy=0,Distortion=0,totalData=0,trimmedCounter=0,totalCounter=0,accuracyError=0,cvAccuracy=0,cvAccuracyError=0,mse=65025,psnr=0,incompleteFrames=0,completeFrames=0,missedFrames=0,totalFrames=0,concealedFrames=0\n",
							(double)op_sim_time(),(int)src_addr);
							fclose(MyExcecutionTrace);
						}
					}
			}
				
				
			if(packetCounter[(int)src_addr] < lastFrameSizeInPackets[(int)src_addr])    //incomplete packet received
			{
				frameRecievedFlag = 1;
			}

			if(packetCounter[(int)src_addr] == lastFrameSizeInPackets[(int)src_addr])//complete packet received
			{
				completeFrameRecievedFlag = 1;
				
				//fprintf(receivedPacketTrace,"completeFrameRecievedFlag is set to one,node=%d,packetCounter=%d,lastFrameSizeInPackets=%d\n",(int)src_addr,packetCounter[(int)src_addr],lastFrameSizeInPackets[(int)src_addr]);
		    }
					
			//Loren
			sprintf(myString, "Just determined, frameRecievedFlag = %d, completeFrameRecievedFlag = %d", (int)frameRecievedFlag, (int)completeFrameRecievedFlag);
			op_prg_odb_print_major(myString,OPC_NIL);		
			packetCounter[(int)src_addr]=0;
			//peerStreamData[(int)src_addr] = 0;
									
		}
			
		totalPeerStreamData2[(int)src_addr] += op_pk_total_size_get(seg_pkptr);//-(packetN==0?(64+23)*8:23*8);
		peerStreamData2[(int)src_addr] += op_pk_total_size_get(seg_pkptr);//-(packetN==0?(64+23)*8:23*8);
			
		peerStreamData[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// - (packetN==0?(64+23)*8:23*8);
		totalPeerStreamData[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// - (packetN==0?(64+23)*8:23*8);
			
		peerStreamDataForRate[(int)src_addr] += op_pk_total_size_get(seg_pkptr);//-(packetN==0?(64+23)*8:23*8);
		peerStreamDataForRate2[(int)src_addr] += op_pk_total_size_get(seg_pkptr);//-(packetN==0?(64+23)*8:23*8);
		
		
		if(current_time <= EAestimationTime + transitionTime)    // time sensitive
			if(frameRecievedFlag || completeFrameRecievedFlag)
				lostPacketsCounter[(int)src_addr] = 0;
			
			
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"I am %d, frame forward function about to compare current time (%f) to EA estimation time + transition time (%d).", (int)my_address, (float)current_time, (int)EAestimationTime+(int)transitionTime);
			op_prg_odb_print_major(myString,OPC_NIL);	
		}
		
    	if(current_time > EAestimationTime+transitionTime)       // time sensitive
		{
						
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, frame forward function current time (%f) > EA estimation time + transition time.", (int)my_address, (float)current_time);
				op_prg_odb_print_major(myString,OPC_NIL);
				sprintf(myString, "frameRecievedFlag = %d, completeFrameRecievedFlag = %d", (int)frameRecievedFlag, (int)completeFrameRecievedFlag);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			//construct the image name
			//get the image name using the sizeinfo file line number
			
			if(frameRecievedFlag || completeFrameRecievedFlag)
			{					
				if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0)
				{
					
					sprintf(truthFileName,"C:\\facedatabase\\georgiaTech\\gt_db50\\mytruth.txt");
					
					truthFile = fopen(truthFileName,"r");
					//f = fopen("C:\\facedatabase\\georgiaTech\\gt_db50\\sizeInfo50.txt","r");
					
				}
				else if(strcmp(curve,"accu_quality_GT_withoutNI")==0)
				{
					
					sprintf(truthFileName,"C:\\facedatabase\\georgiaTech\\mytruth.txt");
					truthFile = fopen(truthFileName,"r");
					//f = fopen("C:\\facedatabase\\georgiaTech\\sizeInfo.txt","r");
					
				}
				else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0)
				{
					
					sprintf(truthFileName,"C:\\facedatabase\\georgiaTech\\gt_db75\\mytruth.txt");
					truthFile = fopen(truthFileName,"r");
					//f = fopen("C:\\facedatabase\\georgiaTech\\gt_db75\\sizeInfo75.txt","r");
					
				}
				
				
				/*else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)
					f = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance1.txt","r");
				else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)
					f = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance2.txt","r");
				else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)
					f = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance3.txt","r");	
				else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
				
					f = fopen("C:\\facedatabase\\CMU_MIT\\sizeInfo.txt","r");
				else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
				
					f = fopen("C:\\facedatabase\\CMU_MIT\\anew\\NewCMUSizeInfo.txt","r");
				
				
				//fgets(tempFileName, 1000,f);//read image number
				
				for(i = 0 ; i < lastImageLineNumber[(int)src_addr] - 1;i++)//skip lines until we get to the required line in the file
					{
					fgets(tempFileName, 1000,f);
					//printf("before reading truth file\n");
					if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0 || strcmp(curve,"accu_quality_GT_withoutNI")==0 || strcmp(curve,"accu_quality_GT75_withoutNI")==0)
						fgets(tempFileName,1000,truthFile);
					//printf("after reading truth file\n");
					}
							
				
				fscanf(f,"%s%s",imageName, directoryName);
				*/
				//Loren
				//if(opencvDebugFlag)
				//{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"this frame came from %d: lastImageLineNumber = %d, q = %d, imageName=%s, directoryName = %s\n",(int)src_addr,lastImageLineNumber[(int)src_addr],lastQ[(int)src_addr],imageName[lastImageLineNumber[(int)src_addr]], directoryName[lastImageLineNumber[(int)src_addr]]);
					printf("this frame came from %d: lastImageLineNumber = %d, q = %d, imageName=%s, directoryName = %s\n",(int)src_addr,lastImageLineNumber[(int)src_addr],lastQ[(int)src_addr],imageName[lastImageLineNumber[(int)src_addr]], directoryName[lastImageLineNumber[(int)src_addr]]);
					fclose(opencvDebugFile);
				//}
				
				
				
				if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0)
				{
					//printf("before scanning truth file\n");
					fscanf(truthFile,"%s%s%lf%lf",tempFileName, tempFileName,&truthArray[0][0],&truthArray[0][1]);
					fclose(truthFile);
					//printf("before closing truth file\n");
					
					sprintf(tempFileName,"C:\\facedatabase\\georgiaTech\\gt_db50\\%03d\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\georgiaTech\\gt_db50\\%03d\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
				
				else if(strcmp(curve,"accu_quality_GT_withoutNI")==0)
				{
					//printf("before scanning truth file\n");
					fscanf(truthFile,"%s%s%lf%lf",tempFileName, tempFileName,&truthArray[0][0],&truthArray[0][1]);
					fclose(truthFile);
					//printf("before closing truth file\n");
					
					sprintf(tempFileName,"C:\\facedatabase\\georgiaTech\\%03d\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\georgiaTech\\%03d\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
				
				else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0)
				{
					//printf("before scanning truth file\n");
					fscanf(truthFile,"%s%s%lf%lf",tempFileName, tempFileName,&truthArray[0][0],&truthArray[0][1]);
					fclose(truthFile);
					//printf("before closing truth file\n");
					
					sprintf(tempFileName,"C:\\facedatabase\\georgiaTech\\gt_db75\\%03d\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\georgiaTech\\gt_db75\\%03d\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
								
				else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)
				{
					sprintf(tempFileName,"C:\\facedatabase\\SCFace\\%03d\\distance1\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\SCFace\\%03d\\distance1\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
				
				else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)
				{				
					sprintf(tempFileName,"C:\\facedatabase\\SCFace\\%03d\\distance2\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\SCFace\\%03d\\distance2\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
				
				else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)
				{
					sprintf(tempFileName,"C:\\facedatabase\\SCFace\\%03d\\distance3\\%s\\%s",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\SCFace\\%03d\\distance3\\%s\\%s",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
				
				else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0 ||strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0||strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
				{
					sprintf(tempFileName,"C:\\facedatabase\\CMU_MIT\\Q%03d\\%s\\%s.jpg",lastQ[(int)src_addr],directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
					sprintf(originalFileName,"C:\\facedatabase\\CMU_MIT\\Q%03d\\%s\\%s.jpg",100,directoryName[lastImageLineNumber[(int)src_addr]],imageName[lastImageLineNumber[(int)src_addr]]);
				}
								
				//if(opencvDebugFlag)
				//{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"file name constructed is %s\n frameRecievedFlag = %d, completeFrameRecievedFlag= %d\n",tempFileName,frameRecievedFlag,completeFrameRecievedFlag);
					fclose(opencvDebugFile);
					printf("file name constructed is %s\n frameRecievedFlag = %d, completeFrameRecievedFlag= %d\n",tempFileName,frameRecievedFlag,completeFrameRecievedFlag);
				//}
				//fclose(f);
			}
			   //{
									
			if(calculationMethod == FRAMESTAT && frameRecievedFlag)//incomplete frame received
			{
									
				int M[]={1000000};
				myImageStructure * ids = createImageDataStructure(tempFileName,op_pk_total_size_get (seg_pkptr));//load the image from the image file
				myImageStructure * idsOriginal = createImageDataStructure(originalFileName,op_pk_total_size_get (seg_pkptr));//load the image from the image file
						
				incompleteFrames[(int)src_addr]++;
				totalFrames[(int)src_addr]++;
				
				//Loren
				if(LorenDebugFlag)
				{
					sprintf(myString,"I am %d, incomplete frame received.", (int)my_address);
					op_prg_odb_print_major(myString,OPC_NIL);
				}
				
				if(!ids || !idsOriginal)
				{
					op_sim_end("Could not create my image data structure","","","");
				}
				
				decodeHuffman_PKT(ids,0);//packetize the image
				decodeHuffman_PKT(idsOriginal,0);//packetize the imageOriginal
						
				if(opencvDebugFlag)
				{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"lostPackets:");
					printf("lostPackets:");
					
					for(i=0;i<lostPacketsCounter[(int)src_addr];i++)
					{
						fprintf(opencvDebugFile,"%d ",lostPackets[(int)src_addr][i]);
						printf("%d ",lostPackets[(int)src_addr][i]);
					}
					
					fprintf(opencvDebugFile,"\n");
					printf("\n");
					fclose(opencvDebugFile);
				}
						
				printf("end of printing lost packets\n");
						
				if(reconstruct(ids,lostPackets[(int)src_addr],lostPacketsCounter[(int)src_addr]))
				{			
					concealedFrames[(int)src_addr]++;
							
					reconstruct(idsOriginal,M,1);
		
					printf("Image reconstructed\n");
					cvImage=convertToOPENCV(ids);
					originalImage = convertToOPENCV(idsOriginal);		
							
					if(cvImage!=NULL && idsOriginal !=NULL )
					{
						printf("image converted to cv\n");
						if(opencvDebugFlag)
						{
							//printf("Image %s truth is %f,%f\n",tempFileName,truthArray[0][0],truthArray[0][1]);
						}			
								
						getPSNR(originalImage,cvImage,&mse,&psnr);
						
						sprintf(myString,"Start FaceDetect");
						op_prg_odb_print_major(myString,OPC_NIL);
						faceDetection(cvImage,imageName[lastImageLineNumber[(int)src_addr]], directoryName[lastImageLineNumber[(int)src_addr]],&accuracy,&accuracyError,truthArray);
						sprintf(myString,"End FaceDetect");
						op_prg_odb_print_major(myString,OPC_NIL);
						sprintf(myString,"Start Face Recognition");
						op_prg_odb_print_major(myString,OPC_NIL);
						//Loren, call faceRecognition
						if(trainingCompleteFlag == 0)
						{
							trainFaces((int)src_addr);
							trainingCompleteFlag = 1;
						}
						if(trainingCompleteFlag)
						{
							faceRecognition(cvImage, m, directoryName[lastImageLineNumber[(int)src_addr]], (int)src_addr);
						}
						sprintf(myString,"End Face Recognition");
						op_prg_odb_print_major(myString,OPC_NIL);
						if(opencvDebugFlag)
						{
							opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
							fprintf(opencvDebugFile,"from accuracy = %lf, accuracyError = %lf\n",accuracy, accuracyError);
							fclose(opencvDebugFile);
						}
								
						cvReleaseImage( &cvImage );
						cvReleaseImage( &originalImage );
					}
							
					else
					{
						op_sim_end("Could not create cvImage using convertToOPENCV","","","");
					}
					
				}
				
				else
				{
					mse = 255*255;
					psnr = 0;
					accuracy = 0;
					accuracyError = 0;
					if(opencvDebugFlag)
						{
							opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
							fprintf(opencvDebugFile,"image could not be reconstructed\n");
							fclose(opencvDebugFile);
						}
									
				}
					
				lostPacketsCounter[(int)src_addr] = 0;//reset counter for the next frame
				op_stat_write (CVAccuracyI, accuracy);
				op_stat_write (CVAccuracyA, accuracy);
									
						
				deleteImageDataStructure(ids);
				deleteImageDataStructure(idsOriginal);
				
				if(opencvDebugFlag)
				{
					opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
					fprintf(opencvDebugFile,"after deleteImageDataStructure\n");
					printf("after deleteImageDataStructure\n");
					fclose(opencvDebugFile);
				}
				
				frameRecievedFlag=0;
				//if(!completeFrameRecievedFlag)
				//	{
				totalPeerStreamData2[(int)src_addr] -= op_pk_total_size_get(seg_pkptr) ;//+ (packetN==0?(64+23)*8:23*8);
				peerStreamData2[(int)src_addr] -= op_pk_total_size_get(seg_pkptr);// +(packetN==0?(64+23)*8:23*8);
				//	}
						
				if(current_time - last_DataRate_reset_time2[(int)src_addr] > calculationPeriod )
				{
					peerStreamDataRate2[(int)src_addr] =  peerStreamDataForRate2[(int)src_addr]/(current_time-last_DataRate_reset_time2[(int)src_addr]);
					peerStreamDataForRate2[(int)src_addr] = 0;
				
					last_DataRate_reset_time2[(int)src_addr] = current_time;
				}
						
				
					
				if(strcmp(curve,"accu_quality_scfaced1_withNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy2[(int)src_addr] = (2.158E-8 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.807)+0.04894);
													
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
					
					peerStreamDistortion2[(int)src_addr] = 6.783 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1983) + -23.1;

				}
				else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy2[(int)src_addr] = (9.399E-13 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.997)+0.005403);
													
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
					
					peerStreamDistortion2[(int)src_addr] = 0.3801 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1966) + -1.142;

				}
				else if(strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy2[(int)src_addr] = (2.301E-8 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.8)+0.04801);
													
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);//need editting
					
					peerStreamDistortion2[(int)src_addr] = 6.783 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1983) + -23.1;
				}
				else if(strcmp(curve,"accu_quality_cmumit_withNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy2[(int)src_addr] = (9.623E-9 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.86)+0.2071);
					//peerStreamAccuracy2[(int)src_addr] = (1.266E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.529)+0.2362);
				
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
					
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion2[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion2[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
				else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
				{
					//for curve accuracy error = 1-detectionIndex
					peerStreamAccuracy2[(int)src_addr] = (2.138E-6 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.006)+0.05754);
					//peerStreamAccuracy2[(int)src_addr] = (2.899E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.455)+0.11);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
							
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion2[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion2[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
						
						
				else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
				{
					//for curve accuracy error = 1-detectionIndex
					peerStreamAccuracy2[(int)src_addr] = (9.963E-6 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.725)+0.1813);
					//peerStreamAccuracy2[(int)src_addr] = (2.899E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.455)+0.11);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
							
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion2[(int)src_addr] = pow(3.944,2) * pow(2,-94 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
							
				}
						
				else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
				{
				
					//for curve accuracy error = 1-detectionIndex
					peerStreamAccuracy2[(int)src_addr] = pow((peerStreamData[(int)src_addr]/8.0/20.0/1024.0/1024.0),-2.346) +    0.09305;
					//peerStreamAccuracy2[(int)src_addr] = (2.899E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.455)+0.11);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
							
					//if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
					peerStreamDistortion2[(int)src_addr] = 9.545 * pow((peerStreamData[(int)src_addr]/8.0/20.0/1024.0/1024.0),-0.1845) + -15.41;
									
				}
						
				else if(strcmp(curve,"accu_quality_frontal")==0)
				{
				
					peerStreamAccuracy2[(int)src_addr] = (4.346E-16 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-8.104)+0.1797);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
					
					
					peerStreamDistortion2[(int)src_addr] = 8.417E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-3.937) + 0;
				}
				else if(strcmp(curve,"accu_resolution_frontal")==0)
				{
					
					peerStreamAccuracy2[(int)src_addr] = (5.079E-008 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.28)+0.2446);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
					
					peerStreamDistortion2[(int)src_addr] = 0.1403 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.6785) + 0;
				}
				
				else if(strcmp(curve,"matlabOptimization_accu_resolution_cmumit")==0)
				{
					
					//0.9405 .*W .* exp(-233.5 .*(x.* Y)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y)./T)
					
					peerStreamAccuracy2[(int)src_addr] = 0.9405 * exp(-233.5 *peerStreamData[(int)src_addr]/8.0/1024.0/1024.0) + 0.2563 * exp(-1.354 *peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
					
					//peerStreamAccuracy[(int)i] = (5.079E-008 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-2.28)+0.2446);
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
				}
				
				else if(strcmp(curve,"accu_quality_GT50_withNI")==0)
				{
					
					//for curve accuracy error = 1-detectionIndex + false detection index
						
					peerStreamAccuracy2[(int)src_addr] = (8.597e-013 * pow(peerStreamData2[(int)src_addr]/8.0/1024.0/1024.0,-3.654)+0.08355);
					
					peerStreamAccuracyError2[(int)src_addr] = peerStreamAccuracy2[(int)src_addr];
					
					if(peerStreamAccuracy2[(int)src_addr] <0 || peerStreamAccuracy2[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy2[(int)src_addr] = 1 - (peerStreamAccuracy2[(int)src_addr] > 1 ? 1 : peerStreamAccuracy2[(int)src_addr]);
							
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion2[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion2[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
					
						
				//	peerStreamDistortion[(int)i] =6.778 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-0.2555) + -10.63;
				
					
				if(peerStreamDistortion2[(int)src_addr]<0)
					peerStreamDistortion2[(int)src_addr] = 0;
						
				if (peerStreamData[(int)src_addr] == 0)
				{
					peerStreamAccuracyError2[(int)src_addr]= 25;
					peerStreamDistortion2[(int)src_addr] = 25;
				}
						
				accuracyCalculationCounter2[(int)src_addr]++;
					
					
				if(myDataFileGenerationFlag == 1)
				{
				
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					//fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f\n",
					fprintf(MyExcecutionTrace,"2At Time %f,from Node %d:DataRate=%f,Accuracy=%f,Distortion=%f,totalData=%f,trimmedCounter=%d,totalCounter=%d,accuracyError=%f,cvAccuracy=%f,cvAccuracyError=%f,mse=%f,psnr=%f,incompleteFrames=%d,completeFrames=%d,missedFrames=%d,totalFrames=%d,concealedFrames=%d\n",
					(double)op_sim_time(),(int)src_addr,(double)peerStreamDataRate2[(int)src_addr],(double)peerStreamAccuracy2[(int)src_addr],(double)peerStreamDistortion2[(int)src_addr],(double)totalPeerStreamData2[(int)src_addr],trimmedAccuracyCounter2[(int)src_addr],accuracyCalculationCounter2[(int)src_addr],peerStreamAccuracyError2[(int)src_addr],accuracy,accuracyError,mse,psnr, incompleteFrames[(int)src_addr],completeFrames[(int)src_addr],missedFrames[(int)src_addr],totalFrames[(int)src_addr],concealedFrames[(int)src_addr]);
					fclose(MyExcecutionTrace);
				}
					
											
				peerStreamData2[(int)src_addr]=0;
						
				peerStreamAccuracy2[(int)src_addr] = 0;
				peerStreamDistortion2[(int)src_addr] = 0;
				peerStreamAccuracyError2[(int)src_addr] = 0;
						
				//lostPacketsCounter[(int)src_addr] = 0;//reset counter for the next frame
						
						
				//if(!completeFrameRecievedFlag)
				//	{
				totalPeerStreamData2[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// - (packetN==0?(64+23)*8:23*8);
				peerStreamData2[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// -(packetN==0?(64+23)*8:23*8);
				//	}
						
						
			}
					
				
			if(calculationMethod == FRAMESTAT && completeFrameRecievedFlag)//complete frame recived
			{
				completeFrames[(int)src_addr]++;
				totalFrames[(int)src_addr]++;
				cvImage=cvLoadImage( tempFileName, 0 );
				//Loren
				sprintf(myString,"I am %d, complete frame received.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);		
				if(cvImage)
				{
					originalImage = cvLoadImage(originalFileName, 0);
					
					if(originalImage)
						getPSNR(originalImage,cvImage,&mse,&psnr);
					else
						op_sim_end("Could not create cvImage for the original image","","","");
					
					sprintf(myString,"Start FaceDetect 1");
					op_prg_odb_print_major(myString,OPC_NIL);
					faceDetection(cvImage,imageName[lastImageLineNumber[(int)src_addr]], directoryName[lastImageLineNumber[(int)src_addr]],&accuracy,&accuracyError,truthArray);
					sprintf(myString,"End FaceDetect 1");
					op_prg_odb_print_major(myString,OPC_NIL);
					sprintf(myString,"Start Face Recognition 1 with image file: %s", tempFileName);
					op_prg_odb_print_major(myString,OPC_NIL);
					
					//Loren Call Face Recognition 2
					if(trainingCompleteFlag == 0)
					{
						trainFaces((int)src_addr);
						trainingCompleteFlag = 1;
					}
					if(trainingCompleteFlag)
					{
						faceRecognition(cvImage, m, directoryName[lastImageLineNumber[(int)src_addr]], (int)src_addr);
					}
					
					sprintf(myString,"End FaceRecognition 1");
					op_prg_odb_print_major(myString,OPC_NIL);
					
					if(opencvDebugFlag)
						printf("from accuracy = %lf, accuracyError = %lf\n",accuracy, accuracyError);
					
					cvReleaseImage( &cvImage );
					cvReleaseImage( &originalImage );
				}
				else
				{
					op_sim_end("Could not create cvImage using cvLoadImage","","","");
				}
						
				op_stat_write (CVAccuracyC, accuracy);
				op_stat_write (CVAccuracyA, accuracy);
												
				completeFrameRecievedFlag = 0;
				totalPeerStreamData[(int)src_addr] -= op_pk_total_size_get(seg_pkptr);// + (packetN==0?(64+23)*8:23*8);
				peerStreamData[(int)src_addr] -= op_pk_total_size_get(seg_pkptr);// +(packetN==0?(64+23)*8:23*8);
						
				if(current_time - last_DataRate_reset_time[(int)src_addr] > calculationPeriod )
				{
					peerStreamDataRate[(int)src_addr] =  peerStreamDataForRate[(int)src_addr]/(current_time-last_DataRate_reset_time[(int)src_addr]);
					peerStreamDataForRate[(int)src_addr] = 0;
					
					last_DataRate_reset_time[(int)src_addr] = current_time;
				}
				
					
						
				if(strcmp(curve,"accu_quality_scfaced1_withNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy[(int)src_addr] = (2.158E-8 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.807)+0.04894);
													
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
						
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					peerStreamDistortion[(int)src_addr] = 6.783 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1983) + -23.1;
				}
				else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0)//!accu_woe_flag)
				{
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy[(int)src_addr] = (9.399E-13 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.997)+0.005403);
												
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter2[(int)src_addr]++;
						
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					peerStreamDistortion[(int)src_addr] = 0.3801 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1966) + -1.142;

				}
				else if(strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//!accu_woe_flag)
				{	
					//for curve accuracy error = 1-detectionIndex + false detection index
					peerStreamAccuracy[(int)src_addr] = (2.301E-8 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.8)+0.04801);
					//peerStreamAccuracy2[(int)src_addr] = (1.266E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.529)+0.2362);
						
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
						
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);//need editting
					
					//peerStreamDistortion2[(int)src_addr] = 6.778 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.2555) + -10.63;
					peerStreamDistortion[(int)src_addr] = 6.783 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.1983) + -23.1;
				}
				else if(strcmp(curve,"accu_quality_cmumit_withNI")==0)//!accu_woe_flag)
				{//for curve accuracy error = 1-detectionIndex + false detection index
					//peerStreamAccuracy[(int)src_addr] = (1.266E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.529)+0.2362);
					peerStreamAccuracy[(int)src_addr] = (9.623E-9 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.86)+0.2071);
							
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
						
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
				else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
				{
					//for curve accuracy error = 1-detectionIndex
					//peerStreamAccuracy[(int)src_addr] = (2.899E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.455)+0.11);
					peerStreamAccuracy[(int)src_addr] = (2.138E-6 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.006)+0.05754);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
				else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
				{
					//for curve accuracy error = 1-detectionIndex
					peerStreamAccuracy[(int)src_addr] = (9.963E-6 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-1.725)+0.1813);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
							
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion[(int)src_addr] = pow(3.944,2) * pow(2,-94 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					
				}
				else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
				{
							
					//for curve accuracy error = 1-detectionIndex
					peerStreamAccuracy[(int)src_addr] = pow((peerStreamData[(int)src_addr]/8.0/20.0/1024.0/1024.0),-2.346) +    0.09305;
					//peerStreamAccuracy2[(int)src_addr] = (2.899E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.455)+0.11);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					//if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
					peerStreamDistortion[(int)src_addr] = 9.545 * pow((peerStreamData[(int)src_addr]/8.0/20.0/1024.0/1024.0),-0.1845) + -15.41;
									
				}
						
				else if(strcmp(curve,"accu_quality_frontal")==0)
				{
					
					peerStreamAccuracy[(int)src_addr] = (4.346E-16 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-8.104)+0.1797);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
					
					
					peerStreamDistortion[(int)src_addr] = 8.417E-7 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-3.937) + 0;
				}
				else if(strcmp(curve,"accu_resolution_frontal")==0)
				{
				
					peerStreamAccuracy[(int)src_addr] = (5.079E-008 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-2.28)+0.2446);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
				
					
					peerStreamDistortion[(int)src_addr] = 0.1403 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.6785) + 0;
				}
				
				else if(strcmp(curve,"matlabOptimization_accu_resolution_cmumit")==0)
				{
					
					//0.9405 .*W .* exp(-233.5 .*(x.* Y)./T) + W .* 0.2563 .* exp(-1.354 .*(x .* Y)./T)
					peerStreamAccuracy[(int)src_addr] = 0.9405 * exp(-233.5 *peerStreamData[(int)src_addr]/8.0/1024.0/1024.0) + 0.2563 * exp(-1.354 *peerStreamDataRate[(int)src_addr]/8.0/20.0/1024.0/1024.0);
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
					
					//peerStreamAccuracy[(int)i] = (5.079E-008 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-2.28)+0.2446);
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
				}
				
				//AFOPT= 8.597e-013 * pow((appRateBits/8.0/20.0/1024.0/1024.0),-3.654) + 0.08355;
				
				else if(strcmp(curve,"accu_quality_GT50_withNI")==0)
				{
					
					//for curve accuracy error = 1-detectionIndex + false detection index
					
					peerStreamAccuracy[(int)src_addr] = (8.597e-013 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-3.654)+0.08355);
							
					peerStreamAccuracyError[(int)src_addr] = peerStreamAccuracy[(int)src_addr];
					if(peerStreamAccuracy[(int)src_addr] <0 || peerStreamAccuracy[(int)src_addr] > 1)
						trimmedAccuracyCounter[(int)src_addr]++;
				
					peerStreamAccuracy[(int)src_addr] = 1 - (peerStreamAccuracy[(int)src_addr] > 1 ? 1 : peerStreamAccuracy[(int)src_addr]);
							
					if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)
						peerStreamDistortion[(int)src_addr] = pow(4.501,2) * pow(2,-2668 * peerStreamData[(int)src_addr]/8.0/1024.0/1024.0);
					else
						peerStreamDistortion[(int)src_addr] = 17.93 * pow(peerStreamData[(int)src_addr]/8.0/1024.0/1024.0,-0.143) + -23.72;
				}
					
					
				
				//	peerStreamDistortion[(int)i] =6.778 * pow(peerStreamDataRate[(int)i]/8.0/(current_time-last_DataRate_reset_time)/20.0/1024.0/1024.0,-0.2555) + -10.63;
				
					
				if(peerStreamDistortion[(int)src_addr]<0)
					peerStreamDistortion[(int)src_addr] = 0;
						
				if (peerStreamData[(int)src_addr] == 0)
				{
					peerStreamAccuracyError[(int)src_addr]= 25;
					peerStreamDistortion[(int)src_addr] = 25;
				}
						
				accuracyCalculationCounter[(int)src_addr]++;
					
					
						
				//Loren		
				//if(myDataFileGenerationFlag == 1)
				//{
						
					//MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					//fprintf(MyExcecutionTrace,"At Time %f,from Node %d:DaraRate=%f,Accuracy=%f,Distortion=%f\n",
					sprintf(myString,"1At Time %f,from Node %d:DataRate=%f,Accuracy=%f,Distortion=%f,totalData=%f,trimmedCounter=%d,totalCounter=%d,accuracyError=%f,cvAccuracy=%f,cvAccuracyError=%f,mse=%f,psnr=%f,incompleteFrames=%d,completeFrames=%d,missedFrames=%d,totalFrames=%d,concealedFrames=%d\n",
					(double)op_sim_time(),(int)src_addr,(double)peerStreamDataRate[(int)src_addr],(double)peerStreamAccuracy[(int)src_addr],(double)peerStreamDistortion[(int)src_addr],(double)totalPeerStreamData[(int)src_addr],trimmedAccuracyCounter[(int)src_addr],accuracyCalculationCounter[(int)src_addr],peerStreamAccuracyError[(int)src_addr],accuracy,accuracyError,mse,psnr,incompleteFrames[(int)src_addr],completeFrames[(int)src_addr],missedFrames[(int)src_addr],totalFrames[(int)src_addr],concealedFrames[(int)src_addr]);
					//Remove when changing back.
					op_prg_odb_print_major(myString, OPC_NIL);
					//fclose(MyExcecutionTrace);
				//}
					
											
						
				peerStreamAccuracy[(int)src_addr] = 0;
				peerStreamDistortion[(int)src_addr] = 0;
						
				peerStreamAccuracyError[(int)src_addr] = 0;
					
				peerStreamData[(int)src_addr]=0;
					
						
						
				totalPeerStreamData[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// - (packetN==0?(64+23)*8:23*8);
				peerStreamData[(int)src_addr] += op_pk_total_size_get(seg_pkptr);// -(packetN==0?(64+23)*8:23*8);
			}
					
			if(myStringDebug)
			{
				sprintf(myString,"I am  %d:accuracy is being calculated DONE",(int)my_address,(int)my_address, importance);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
					//}//end of my stat
				
					
			if(accuracy > 1)
				op_sim_end("accuracy is greater than one","","","");
					
		}//end of if (current_time> 22)
			
				
			
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"I am %d, frame forward function current time (%f), EA estimation time + transition time code done or skipped.", (int)my_address, (float)current_time);
			op_prg_odb_print_major(myString,OPC_NIL);	
		}
	
		if(lastFrameN[(int)src_addr] != -1 && frameN != lastFrameN[(int)src_addr] && packetN != 0)//packetCounter[(int)src_addr] == 1 && lastPacketN[(int)src_addr] != 0)//if some packets are lost from the beginig of the frame
		{
			for(i=0;i<packetN;i++)
			{
				lostPackets[(int)src_addr][lostPacketsCounter[(int)src_addr]++] = i;
				//lostPacketsCounter[(int)src_addr]++;
			}
				
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, checking lost packets.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);	
			}
				
			if(opencvDebugFlag)
			{
				opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
				fprintf(opencvDebugFile,"frome %d:in filling lost packets from the begining of the current frame: frameN=%d\tlastFrameN=%d\tlastFrameSizeInPackets=%d\tpacketCounter=%d\tlostPacketsCounter=%d\n",(int)src_addr,(int)frameN,lastFrameN[(int)src_addr],lastFrameSizeInPackets[(int)src_addr],packetCounter[(int)src_addr],lostPacketsCounter[(int)src_addr]);
				fclose(opencvDebugFile);
			}
		}
			
		lastQ[(int)src_addr]=q;
		lastImageLineNumber[(int)src_addr] = imageLineNumber;
				
		lastPacketN[(int)src_addr] = packetN;
		lastFrameN[(int)src_addr] = frameN;
		lastFrameSizeInPackets[(int)src_addr] = FrameSizeInPackets;
		//lastImageLineNumber[(int)src_addr] = imageLineNumber;//move down
			
		completeFrameRecievedFlag = 0;
		frameRecievedFlag = 0;
		
		//Loren
		if(LorenDebugFlag)
		{
			sprintf(myString,"I am %d, updating packet counter.", (int)my_address);
			op_prg_odb_print_major(myString,OPC_NIL);
		}
		
		packetCounter[(int)src_addr]++;
		//if(opencvDebugFlag)
		//printf("my statistics done\n");
		
	}
			
		
		/* Send the packet to the higher layer if not destined within	*/
		/* own BSS or if it has broadcast address as destination		*/
		/* address.														*/
		if (send_to_higher == OPC_TRUE)
		{
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, sending to higher layer.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			/* Update the local/global throughput and end-to-end delay	*/
			/* statistics based on the packet that will be forwarded to	*/
			/* the higher layer.										*/
			wlan_hcf_accepted_frame_stats_update (seg_pkptr, tx_ac);
			
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, done sending to higher layer.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			/* Set the contents of the LLC-destined ICI.				*/
			op_ici_attr_set_int64 (llc_iciptr, "src_addr", src_addr);
			op_ici_attr_set_int64 (llc_iciptr, "dest_addr", final_dest_addr);
			op_ici_attr_set (llc_iciptr, "protocol_type", protocol_type);
			
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, got ici information.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			/* Install the ICI.											*/
			op_ici_install (llc_iciptr);

			/* Printing out information to ODB.							*/
			if (wlan_trace_active == OPC_TRUE)
			{
				sprintf (msg_string, "All fragments of Data packet " OPC_PACKET_ID_FMT " is received and sent to the higher layer.", pkt_id);
				op_prg_odb_print_major (msg_string, OPC_NIL);
			}
			
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, sending to higher layer for real.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
			
			/* Sending data to higher layer.							*/
			wlan_rcvd_pkt_higher_layer_forward (seg_pkptr, wlan_flags->bridge_flag, mac_client_reassembly_buffer, outstrm_to_mac_if);
			
			//Loren
			if(LorenDebugFlag)
			{
				sprintf(myString,"I am %d, done sending to higher layer for real.", (int)my_address);
				op_prg_odb_print_major(myString,OPC_NIL);
			}
		}
		}
	else
		{
		/* If the station is a gateway and not an access point then do	*/
		/* not send	data to higher layer for address resolution. This	*/
		/* is for not allowing data to go out of the ad-hoc BSS.		*/
		/* Except, in the case of broadcast packets and packets			*/
		/* addressed to this station. On the other hand, if we are in a	*/
		/* bridge/switch node and not AP enabled, then drop the packet.	*/
		if ((wlan_flags->gateway_flag == OPC_TRUE  && dest_addr != my_address && dest_addr >= 0) || 
			wlan_flags->bridge_flag == OPC_TRUE)
			{				
			/* Printing out information to ODB.							*/
			if (wlan_trace_active == OPC_TRUE)
				{
				strcpy (msg_string, "Gateway is not an access point so all received fragments are discarded.");
				op_prg_odb_print_major (msg_string, OPC_NIL);
				}
			op_pk_destroy (seg_pkptr);
			}
		else
			{
			/* Update the local/global throughput and end-to-end delay	*/
			/* statistics based on the packet that will be forwarded to	*/
			/* the higher layer.										*/
			wlan_hcf_accepted_frame_stats_update (seg_pkptr, tx_ac);
			
			/* Send the packet to the higher layer unless it is a		*/
			/* spanning tree BPDU. No need to check whether the			*/
			/* surrounding node is a bridge/switch since WLAN ports		*/
			/* can't be used for bridge-to-bridge connections.			*/
			if (dest_addr == BRIDGE_BROADCAST_ADDR || dest_addr == PVST_BPE_MCAST_ADDR)
				op_pk_destroy (seg_pkptr);
			else
				{
				/* Printing out information to ODB.						*/
				if (wlan_trace_active == OPC_TRUE)
					{
					sprintf (msg_string, "All fragments of Data packet " OPC_PACKET_ID_FMT " is received and sent to the higher layer.", pkt_id);
					op_prg_odb_print_major (msg_string, OPC_NIL);
					}
				
				/* Sending data to the higher layer.					*/
				wlan_rcvd_pkt_higher_layer_forward (seg_pkptr, wlan_flags->bridge_flag, mac_client_reassembly_buffer, outstrm_to_mac_if);
				}
			}
		}

	FOUT;
	}

static void
wlan_hcf_ba_process (OpT_Int64 peer_addr, Packet* rcvd_frame_pkptr)
	{
	const WlanT_BA_Control_Fields*	ba_cntl_fields_ptr;
	WlanT_HCF_Peer_Info*			peer_info_ptr;
	WlanT_HCF_BA_State*				ba_info_ptr;
	const WlanT_Data_Header_Fields*	mpdu_fields_ptr;
	List*							ac_tx_queue;
	WlanT_HCF_Hld_Info*				hld_ptr;
	int								mpdu_seq_num, seq_num_offset;
	int								current_mpdu, failed_mpdu_count, unacked_mpdu_count;
	int								insertion_index, i;
	int								ac_queue_size;
	WlanT_HCF_Access_Category		ac, temp_ac;
	Boolean							found;
	char							msg_string1 [256];
	char							msg_string2 [256];
	
	/** This function processes the given block-ACK frame. MPDUs		**/
	/** acknowledged in the BA are removed from the retransmission		**/
	/** buffer. For each MPDU that is reported as "not received" in the	**/
	/** BA, a copy of it is inserted into the corresponding AC's		**/
	/** transmission buffer for retransmission of the MPDU. If there	**/
	/** any MPDUs requiring retransmission, also a BAR is enqueued just	**/
	/** after the MPDUs that are enqueued for retransmission.			**/
	FIN (wlan_hcf_ba_process (peer_addr, rcvd_frame_pkptr));
	
	/* Remove the BAR specific fields of the control frame. 			*/
	
	//Loren: Function does not get called from here in normal operation. 	
	op_pk_fd_access_read_only_ptr (rcvd_frame_pkptr, WLANC_CNTL_BA_FD, (const void **) &ba_cntl_fields_ptr);
	
	/* Get our record of this peer.										*/
	if (wlan_flags->ad_hoc_or_ap == OPC_FALSE)
		peer_info_ptr = ap_peer_info_ptr;
	else
		peer_info_ptr = (WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(peer_addr));

	/* Get a handle to the BA state information with this peer and TID.	*/
	ba_info_ptr = peer_info_ptr->ba_state_ptr_arr [ba_cntl_fields_ptr->tid];
	
	/* No need to process the BA if it is a duplicate. Also discard it	*/
	/* if we have torn down our BA agreement with this peer/TID due to	*/
	/* inactivity (this is unlikely but possible to happen since the	*/
	/* peer may transmit a BA before our DELBA reaches it).				*/	
	if (ba_info_ptr == OPC_NIL || ba_info_ptr->status != WlanC_BA_Established ||
		SEQ_A_GREATER_THAN_SEQ_B (ba_info_ptr->starting_seq_num, ba_cntl_fields_ptr->starting_seq_num, ba_info_ptr->block_size) || 
		ba_info_ptr->bar_pending == OPC_TRUE)
		{
		/* If enabled, write an ODB message.							*/
		if (wlan_trace_active)
			{				
			sprintf (msg_string1, "Received a duplicate BA from STA "OPC_INT64_FMT" for TID %d! Discarding.", ba_info_ptr->peer_addr, ba_info_ptr->tid); 
			op_prg_odb_print_major (msg_string1, OPC_NIL);
			}		
		FOUT;
		}
	
	/* Is this a delayed BA?											*/
	if (tc_config_arr [ba_info_ptr->tid].ba_policy == WlanC_Delayed_BA)
		{
		/* Reset the flag indicating awaited BA.						*/
		ba_info_ptr->awaiting_delayed_ba = OPC_FALSE;
		
		/* In some rare cases, we may receive a delayed BA from peer	*/
		/* while we are still trying to transmit a BAR (peer receives	*/
		/* our BAR, but we can't receive its ACK successfully). If this	*/
		/* is the case, discard the BAR we are trying to transmit.		*/
		if (ba_info_ptr->bar_tx_time > 0.0 && op_ev_valid (ba_info_ptr->inactivity_evh) == OPC_FALSE)
			{
			wlan_hcf_frame_remove (WLANC_UP_TO_AC_MAPPING_ARRAY [ba_info_ptr->tid], 0);
			
			/* Perform a CW-backoff like our transmission was			*/
			/* successful.												*/
			wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [WLANC_UP_TO_AC_MAPPING_ARRAY [ba_info_ptr->tid]];
			}
		}
	
	/* Go over the array of the MPDUs sent within the block and check	*/
	/* their status whether they are received or not by the peer.		*/
	for (current_mpdu = 0, failed_mpdu_count = 0, unacked_mpdu_count = 0; current_mpdu < ba_info_ptr->mpdu_count; current_mpdu++)
		{
		/* Access the header fields of the current MPDU.				*/
		
		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (ba_info_ptr->retx_arr [current_mpdu]->pkptr, WLANC_DATA_HEADER_FD, (const void **) &mpdu_fields_ptr);
		
		/* Compute the sequence number offset.							*/
		mpdu_seq_num   = mpdu_fields_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE;
		seq_num_offset = wlan_hcf_seq_a_minus_seq_b (mpdu_seq_num, ba_cntl_fields_ptr->starting_seq_num, ba_info_ptr->block_size);
		
		/* Check the status of the MPDU.								*/
		if (seq_num_offset >= WLANC_BA_STATUS_BITMAP_MAX_MSDU)
			{
			/* This MPDU's sequence number is beyond the status bitmap.	*/
			/* Hence, this one and all the remaining MPDUs could not be	*/
			/* ACKed with the received BA.								*/
			do
				{
				ba_info_ptr->retx_arr [failed_mpdu_count + unacked_mpdu_count] = ba_info_ptr->retx_arr [current_mpdu];
				unacked_mpdu_count++;
				current_mpdu++;
				} while (current_mpdu < ba_info_ptr->mpdu_count);
			}
		else if (ba_cntl_fields_ptr->status_bitmap [seq_num_offset] & (1 << (mpdu_fields_ptr->sequence_control & WLANC_FRAG_NUM_BIT_MASK)))
			{
			/* MPDU is acknowledged in the BA. Destroy the copy we kept	*/
			/* and update the total buffer usage by queued packets.		*/
			op_pk_destroy (ba_info_ptr->retx_arr [current_mpdu]->pkptr);
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size before decrement #3 = %d\n", (int)total_hlpk_size);
			}
			total_hlpk_size -= ba_info_ptr->retx_arr [current_mpdu]->size;
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size after decrement #3 = %d\n",(int)total_hlpk_size);
			}
			op_prg_mem_free (ba_info_ptr->retx_arr [current_mpdu]);
			
			/* Record the sequence number of the MPDU if it is the new	*/
			/* highest ACKed one.										*/
			if (SEQ_A_GREATER_THAN_SEQ_B (mpdu_seq_num, ba_info_ptr->max_acked_seq_num, ba_info_ptr->block_size)) 
				ba_info_ptr->max_acked_seq_num = mpdu_seq_num;
			}
		else
			{
			/* Transmission of the MPDU has failed.						*/
			ba_info_ptr->retx_arr [failed_mpdu_count] = ba_info_ptr->retx_arr [current_mpdu];
			failed_mpdu_count++;
			}
		}
	
	/* Set the number of remaining MPDUs.								*/
	ba_info_ptr->mpdu_count = failed_mpdu_count + unacked_mpdu_count;
	
	/* Check the overall status.										*/
	if (ba_info_ptr->mpdu_count == 0)
		{
		/* All the pending MPDUs are ACKed. Set the new starting		*/
		/* sequence number.												*/
		ba_info_ptr->starting_seq_num = (ba_info_ptr->max_acked_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
		}
	else
		{
		/* The retransmission buffer is not empty. New starting			*/
		/* sequence number is the sequence number of the first MPDU in	*/
		/* the buffer.													*/
		
		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (ba_info_ptr->retx_arr [0]->pkptr, WLANC_DATA_HEADER_FD, (const void **) &mpdu_fields_ptr);
		ba_info_ptr->starting_seq_num = mpdu_fields_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE;
		
		/* If there are failed MPDUs, we will retransmit them and then	*/
		/* send a BAR. If there are only unacked MPDUs, then we will	*/
		/* send another BAR to query the status of the remaining ones.	*/
		/* Find the exact index at the head of the transmission queue	*/
		/* where we can start inserting entries for the	retransmissions	*/
		/* of these MPDUs.												*/
		ac = WLANC_UP_TO_AC_MAPPING_ARRAY [ba_cntl_fields_ptr->tid];
		ac_tx_queue = hlpk_lptr_arr [ac];
		ac_queue_size = op_prg_list_size (ac_tx_queue);
		if (ac_queue_size == 0)
			{
			/* AC's queue is empty.										*/
			insertion_index = 0;
			
			/* Update the queue status array if necessary, since the	*/
			/* queue won't be empty anymore.							*/
			if(!(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [ac]))
				{
				/* Insert the category into the list of the categories	*/
				/* with non-empty queues. Make sure that the list		*/
				/* remains sorted.										*/
				for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
					{
					if (ac > ac_queue_status_arr [i])
						{
						temp_ac = ac;
						ac = ac_queue_status_arr [i];
						ac_queue_status_arr [i] = temp_ac;
						}
					}
				ac_queue_status_arr [i] = ac;
				}
			}
		else
			{
			/* The queue is non-empty. First find the lowest queue		*/
			/* index after excluding frames being transmitted.			*/
			insertion_index = wlan_hcf_ac_queue_transmission_status_check (ac_tx_queue, ac);
			
			/* Now skip control/management frames already queued and BA	*/
			/* retransmission packets inserted as a result of a			*/
			/* previous BA, if any.										*/
			for (found = OPC_FALSE; insertion_index < ac_queue_size && found == OPC_FALSE;)
				{
				/* Access the record of the current queued frame.		*/
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_tx_queue, insertion_index);
				
				/* Skip the high priority frames listed above.			*/	
				if (!(hld_ptr->type & WLANC_DATA_TYPE_BIT) || hld_ptr->ba_retx == OPC_TRUE)
					insertion_index++;
				else
					found = OPC_TRUE;
				}
			}
		
		/* If any, failed MPDUs have to be retransmitted.				*/
		if (failed_mpdu_count > 0)
			{			
			/* Insert a copy of each failed MPDU into the AC's			*/
			/* transmission buffer.										*/
			current_mpdu = 0;
			do
				{
				/* Create a higher layer data transmission buffer entry	*/
				/* for the BA MPDU to be retransmitted.					*/
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_pmo_alloc (hld_pmh);
				op_prg_mem_copy (ba_info_ptr->retx_arr [current_mpdu], hld_ptr, sizeof (WlanT_HCF_Hld_Info));
				
				/* Store a copy of the MPDU for retransmission.			*/
				hld_ptr->pkptr = op_pk_copy (ba_info_ptr->retx_arr [current_mpdu]->pkptr);
				hld_ptr->ba_retx = OPC_TRUE;
				
				/* Insert the retransmission copy into the buffer.		*/
				op_prg_list_insert (ac_tx_queue, hld_ptr, insertion_index);
				
				/* Move to the next one.								*/
				insertion_index++;
				current_mpdu++;
				} while (current_mpdu < failed_mpdu_count);			
			}

		/* As the final step, create and enqueue a BAR.					*/
		hld_ptr = wlan_hcf_ba_control_queue_entry_create (WlanC_BAR, peer_addr, (OpT_uInt8) ba_cntl_fields_ptr->tid);
		if(LorenDebugFlag)
		{
			printf("total_hlpk_size before increment #4 = %d\n",(int)total_hlpk_size);
		}
		total_hlpk_size += hld_ptr->size;
		if(LorenDebugFlag)
		{
			printf("total_hlpk_size after increment #4 = %d\n", (int)total_hlpk_size);
		}
		op_prg_list_insert (ac_tx_queue, hld_ptr, insertion_index);
		
		/* Update the number of queued packets and related statistics.	*/
		total_hlpk_num += failed_mpdu_count + 1;
		op_stat_write (hl_packets_rcvd,              (double) total_hlpk_num);
		op_stat_write (ac_queue_size_shndl_arr [ac], (double) ac_queue_size + failed_mpdu_count + 1);
		
		/* Set the flag indicating existence of a queued BAR.			*/
		ba_info_ptr->bar_pending = OPC_TRUE;					
		}
	
	/* If used, with the reception of the delayed BA, stop the			*/
	/* inactivity timer. Also restart it, if the retransmission buffer	*/
	/* was emptied. When delayed BA policy is used, as a rare event, we	*/
	/* may receive peer's BA before receiving an ACK for the BAR. If	*/
	/* this happens, there won't be an event to cancel. Pay attention	*/
	/* to this by checking the value of "bar_tx_time", which indicates	*/
	/* whether a BAR is being transmitted or not.						*/	
	if (tc_config_arr [ba_cntl_fields_ptr->tid].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
		{
		if (tc_config_arr [ba_cntl_fields_ptr->tid].ba_policy == WlanC_Delayed_BA && ba_info_ptr->bar_tx_time == 0.0)
			op_ev_cancel (ba_info_ptr->inactivity_evh);
		
		if (ba_info_ptr->mpdu_count == 0)
			{
			op_ev_state_install (ba_info_ptr, OPC_NIL);
			ba_info_ptr->inactivity_evh = 
				op_intrpt_schedule_self (current_time + tc_config_arr [ba_cntl_fields_ptr->tid].ba_timeout_value, WlanC_BA_Inactive_Tout_Init);
			op_ev_state_install (OPC_NIL, OPC_NIL);
			}
		}
	
	/* Reset the "bar_tx_time" information, since the response to our	*/
	/* BAR is received.													*/
	ba_info_ptr->bar_tx_time = 0.0;
	
	/* If enabled, write an ODB message.								*/
	if (wlan_trace_active)
		{				
		sprintf (msg_string1, "Received a BA from STA "OPC_INT64_FMT" for TID %d.", ba_info_ptr->peer_addr, ba_info_ptr->tid); 
		sprintf (msg_string2, "Failed MPDUs = %d, unacked MPDUs = %d, new starting sequence number = %d.", 
				 failed_mpdu_count, unacked_mpdu_count, ba_info_ptr->starting_seq_num); 
		op_prg_odb_print_major (msg_string1, msg_string2, OPC_NIL);
		}
	
	FOUT;
	}

static void
wlan_hcf_ba_inactivity_timeout_handle (WlanT_HCF_BA_State* ba_info_ptr, int code)
	{
	WlanT_HCF_Peer_Info*	peer_info_ptr;
	OpT_Int64				peer_addr;
	int						tid;
	char					msg_string [256];
	
	/** This function is called when inactivity timer expires for a		**/
	/** block-ACK agreement, whose state information is provided. The	**/
	/** "code" indicates whether this MAC is the initiator or the		**/
	/** recipient of the agreement. The function tears down the			**/
	/** agreement by freeing all related memory, discarding the MPDUs	**/
	/** in the retransmission or reordering buffer, dequeueing all BA	**/
	/** related packets of this agreement in the transmission queues,	**/
	/** if any, and enqueuing a DELBA message for the peer.				**/
	FIN (wlan_hcf_ba_inactivity_timeout_handle (ba_info_ptr, code));
	
	/* We are tearing down one of our block-ACK agreements due to		*/
	/* inactivity. First check whether we are the originator or the		*/
	/* recipient of the agreement.										*/
	if (code == WlanC_BA_Inactive_Tout_Rcpt)
		{
		/* We are the recipient of the block-ACKed traffic. Enqueue a	*/
		/* DELBA message for the peer.									*/
		wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_DELBA, ba_info_ptr->tid, ba_info_ptr->peer_addr, 0, OPC_FALSE);
		
		/* Forward any MSDU in the reordering buffer that can be fully	*/
		/* assembled, flush the MSDU that can't be assembled, and		*/
		/* destroy the buffer. Also free any memory we allocated as a	*/
		/* block-ACK traffic recipient.									*/
		wlan_hcf_peer_tid_ba_info_flush (ba_info_ptr, WlanC_BA_Recipient);
		
		/* If we don't have a block-ACK agreement for the same peer and	*/
		/* TID originated by us, destroy the BA state record for this	*/
		/* peer and TID.												*/
		if (ba_info_ptr->status == WlanC_BA_Uninitiated)
			{
			peer_addr = ba_info_ptr->peer_addr;
			tid       = ba_info_ptr->tid;
			op_prg_mem_free (ba_info_ptr);
			peer_info_ptr = (wlan_flags->ad_hoc_or_ap == OPC_FALSE) ? ap_peer_info_ptr :
								(WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(peer_addr));				
			peer_info_ptr->ba_state_ptr_arr [tid] = OPC_NIL;
			}
		else
			/* Set the peer block size to 0 indicating that there is no	*/
			/* BA agreement for this peer and TID where we are the		*/
			/* recipient.												*/
			ba_info_ptr->peer_block_size = 0;
		}
	else
		{
		/* We are the initiator of the block-ACKed traffic. Enqueue a	*/
		/* DELBA message for the peer.									*/
		wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_DELBA, ba_info_ptr->tid, ba_info_ptr->peer_addr, 0, OPC_TRUE);
		
		/* Flush the MPDUs in the retransmission buffer and destroy the	*/
		/* buffer.														*/
		wlan_hcf_peer_tid_ba_info_flush (ba_info_ptr, WlanC_BA_Initiator);
		
		/* If running, which is possible but highly unlikely, cancel	*/
		/* ADDBA response timeout timer.								*/
		if (op_ev_valid (ba_info_ptr->addba_resp_timeout_evh))
			op_ev_cancel (ba_info_ptr->addba_resp_timeout_evh);
		
		/* If we don't have a block-ACK agreement with the same peer	*/
		/* and TID originated by the peer, destroy the BA state record	*/
		/* for this peer and TID.										*/
		peer_addr = ba_info_ptr->peer_addr;
		tid       = ba_info_ptr->tid;
		if (ba_info_ptr->peer_block_size == 0)
			{
			op_prg_mem_free (ba_info_ptr);
			peer_info_ptr = (wlan_flags->ad_hoc_or_ap == OPC_FALSE) ? ap_peer_info_ptr :
								(WlanT_HCF_Peer_Info *) prg_bin_hash_table_item_get (peer_info_hash_tbl, (void *) &(peer_addr));				
			peer_info_ptr->ba_state_ptr_arr [tid] = OPC_NIL;
			}
		else
			ba_info_ptr->status = WlanC_BA_Uninitiated;
		
		/* Scan the transmission buffer of the AC and remove any BA		*/
		/* related packet, and	change the ACK policy of data frames.	*/
		if (op_prg_list_size (hlpk_lptr_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [tid]]) > 0)
			wlan_hcf_ac_queue_ba_terminate (WLANC_UP_TO_AC_MAPPING_ARRAY [tid], peer_addr, tid);
		}
	
	/* If enabled, write an ODB message.								*/
	if (wlan_trace_active)
		{				
		sprintf (msg_string, "Inactivity timer has expired for BA agreement with STA "OPC_INT64_FMT" (%s) for TID %d.", 
			ba_info_ptr->peer_addr, (code == WlanC_BA_Inactive_Tout_Rcpt) ? "originator" : "recipient", ba_info_ptr->tid);
		op_prg_odb_print_major (msg_string, OPC_NIL);
		}
	
	FOUT;
	}

static void
wlan_hcf_ac_queue_ba_terminate (WlanT_HCF_Access_Category ac, OpT_Int64 peer_addr, int tid)
	{
	int							ac_queue_size, i;
	List*						ac_hlpk_lptr;
	WlanT_HCF_Hld_Info*			hld_info_ptr;

	/** This function is called when a block-ACK agreement is torn		**/
	/** down. It scans the packets in the queue of the given AC for the	**/
	/** given peer belonging to the given TID. Among those packets,		**/
	/** BARs and block-MPDU retransmission are removed from the queue,	**/
	/** and ACK-policy of the data frames are changed to Normal-ACK.	**/
	FIN (wlan_hcf_ac_queue_ba_terminate (ac, peer_addr, tid));
	
	/* Scan the packets in AC's transmission buffer.					*/
	for (ac_hlpk_lptr = hlpk_lptr_arr [ac], ac_queue_size = op_prg_list_size (ac_hlpk_lptr), i = 0; i < ac_queue_size; )
		{
		/* Access the record of the current packet.						*/
		hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_hlpk_lptr, i);
		
		/* Check for a match.											*/
		if (hld_info_ptr->up == tid && (wlan_flags->ad_hoc_or_ap == OPC_FALSE || hld_info_ptr->dest_addr == peer_addr))
			{
			/* Remove if it is a BAR or block MPDU retransmission.		*/
			if (hld_info_ptr->type == WlanC_BAR || hld_info_ptr->ba_retx == OPC_TRUE)
				{
				wlan_hcf_frame_remove (ac, i);
				ac_queue_size--;
				}
			
			/* Otherwise, it is probably a QoS data frame. In any case,	*/
			/* set its ACK policy to normal ACK.						*/
			else
				{
				hld_info_ptr->ack_policy = WlanC_Normal_ACK;
				i++;
				}
			}
		else
			i++;
		}
	
	/* If the AC's queue is emptied due	to removals above, update the	*/
	/* AC queue	status info.											*/
	if (ac_queue_size == 0 && !(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [ac]))
		{
		for (i = 0; ac_queue_status_arr [i] != ac; i++);
		do
			{
			ac_queue_status_arr [i] = ac_queue_status_arr [i + 1];
			i++;
			} while (ac_queue_status_arr [i] != WlanC_AC_None);
		}

	FOUT;
	}

static void
wlan_hcf_queued_ba_remove (OpT_Int64 peer_addr, int tid)
	{
	int							queue_size, i;
	List*						voice_hlpk_lptr;
	WlanT_HCF_Hld_Info*			hld_info_ptr;

	/** This function removes the delayed BA queued in voice AC's		**/
	/** transmission buffer destined to the given peer for the given	**/
	/** TID. It expects the BA to exist in the queue, otherwise			**/
	/** terminates the simulation.										**/
	FIN (wlan_hcf_queued_ba_remove (peer_addr, tid));
	
	/* Scan the packets in Voice AC's transmission buffer to find the	*/
	/* requested BA, which has to be close to the head due to its		*/
	/* priority.														*/
	for (voice_hlpk_lptr = hlpk_lptr_arr [WlanC_AC_VO], queue_size = op_prg_list_size (voice_hlpk_lptr), i = 0; i < queue_size; )
		{
		/* Access the record of the current packet.						*/
		hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (voice_hlpk_lptr, i);
		
		/* Is this the BA we are looking for?							*/
		if (hld_info_ptr->type == WlanC_BA && hld_info_ptr->dest_addr == peer_addr && hld_info_ptr->up == tid)
			{
			/* Remove it and terminate the search.						*/
			wlan_hcf_frame_remove (WlanC_AC_VO, i);
			i = queue_size;
			}
		else
			{
			/* Move to the next one and make sure that we didn't reach	*/
			/* end of the queue.										*/
			i++;
			if (i == queue_size)
				wlan_error_print ("Expected BA is not found in the Voice AC transmission queue.", "", "");
			}
		}
	
	FOUT;
	}

static void
wlan_hcf_action_mmpdu_process (Packet* frame_body_pkptr, OpT_Int64 peer_addr, WlanT_HCF_Peer_Info* peer_info_ptr)
	{
	int							category, action, tid;
	WlanT_HCF_BA_State*			peer_tid_ba_info_ptr;
	const WlanT_ADDBA_Fields*	addba_params_ptr;
	const WlanT_DELBA_Fields*	delba_params_ptr;
	int							ac_queue_size, i;
	List*						ac_hlpk_lptr;
	WlanT_HCF_Hld_Info*			hld_info_ptr;
	char						msg_string [128];
	
	/** This function procsses the given action MMPDU, received		**/
	/** from physical layer, and prepares and enqueues the response	**/
	/** frame if needed.											**/	
	FIN (wlan_hcf_action_mmpdu_process (frame_body_pkptr, peer_addr, peer_info_prt));

	/* Find out the category and action type of the received		*/
	/* message.														*/
	op_pk_fd_get_int32 (frame_body_pkptr, WLANC_ACT_MGMT_CAT_ACT_FD, &category);
	action   = category & WlanC_Action_Bit_Map;
	category = category >> WLANC_MMPDU_ACTION_FD_SIZE;
	
	/* Retrieve the TID information of the action MMPDU.			*/
	op_pk_fd_get_int32 (frame_body_pkptr, WLANC_ACT_MGMT_TID_FD, &tid);
	
	/* Based on the category and action, perform the necessary		*/
	/* tasks.														*/
	switch (category)
		{
		case WlanC_Category_Block_ACK:
			{
			switch (action)
				{
				case WlanC_Action_ADDBA_Request:
					{
					/* Get our BA state information with this peer	*/
					/* and TID.										*/
					peer_tid_ba_info_ptr = wlan_hcf_ba_state_info_get (peer_info_ptr, peer_addr, (OpT_uInt8) tid);
					
					/* If duplicate, processing is not needed. Just	*/
					/* send an ADDBA Response message.				*/
					if (peer_tid_ba_info_ptr->peer_block_size > 0)
						{
						wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_ADDBA_Response, tid, peer_addr, 0, OPC_FALSE);						

						/* Write an ODB message if enabled.			*/
						if (wlan_trace_active)
							{
							sprintf (msg_string,  "Duplicate ADDBA Request is received from STA "OPC_INT64_FMT" for TID %d.\n", peer_addr, tid); 
							op_prg_odb_print_major (msg_string, OPC_NIL);
							}
						
						break;
						}
					
					/* Record the peer's block ACK policy and 		*/
					/* requested block size.						*/
					
					//Loren: Function does not get called from here in normal operation.
					op_pk_fd_access_read_only_ptr (frame_body_pkptr, WLANC_ACT_MGMT_PARAMS_FD, (const void **) &addba_params_ptr);
					peer_tid_ba_info_ptr->peer_policy        = addba_params_ptr->policy; 
					peer_tid_ba_info_ptr->peer_block_size    = addba_params_ptr->block_size;
					peer_tid_ba_info_ptr->peer_timeout_value = addba_params_ptr->timeout_value;
					peer_tid_ba_info_ptr->rcvd_mpdu_count    = 0;
					peer_tid_ba_info_ptr->first_mpdu_rcvd	 = OPC_FALSE;
					
					/* Initialize status bit map and re-ordering	*/
					/* buffer.										*/
					peer_tid_ba_info_ptr->peer_starting_seq_num = addba_params_ptr->starting_seq_num;
					peer_tid_ba_info_ptr->last_fwd_seq_num      = (peer_tid_ba_info_ptr->peer_starting_seq_num == 0) ? 
																  WLANC_SEQ_NUM_WRAP_VALUE - 1 : peer_tid_ba_info_ptr->peer_starting_seq_num - 1;
					peer_tid_ba_info_ptr->block_ack_fields_ptr  = OPC_NIL; 
					peer_tid_ba_info_ptr->reordering_buffer_ptr = OPC_NIL; 
					peer_tid_ba_info_ptr->last_rcvd_msdu_ptr 	= OPC_NIL;
					peer_tid_ba_info_ptr->status_bitmap         = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_BA_RECIPIENT_SB_MAX_MSDU * sizeof (OpT_uInt16));
					for (i = 0; i < WLANC_BA_RECIPIENT_SB_MAX_MSDU; i++)
						peer_tid_ba_info_ptr->status_bitmap [i] = 0;

					/* Create pool memories or get a handle to them	*/
					/* to be used for reordering buffer entries.	*/
					peer_tid_ba_info_ptr->buffered_msdu_pmh = op_prg_pmo_define ("BA Reordering Buffer MSDU", sizeof (WlanT_BA_Buffered_MSDU), 64);
					peer_tid_ba_info_ptr->buffered_mpdu_pmh = op_prg_pmo_define ("BA Reordering Buffer MPDU", sizeof (WlanT_BA_Buffered_MPDU), 64);
					
					/* Start the inactivity timer.					*/
					if (peer_tid_ba_info_ptr->peer_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
						{
						op_ev_state_install (peer_tid_ba_info_ptr, OPC_NIL);
						peer_tid_ba_info_ptr->peer_inactivity_evh = 
							op_intrpt_schedule_self (current_time + peer_tid_ba_info_ptr->peer_timeout_value, WlanC_BA_Inactive_Tout_Rcpt);
						op_ev_state_install (OPC_NIL, OPC_NIL);
						}
					
					/* Update the total size of reordering buffers	*/
					/* of the active BA agreements and record that	*/
					/* into the corresponding statistic. Register	*/
					/* the statistic if necessary.					*/
					if (total_ba_reorder_buf_size < 0)
						{
						total_reorder_size_handle = op_stat_reg ("WLAN Block-ACK.Total Reordering Buffer Size (bytes)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
						total_ba_reorder_buf_size = 0;
						}
					total_ba_reorder_buf_size += (addba_params_ptr->block_size * WLANC_MAXMSDU_LENGTH / 8);
					op_stat_write (total_reorder_size_handle, total_ba_reorder_buf_size);
						
					/* Send an ADDBA response frame.				*/
					wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_ADDBA_Response, tid, peer_addr, 0, OPC_FALSE);
					break;
					}
					
				case WlanC_Action_ADDBA_Response:
					{
					/* Have a local handle to the BA state info for	*/
					/* quick access.								*/
					peer_tid_ba_info_ptr = peer_info_ptr->ba_state_ptr_arr [tid];
					
					/* If duplicate, processing is not needed.		*/
					if (peer_tid_ba_info_ptr->status == WlanC_BA_Established)
						{
						/* Write an ODB message if enabled.			*/
						if (wlan_trace_active)
							{
							sprintf (msg_string,  "Duplicate ADDBA Response is received from STA "OPC_INT64_FMT" for TID %d.\n", peer_addr, tid); 
							op_prg_odb_print_major (msg_string, OPC_NIL);
							}
						
						break;
						}
					
					/* Update the BA record to indicate the block	*/
					/* ACK agreement with the peer.					*/
					peer_tid_ba_info_ptr->status              = WlanC_BA_Established;
					peer_tid_ba_info_ptr->addba_failure_count = 0;
					
					/* Initialize the related parameters.			*/
					peer_tid_ba_info_ptr->block_size          = tc_config_arr [tid].ba_block_size;
					peer_tid_ba_info_ptr->queued_msdu_count   = 0;
					peer_tid_ba_info_ptr->mpdu_count          = 0;
					peer_tid_ba_info_ptr->starting_seq_num    = peer_info_ptr->tid_seq_counter_arr [tid];
					peer_tid_ba_info_ptr->max_acked_seq_num   = (peer_tid_ba_info_ptr->starting_seq_num == 0) ? WLANC_SEQ_NUM_WRAP_VALUE - 1 : peer_tid_ba_info_ptr->starting_seq_num - 1;
					peer_tid_ba_info_ptr->bar_pending         = OPC_FALSE;
					peer_tid_ba_info_ptr->awaiting_delayed_ba = OPC_FALSE;
					peer_tid_ba_info_ptr->bar_tx_time         = 0.0;
					peer_tid_ba_info_ptr->bar_ack_time        = 0.0;

					/* Create the BA retransmission buffer. In case	*/
					/* of delayed BA, make the buffer slightly 		*/
					/* bigger than the block size since we may		*/
					/* continue sending MPDUs while awaiting a BA.	*/
					peer_tid_ba_info_ptr->retx_arr_size = peer_tid_ba_info_ptr->block_size + 
						(tc_config_arr [tid].ba_policy == WlanC_Delayed_BA) ? max_frags_per_msdu * DELAYED_BA_BK_SIZE_ADJ: 0;
					peer_tid_ba_info_ptr->retx_arr = (WlanT_HCF_Hld_Info **) op_prg_mem_alloc (peer_tid_ba_info_ptr->retx_arr_size * sizeof (WlanT_HCF_Hld_Info *));
					
					/* Stop the ADDBA response timeout timer.		*/
					/* Check for its validity, because in rare		*/
					/* cases we may receive the response without	*/
					/* receiving an ACK for the request (peer		*/
					/* receives our request but we fail to receive	*/
					/* its ACK, but then we receive its response).	*/
					if (op_ev_valid (peer_tid_ba_info_ptr->addba_resp_timeout_evh))
						op_ev_cancel (peer_tid_ba_info_ptr->addba_resp_timeout_evh);
					
					/* Start the inactivity timer if enabled.		*/
					if (tc_config_arr [tid].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
						{
						op_ev_state_install (peer_tid_ba_info_ptr, OPC_NIL);
						peer_tid_ba_info_ptr->inactivity_evh =  op_intrpt_schedule_self (current_time + tc_config_arr [tid].ba_timeout_value, WlanC_BA_Inactive_Tout_Init);
						op_ev_state_install (OPC_NIL, OPC_NIL);
						}
						
					/* Write an ODB message if enabled.				*/
					if (wlan_trace_active)
						{
						sprintf (msg_string,  "Block ACK agreement is established with STA "OPC_INT64_FMT" for TID %d.\n", peer_addr, tid); 
						op_prg_odb_print_major (msg_string, OPC_NIL);
						}

					/* If there are any packets already queued for	*/
					/* this peer and for this TID, then change		*/
					/* their ACK policy to block ACK.				*/
					ac_queue_size = op_prg_list_size (hlpk_lptr_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [tid]]);
					if (ac_queue_size > 0)
						{
						/* Skip the first packet if it is currently	*/
						/* being transmitted.						*/
						ac_hlpk_lptr = hlpk_lptr_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [tid]];
						if (((WlanT_HCF_Hld_Info *) op_prg_list_access (ac_hlpk_lptr, OPC_LISTPOS_HEAD))->pkptr == OPC_NIL ||
							src_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [tid]] > 0)
							i = 1;
						else
							i = 0;
						
						/* Go over the list of queued packets.		*/
						if (wlan_flags->ad_hoc_or_ap == OPC_TRUE)
							{
							for (; i < ac_queue_size; i++)
								{
								/* If it is a frame of the matching	*/
								/* destination and TID,	change the	*/
								/* policy.							*/
								hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_hlpk_lptr, i);
								if (hld_info_ptr->dest_addr == peer_addr && hld_info_ptr->up == tid && (hld_info_ptr->type & WLANC_DATA_TYPE_BIT))
									{
									hld_info_ptr->ack_policy = WlanC_Block_ACK;
									peer_tid_ba_info_ptr->queued_msdu_count++;
									}
								}
							}
						else
							{
							for (; i < ac_queue_size; i++)
								{
								/* If it is a frame of the matching	*/
								/* TID,	change the policy.			*/ 
								hld_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (ac_hlpk_lptr, i);
								if (hld_info_ptr->up == tid && (hld_info_ptr->type & WLANC_DATA_TYPE_BIT))
									{
									hld_info_ptr->ack_policy = WlanC_Block_ACK;
									peer_tid_ba_info_ptr->queued_msdu_count++;
									}
								}
							}
						}
					
					break;
					}
				
				case WlanC_Action_DELBA:
					{
					/* Have a local handle to the BA state info for	*/
					/* quick access.								*/
					peer_tid_ba_info_ptr = peer_info_ptr->ba_state_ptr_arr [tid];
					
					/* Get the value of "initiator" information and	*/
					/* tear down the corresponding BA agreement		*/
					/* unless we have already done, which is likely.*/
					
					//Loren: Function does not get called from here in normal operation.
					op_pk_fd_access_read_only_ptr (frame_body_pkptr, WLANC_ACT_MGMT_PARAMS_FD, (const void **) &delba_params_ptr);
					if (delba_params_ptr->initiator == OPC_TRUE && peer_tid_ba_info_ptr != OPC_NIL && peer_tid_ba_info_ptr->peer_block_size > 0)
						{
						/* The peer (initiator) wants to tear down	*/
						/* the BA agreement for this TID. Forward	*/
						/* any MSDU in the reordering buffer that	*/
						/* can be fully	assembled, flush the MSDU	*/
						/* that can't be assembled, and	destroy the	*/
						/* buffer. 									*/
						wlan_hcf_peer_tid_ba_info_flush (peer_tid_ba_info_ptr, WlanC_BA_Recipient);
						
						/* Cancel the inactivity timer.				*/
						if (peer_tid_ba_info_ptr->peer_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
							op_ev_cancel (peer_tid_ba_info_ptr->peer_inactivity_evh);
						
						/* If any, destroy any queued BAs.			*/
						if (peer_tid_ba_info_ptr->peer_policy          == WlanC_Delayed_BA && 
							peer_tid_ba_info_ptr->block_ack_fields_ptr != OPC_NIL            )
							wlan_hcf_queued_ba_remove (peer_addr, tid);
		
						/* If we don't have a block-ACK agreement	*/
						/* for the same peer and TID originated by	*/
						/* us, destroy the BA state record for this	*/
						/* peer and TID.							*/
						if (peer_tid_ba_info_ptr->status == WlanC_BA_Uninitiated)
							{
							op_prg_mem_free (peer_info_ptr->ba_state_ptr_arr [tid]);
							peer_info_ptr->ba_state_ptr_arr [tid] = OPC_NIL;
							}
						else
							peer_tid_ba_info_ptr->peer_block_size = 0;
						
						/* Write an ODB message if enabled.			*/
						if (wlan_trace_active)
							{
							sprintf (msg_string,  "DELBA is received and processed from STA "OPC_INT64_FMT" (initiator) for TID %d.\n", peer_addr, tid); 
							op_prg_odb_print_major (msg_string, OPC_NIL);
							}
						}
					else if (delba_params_ptr->initiator == OPC_FALSE && peer_tid_ba_info_ptr != OPC_NIL && 
							 peer_tid_ba_info_ptr->status == WlanC_BA_Established)
						{
						/* The peer (recipient) wants to tear down	*/
						/* the BA agreement for this TID. Flush the	*/
						/* MPDUs in the retransmission buffer and	*/
						/* destroy the buffer.						*/
						wlan_hcf_peer_tid_ba_info_flush (peer_tid_ba_info_ptr, WlanC_BA_Initiator);

						/* If running, cancel the inactivity timer.	*/
						if (tc_config_arr [tid].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT && 
							op_ev_valid (peer_tid_ba_info_ptr->inactivity_evh) == OPC_TRUE)
							op_ev_cancel (peer_tid_ba_info_ptr->inactivity_evh);
						
						/* Similarly, if running, cancel the ADDBA	*/
						/* failure timer. This is extremely rare,	*/
						/* but possible (when the environment is	*/
						/* very noisy due to jammers and the		*/
						/* inactivity timeout value is considerably	*/
						/* low.										*/
						if (op_ev_valid (peer_tid_ba_info_ptr->addba_resp_timeout_evh))
							op_ev_cancel (peer_tid_ba_info_ptr->addba_resp_timeout_evh);
						
						/* If we don't have a block-ACK agreement	*/
						/* for the same peer and TID originated by	*/
						/* the peer, destroy the BA state record	*/
						/* for this	peer and TID.					*/
						if (peer_tid_ba_info_ptr->peer_block_size == 0)
							{
							op_prg_mem_free (peer_info_ptr->ba_state_ptr_arr [tid]);
							peer_info_ptr->ba_state_ptr_arr [tid] = OPC_NIL;
							}
						else
							peer_tid_ba_info_ptr->status = WlanC_BA_Uninitiated;
						
						/* Scan the transmission buffer of the AC	*/
						/* and remove any BA related packet, and	*/
						/* change the ACK policy of data frames.	*/
						if (op_prg_list_size (hlpk_lptr_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [tid]]) > 0)
							wlan_hcf_ac_queue_ba_terminate (WLANC_UP_TO_AC_MAPPING_ARRAY [tid], peer_addr, tid);
							
 						/* Write an ODB message if enabled.			*/
						if (wlan_trace_active)
							{
							sprintf (msg_string,  "DELBA is received and processed from STA "OPC_INT64_FMT" (recipient) for TID %d.\n", peer_addr, tid); 
							op_prg_odb_print_major (msg_string, OPC_NIL);
							}
						}
					else
						{
						/* Write an ODB message if enabled.			*/
						if (wlan_trace_active)
							{
							sprintf (msg_string,  "DELBA is received and discarded from STA "OPC_INT64_FMT" for TID %d.\n", peer_addr, tid); 
							op_prg_odb_print_major (msg_string, OPC_NIL);
							}
						}
					break;
					}
				}
			}
		}
	
	/* Destroy the action MMPDU frame body.							*/
	op_pk_destroy (frame_body_pkptr);
	
	FOUT;
	}

static WlanT_HCF_BA_State*
wlan_hcf_ba_state_info_get (WlanT_HCF_Peer_Info* peer_info_ptr, OpT_Int64 peer_addr, OpT_uInt8 tid)
	{
	int i;
	
	/** This function returns the state information of BA operation **/
	/** with the given STA and for the given TID. If no state		**/
	/** information records are found, they are created.			**/
	FIN (wlan_hcf_ba_state_info_get (peer_info_ptr, peer_addr, tid));
	
	/* Check the block ACK status with the given peer and TID.		*/
	if (peer_info_ptr->ba_state_ptr_arr == OPC_NIL) 
		{
		/* Create the array that will hold block ACK information	*/
		/* with this peer for all TIDs.								*/
		peer_info_ptr->ba_state_ptr_arr = (WlanT_HCF_BA_State **) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (WlanT_HCF_BA_State *));
		for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
			peer_info_ptr->ba_state_ptr_arr [i] = OPC_NIL;
		}
	
	/* Also create a record for the given TID if necessary.			*/
	if (peer_info_ptr->ba_state_ptr_arr [tid] == OPC_NIL)
		{
		peer_info_ptr->ba_state_ptr_arr [tid] = (WlanT_HCF_BA_State *) op_prg_mem_alloc (sizeof (WlanT_HCF_BA_State));
	
		/* Set the fields that identify the record.					*/
		peer_info_ptr->ba_state_ptr_arr [tid]->peer_addr = peer_addr;
		peer_info_ptr->ba_state_ptr_arr [tid]->tid       = tid;
		
		/* Initialize the fields that indicate that there is		*/
		/* currently no BA agreement with the peer in either		*/
		/* direction.												*/
		peer_info_ptr->ba_state_ptr_arr [tid]->status              = WlanC_BA_Uninitiated;
		peer_info_ptr->ba_state_ptr_arr [tid]->addba_failure_count = 0;
		peer_info_ptr->ba_state_ptr_arr [tid]->peer_block_size     = 0;
		}
	
	/* Return the created or found record.							*/
	FRET (peer_info_ptr->ba_state_ptr_arr [tid]);
	}

static void
wlan_hcf_accepted_frame_stats_update (Packet* seg_pkptr, WlanT_HCF_Access_Category ac)
	{
	double	ete_delay, pk_size;
	
	/** This function is called just before a frame received from	**/
	/** physical layer being forwarded to the higher layer to		**/
	/** update end-to-end delay and throughput statistics. It 		**/
	/** all the related local and global, general and AC specific	**/
	/** statistics.													**/
	FIN (wlan_hcf_accepted_frame_stats_update (seg_pkptr, ac));
	
	/* Register the inbound traffic statistics for the given AC, if	*/
	/* this is the very first packet received that belongs to that	*/
	/* AC.															*/
	if (!(wlan_ac_flags->stats_registered & (WLANC_AC_BITMAP_ARRAY [ac] << WLANC_HCF_AC_COUNT)))
		wlan_hcf_ac_statistics_register (ac, OPC_FALSE);
	
	/* Total number of bits sent to higher layer is equivalent to	*/
	/* throughput.													*/
	pk_size = (double) op_pk_total_size_get (seg_pkptr);
	op_stat_write (throughput_handle,            pk_size);
	op_stat_write (throughput_handle,            0.0);
	op_stat_write (ac_throughput_shndl_arr [ac], pk_size);
	op_stat_write (ac_throughput_shndl_arr [ac], 0.0);

	/* Also update the global WLAN throughput statistic.			*/
	op_stat_write (global_throughput_handle,        pk_size);
	op_stat_write (global_throughput_handle,        0.0);
	op_stat_write (ac_gb_throughput_shndl_arr [ac], pk_size);
	op_stat_write (ac_gb_throughput_shndl_arr [ac], 0.0);
	
	/* Compute the end-to-end delay for the frame and record it.	*/
	ete_delay = current_time - op_pk_stamp_time_get (seg_pkptr);
	op_stat_write (ete_delay_handle, 		   ete_delay);
	op_stat_write (ac_delay_shndl_arr [ac],    ete_delay);
	op_stat_write (global_ete_delay_handle,    ete_delay);
	op_stat_write (ac_gb_delay_shndl_arr [ac], ete_delay);
		
	FOUT;
	}

static void
wlan_hcf_frame_discard (WlanT_HCF_Access_Category discard_ac)
	{
	int 				seg_bufsize;
	int					tid;
	Packet* 			seg_pkptr;
	double				discard_pksize;
	Boolean				ba_inactivity = OPC_FALSE;
	WlanT_HCF_Hld_Info*	bar_info_ptr;
	WlanT_HCF_Hld_Info*	mmpdu_info_ptr;
	WlanT_HCF_BA_State*	ba_state_info_ptr;
	char				msg_string1 [256];
	char				msg_string2 [256];
	
	/** This function is called to check whether the retransmissions of the	**/
	/** frame that is at the head of the queue of the given access category	**/
	/** has reached any of the retry limits. If this is the case then the	**/
	/** frame is discarded, and CW-backoff required flag is set for that AC.**/
	/** If the frame checked is a BAR, for which no retry counts are used,	**/
	/** then it is discarded if its transmit lifetime has expired, which	**/
	/** indicates that the transmit lifetime has also expired for all MPDUs	**/
	/** that correspond to that BAR.										**/
	FIN (wlan_hcf_frame_discard (discard_ac));

	/* If one of the retry limits was reached then drop the frame. For BAR	*/
	/* frames, don't pay attention to the retry counts; instead check		*/
	/* whether its MPDUs reached their transmission lifetime limit. The		*/
	/* creation time of a BAR frame is equal to the transmission time of	*/
	/* the MPDU that is transmitted as the last MPDU of BAR's block. Also	*/
	/* discard the BAR, if BA inactivity timer has expired.					*/
	if ((txframe_type != WlanC_BAR && (src_arr [discard_ac] == short_retry_limit || lrc_arr [discard_ac] == long_retry_limit)) || txframe_type == WlanC_BAR)
		{				 
		/* If this is a BAR, use its own rules to decide whether to discard	*/
		/* it or not.														*/
		if (txframe_type == WlanC_BAR)
			{
			/* Access the information record of the frame.					*/
			bar_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [discard_ac], OPC_LISTPOS_HEAD);
			
			/* Access the BA state information of the BAR.					*/
			ba_state_info_ptr = bar_info_ptr->addr1_info_ptr->ba_state_ptr_arr [bar_info_ptr->up];
			
			/* Check whether it has to be discarded.						*/
			if (op_ev_pending (ba_state_info_ptr->inactivity_evh))
				{
				/* In this extremely rare situation, we received an out of	*/
				/* sequence BA from the peer while we are trying to send	*/
				/* our BAR. Hence, discard the BAR by not exiting the		*/
				/* function here.											*/	
				}
			else if (tc_config_arr [bar_info_ptr->up].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT &&
					 current_time - ba_state_info_ptr->bar_tx_time >= tc_config_arr [bar_info_ptr->up].ba_timeout_value)
				{
				/* Inactivity timer has expired. Discard the BAR, as well	*/
				/* as tear down the BA agreement and enqueue a DELBA for	*/
				/* the peer later below.									*/
				ba_inactivity = OPC_TRUE;
				}
			else if (current_time - bar_info_ptr->time_rcvd >= MAX_MSDU_TX_LIFETIME)
				{
				/* Discard due to transmit lifetime limit of the MSDUs 		*/
				/* (will be performed below). Resume inactivity timer if	*/
				/* used.													*/
				if (tc_config_arr [bar_info_ptr->up].ba_timeout_value != NO_BA_INACTIVITY_TIMEOUT)
					{
					op_ev_state_install (ba_state_info_ptr, OPC_NIL);
					ba_state_info_ptr->inactivity_evh = 
						op_intrpt_schedule_self (ba_state_info_ptr->bar_tx_time + tc_config_arr [bar_info_ptr->up].ba_timeout_value, WlanC_BA_Inactive_Tout_Init);				
					op_ev_state_install (OPC_NIL, OPC_NIL);
					}
				}
			else
				{
				/* Don't discard. Continue with a retransmission.			*/
				FOUT;
				}
			}

		/* Update retransmission count statistic. Decrement the retry count	*/
		/* since we didn't make the last retransmission as a result of		*/
		/* reaching the retry limit.										*/
		op_stat_write (retrans_handle,        (double) (src_arr [discard_ac] + lrc_arr [discard_ac] - 1));
		op_stat_write (global_retrans_handle, (double) (src_arr [discard_ac] + lrc_arr [discard_ac] - 1));		

		/* Reset the retry counts for the next packet.						*/
		src_arr [discard_ac] = 0;
		lrc_arr [discard_ac] = 0;
		
		/* Get the segmentation buffer size to check if there are more		*/
		/* fragments left to be transmitted.								*/
		seg_bufsize = (int) op_sar_buf_size (fragmentation_buffer_arr [discard_ac]); 
		if (seg_bufsize != 0)
			{
			/* Discard remaining fragments.									*/
			seg_pkptr = op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [discard_ac], seg_bufsize);
			op_pk_destroy (seg_pkptr);
			
			/* If the frame's ACK policy is block-ACK, then decrease the	*/
			/* buffer usage by higher layer data, because normally buffer	*/
			/* usage is not reduced when data frames with block-ACK policy	*/
			/* are removed from transmission queues with 					*/
			/* wlan_hcf_hlpk_dequeue() function, which is called below to	*/
			/* remove the discarded frame from the transmission queue.		*/
			if (((WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [discard_ac], OPC_LISTPOS_HEAD))->ack_policy == WlanC_Block_ACK)
				{
				if(LorenDebugFlag)
				{
					printf("total_hlpk_size before decrement #4 = %d\n", (int)total_hlpk_size);
				}
				total_hlpk_size -= seg_bufsize;
				if(LorenDebugFlag)
				{
					printf("total_hlpk_size after decrement #4 = %d\n", (int)total_hlpk_size);
				}
				}
			}

		/* If expecting ACK frame then destroy the tx data frame as this	*/
		/* frame will no longer be transmitted (even if we are not			*/
		/* expecting an ACK at this	moment, we still may have a copy of the	*/
		/* frame if at one point in the	retransmission history of the		*/
		/* original packet we received a CTS for our RTS but then didn't	*/
		/* receive an ACK for our data transmission; hence consider this	*/
		/* case as well).													*/
		if ((expected_frame_type == WlanC_Ack) || (mpdu_retx_copy_arr [discard_ac] != OPC_NIL))			
			{	
			/* Destroy the copy of the frame as the packet is discarded.	*/
			op_pk_destroy (mpdu_retx_copy_arr [discard_ac]);
			mpdu_retx_copy_arr [discard_ac] = OPC_NIL;
			}
			
		/* Reset the "frame to respond" variable unless we have a CTS or  	*/
		/* ACK to send.														*/
		if (fresp_to_send == WlanC_QoS_Data)
			{
			fresp_to_send = WlanC_None;
			}
		
		/* If we are discarding a BAR frame, also remove the remaining		*/
		/* copies of the MPDUs of BAR's block in the retransmission buffer.	*/
		if (txframe_type == WlanC_BAR)
			wlan_hcf_bar_mpdus_discard ((WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [discard_ac], OPC_LISTPOS_HEAD));
		
		/* Else if we are discarding an ADDBA request, increment the		*/
		/* corresponding ADDBA failure counter.								*/
		else if (txframe_type == WlanC_Action)
			{
			/* Access the information record of the MMPDU.					*/
			mmpdu_info_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [discard_ac], OPC_LISTPOS_HEAD);
			
			/* Is this MMPDU an ADDBA request?								*/
			if (mmpdu_info_ptr->mmpdu_cat_action_tid >> WLANC_MMPDU_TID_FD_SIZE == 
				(WlanC_Category_Block_ACK << WLANC_MMPDU_ACTION_FD_SIZE) + WlanC_Action_ADDBA_Request)
				{
				/* Increment the counter. If we reach the limit, don't try	*/
				/* again with a new ADDBA. Otherwise, try again if we		*/
				/* receive a new higher layer data for that peer/TID.		*/
				tid = mmpdu_info_ptr->mmpdu_cat_action_tid & WLANC_MMPDU_TID_BIT_MASK;
				if (++(mmpdu_info_ptr->addr1_info_ptr->ba_state_ptr_arr [tid]->addba_failure_count) < ADDBA_FAILURE_RETRY_LIMIT)
					mmpdu_info_ptr->addr1_info_ptr->ba_state_ptr_arr [tid]->status = WlanC_BA_Uninitiated;
				else
					mmpdu_info_ptr->addr1_info_ptr->ba_state_ptr_arr [tid]->status = WlanC_BA_Failure;

				/* Write an ODB message if enabled.							*/
				if (wlan_trace_active)
					{
					sprintf (msg_string1, "Discarding ADDBA request message for STA "OPC_INT64_FMT", TID %d due to reaching retry limit.", mmpdu_info_ptr->dest_addr, tid);
					sprintf (msg_string2, "Incrementing ADDBA retry count to %d (limit = %d).", 
							 mmpdu_info_ptr->addr1_info_ptr->ba_state_ptr_arr [tid]->addba_failure_count, ADDBA_FAILURE_RETRY_LIMIT); 
					op_prg_odb_print_major (msg_string1, msg_string2, OPC_NIL);
					}
				}
			}
			
		/* Dequeue the packet from the higher layer buffer.					*/
		discard_pksize = (double) wlan_hcf_hlpk_dequeue (discard_ac, 0);
		
		/* Update the local and global, general and AC specific statistics	*/
		/* that keep track of the dropped higher layer data as a result of	*/
		/* reaching the retry limit. All dropped non-data traffic is		*/
		/* recorded under management dropped traffic statistics.			*/
		if (txframe_type & WLANC_DATA_TYPE_BIT)
			{
			op_stat_write (retx_drop_pkts_handle,                       1.0);
			op_stat_write (retx_drop_pkts_handle,                       0.0);
			op_stat_write (retx_drop_bits_handle,                       discard_pksize);
			op_stat_write (retx_drop_bits_handle,                       0.0);
			
			my_droppedR_sum += discard_pksize;
			//my_droppedR = discard_pksize/(op_sim_time()-last_my_droppedR_calculated_time);
			//last_my_droppedR_calculated_time = op_sim_time();
			
			op_stat_write (global_retx_drop_handle,                     discard_pksize);
			op_stat_write (global_retx_drop_handle,                     0.0);
			op_stat_write (ac_dropped_retx_pkts_shndl_arr [discard_ac], 1.0);
			op_stat_write (ac_dropped_retx_pkts_shndl_arr [discard_ac], 0.0);
			op_stat_write (ac_dropped_retx_bits_shndl_arr [discard_ac], discard_pksize);
			op_stat_write (ac_dropped_retx_bits_shndl_arr [discard_ac], 0.0);
			op_stat_write (ac_gb_dropped_retx_shndl_arr [discard_ac],   discard_pksize);
			op_stat_write (ac_gb_dropped_retx_shndl_arr [discard_ac],   0.0);
			}
		else
			{
			op_stat_write (mgmt_retx_drop_pkts_handle,                  1.0);
			op_stat_write (mgmt_retx_drop_pkts_handle,                  0.0);
			op_stat_write (mgmt_retx_drop_bits_handle,                  discard_pksize);
			op_stat_write (mgmt_retx_drop_bits_handle,                  0.0);
			}
		
		/* Reset the last transmitted frame's type information since it is	*/
		/* being discarded.													*/
		txframe_type = WlanC_None;
		
		/* Although we could not transmit this data packet and eventually	*/
		/* dropped it, still set the contention window flag and back-off	*/
		/* for a contention window period. This is necessary for the		*/
		/* fairness of the algorithm. This prevents us going to IDLE state	*/
		/* (if higher layer data queue is empty) and then may attempt to	*/
		/* transmit a packet without waiting for a full backoff period as a	*/
		/* result of suddenly receiving a packet from higher layer.			*/
		wlan_ac_flags->cw_required |= WLANC_AC_BITMAP_ARRAY [discard_ac];
		
		/* If the flag is set, in addition to discarding the BAR frame,		*/
		/* also terminate the BA agreement, which we initiated.				*/
		if (ba_inactivity == OPC_TRUE)
			wlan_hcf_ba_inactivity_timeout_handle (ba_state_info_ptr, WlanC_BA_Inactive_Tout_Init);
		}
	
	FOUT;
	}

static void
wlan_hcf_frame_remove (WlanT_HCF_Access_Category discard_ac, int list_pos)
	{
	int 		seg_bufsize;
	Packet* 	seg_pkptr;
	double		discard_pksize;
	
	/** This function dequeues the entry at the given position of the given	**/
	/** AC's transmission buffer.											**/
	FIN (wlan_hcf_frame_remove (discard_ac, list_pos));

	/* Dequeue the packet from the higher layer buffer.						*/
	discard_pksize = (double) wlan_hcf_hlpk_dequeue (discard_ac, list_pos);
		
	/* Are we removing the frame that is at the head of the queue?			*/
	if (list_pos == 0)
		{
		/* Check whether we already had	transmission attempts for this		*/
		/* packet.															*/
		if (src_arr [discard_ac] + lrc_arr [discard_ac] > 0)
			{
			/* Update retransmission count statistics. Decrement the total	*/
			/* retry count by 1 since the last retransmission didn't		*/
			/* actually take place.											*/
			op_stat_write (retrans_handle,        (double) (src_arr [discard_ac] + lrc_arr [discard_ac] - 1));
			op_stat_write (global_retrans_handle, (double) (src_arr [discard_ac] + lrc_arr [discard_ac] - 1));

			/* Reset the retry counts for the next packet.					*/
			src_arr [discard_ac] = 0;
			lrc_arr [discard_ac] = 0;
		
			/* Reset the remaining backoff slots.							*/
			deference_info_arr [discard_ac].backoff_slots = BACKOFF_SLOTS_UNSET;
			
			/* Reset the txframe_type state variable to prevent double		*/
			/* discarding.													*/
			txframe_type = WlanC_None;
			
			/* Get the segmentation buffer size to check if there are more	*/
			/* fragments left to be transmitted.							*/
			seg_bufsize = (int) op_sar_buf_size (fragmentation_buffer_arr [discard_ac]); 
			if (seg_bufsize != 0)
				{
				/* Discard remaining fragments.								*/
				seg_pkptr = op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [discard_ac], seg_bufsize);
				op_pk_destroy (seg_pkptr);
				}

			/* If a copy of the last MPDU is created for retransmission,	*/
			/* destroy it.													*/
			if (mpdu_retx_copy_arr [discard_ac] != OPC_NIL)
				{	
				op_pk_destroy (mpdu_retx_copy_arr [discard_ac]);
				mpdu_retx_copy_arr [discard_ac] = OPC_NIL;
				}
			}
		}
	
	FOUT;
	}

static void
wlan_hcf_bar_mpdus_discard (WlanT_HCF_Hld_Info* bar_info_ptr)
	{
	WlanT_HCF_BA_State*				ba_info_ptr;
	const WlanT_Data_Header_Fields*	mpdu_fields_ptr;
	WlanT_HCF_Access_Category		ac;
	int								current_mpdu, new_mpdu_count;
	double							discard_pksize;
	char							msg_string1 [256];
	char							msg_string2 [256];
	
	/** This function is called to discard the MPDUs in a BA			**/
	/** retransmission buffer that correspond to the given BAR, which	**/
	/** is going to be discarded due to its consistent transmission		**/
	/** failures and reaching the transmit lifetime limit.				**/
	FIN (wlan_hcf_bar_mpdus_discard (bar_info_ptr));
	
	/* Get a handle to the BA state information with the peer and TID,	*/
	/* for which the BAR was intended.									*/	
	ba_info_ptr = bar_info_ptr->addr1_info_ptr->ba_state_ptr_arr [bar_info_ptr->up];
	
	/* Find out the AC of the BAR and its MPDUs to be used while		*/
	/* updating the statistics.											*/
	ac = WLANC_UP_TO_AC_MAPPING_ARRAY [ba_info_ptr->tid];
	
	/* Go over the array of the MPDUs and remove the ones that are		*/
	/* older than BAR (or same age). The oldest MPDUs are at the head	*/
	/* of the array.													*/
	for (current_mpdu = 0, new_mpdu_count = 0; current_mpdu < ba_info_ptr->mpdu_count; current_mpdu++)
		{
		/* Compare MPDU's age with BAR's age.							*/
		if (ba_info_ptr->retx_arr [current_mpdu]->time_rcvd <= bar_info_ptr->time_rcvd)
			{
			/* MPDU completed its transmission lifetime. Record its		*/
			/* sequence number like it is ACKed if it is the new		*/
			/* highest one.												*/
			
			//Loren: Function does not get called from here in normal operation.
			op_pk_fd_access_read_only_ptr (ba_info_ptr->retx_arr [current_mpdu]->pkptr, WLANC_DATA_HEADER_FD, (const void **) &mpdu_fields_ptr);
			if (SEQ_A_GREATER_THAN_SEQ_B ((mpdu_fields_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE), ba_info_ptr->max_acked_seq_num, ba_info_ptr->block_size))
				ba_info_ptr->max_acked_seq_num = mpdu_fields_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE;
			
			/* Decrease the buffer usage by higher layer data.			*/
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size before decrement #5 = %d\n",(int)total_hlpk_size);
			}
			total_hlpk_size -= ba_info_ptr->retx_arr [current_mpdu]->size;
			if(LorenDebugFlag)
			{
				printf("total_hlpk_size after decrement #5 = %d\n", (int)total_hlpk_size);
			}
			
			/* Update the dropped data statistics.						*/
			discard_pksize = (double) ba_info_ptr->retx_arr [current_mpdu]->size;
			op_stat_write (retx_drop_pkts_handle,               1.0);
			op_stat_write (retx_drop_pkts_handle,               0.0);
			op_stat_write (retx_drop_bits_handle,               discard_pksize);
			op_stat_write (retx_drop_bits_handle,               0.0);
			
			my_droppedR_sum += discard_pksize;
			//my_droppedR = discard_pksize/(op_sim_time()-last_my_droppedR_calculated_time);
			//last_my_droppedR_calculated_time = op_sim_time();
			
			op_stat_write (global_retx_drop_handle,             discard_pksize);
			op_stat_write (global_retx_drop_handle,             0.0);
			op_stat_write (ac_dropped_retx_pkts_shndl_arr [ac], 1.0);
			op_stat_write (ac_dropped_retx_pkts_shndl_arr [ac], 0.0);
			op_stat_write (ac_dropped_retx_bits_shndl_arr [ac], discard_pksize);
			op_stat_write (ac_dropped_retx_bits_shndl_arr [ac], 0.0);
			op_stat_write (ac_gb_dropped_retx_shndl_arr [ac],   discard_pksize);
			op_stat_write (ac_gb_dropped_retx_shndl_arr [ac],   0.0);
			
			/* Destroy the MPDU.										*/
			op_pk_destroy (ba_info_ptr->retx_arr [current_mpdu]->pkptr);
			op_prg_mem_free (ba_info_ptr->retx_arr [current_mpdu]);
			}
			
		else
			{
			/* All the remaining MPDUs are newer than BAR. Move them to	*/
			/* the head of the queue.									*/
			do
				{
				ba_info_ptr->retx_arr [new_mpdu_count] = ba_info_ptr->retx_arr [current_mpdu];
				new_mpdu_count++;
				current_mpdu++;
				} while (current_mpdu < ba_info_ptr->mpdu_count);
			}
		}
	
	/* Set the number of remaining MPDUs.								*/
	ba_info_ptr->mpdu_count = new_mpdu_count;
	
	/* Check the overall status.										*/
	if (ba_info_ptr->mpdu_count == 0)
		{
		/* All the pending MPDUs are discarded. Set the new starting	*/
		/* sequence number as the next of the last discarded MPDU.		*/
		ba_info_ptr->starting_seq_num = (ba_info_ptr->max_acked_seq_num + 1) % WLANC_SEQ_NUM_WRAP_VALUE;
		}
	else
		{
		/* The retransmission buffer is not empty. New starting			*/
		/* sequence number is the sequence number of the first MPDU in	*/
		/* the buffer.													*/

		//Loren: Function does not get called from here in normal operation.
		op_pk_fd_access_read_only_ptr (ba_info_ptr->retx_arr [0]->pkptr, WLANC_DATA_HEADER_FD, (const void **) &mpdu_fields_ptr);
		ba_info_ptr->starting_seq_num = mpdu_fields_ptr->sequence_control >> WLANC_FRAG_NUM_SIZE;		
		}
	
	/* Write an ODB message if enabled.									*/
	if (wlan_trace_active)
		{				
		sprintf (msg_string1, "Discarding BAR intended for STA "OPC_INT64_FMT" and TID %d due to reaching transmit lifetime limit.", ba_info_ptr->peer_addr, ba_info_ptr->tid);
		sprintf (msg_string2, "New BA starting sequence number = %d.", ba_info_ptr->starting_seq_num);
		op_prg_odb_print_major (msg_string1, msg_string2, OPC_NIL);
		}

	FOUT;
	}

static void
wlan_hcf_mac_rcv_channel_status_update (int channel_id)
	{
	/** This function updates the receiver_busy flag based	**/
	/** on the the current value of the receiver's received	**/
	/** power statistic and reception end time state		**/
	/** information.										**/				
	FIN (wlan_hcf_mac_rcv_channel_status_update (int channel_id));
	
	/* Read the current value of the received power at the	*/
	/* receiver.											*/
	if (op_stat_local_read (channel_id) > rx_power_threshold)
		{
		/* This is the start of the reception of a new		*/
		/* packet. 											*/
		
		/* Set the receiver status as busy.					*/
		if (!wlan_flags->receiver_busy)
			{
			wlan_flags->receiver_busy = OPC_TRUE;
			
			/* Cancel the NAV reset interrupt, if any,		*/
			/* since we started receiving a packet.			*/
			if (op_ev_valid (nav_reset_evh))
				op_ev_cancel (nav_reset_evh);
			
			/* Set the flag that we are expecting a packet	*/
			/* from the physical layer, good or bad.		*/
			wlan_flags->phy_pkt_expected = OPC_TRUE;			
			}
		}
	
	/* Else a packet reception is complete. Check whether	*/
	/* the receiver became available while it was busy. It	*/
	/* may not have been busy if we were receiving a noise	*/
	/* packet with a weak signal.							*/
	else if (wlan_flags->receiver_busy)
		{
		/* Compare the receiver's reception end time value	*/
		/* with the current time to determine its status.	*/
		if (rx_state_info_ptr->rx_end_time - PRECISION_RECOVERY <= current_time)
			{		
			wlan_flags->receiver_busy = OPC_FALSE;
			}
		
		/* Update the receiver idle time with current time.	*/
		/* Even though the receiver can be still busy (in	*/
		/* case of a collision), this is necessary to note	*/
		/* the completion time of the last reception.		*/
		rcv_idle_time = current_time;
		}
	
	FOUT;
	}

static void
wlan_hcf_sta_addr_register (int bssid, OpT_Int64 sta_addr, int sta_is_ap, Objid sta_mac_objid, WlanT_Phy_Char_Code phy_char)
	{
	PrgT_Mapping_Handle 	wlan_bss_mapping_hndl;
	WlanT_Bss_Mapping_Info*	bss_info_ptr;
	Boolean					beacon_intrpt_scheduled = OPC_FALSE;
	char*					reduced_subnet_hname;
	char					stat_info [32];
	char					subnet_name [128];

	/** Add the station information to the BSS-based station map.			**/
	FIN (wlan_hcf_sta_addr_register (bssid, sta_addr, sta_is_ap, sta_mac_objid, phy_char));

	/* Get the BSS mapping handle (owned by called function as a static		*/
	/* variable).															*/
	wlan_bss_mapping_hndl = wlan_bss_mapping_get ();

	/* Check if this is the first station being mapping into this BSS.		*/
	bss_info_ptr = (WlanT_Bss_Mapping_Info *) prg_mapping_value_get (wlan_bss_mapping_hndl, &bssid);
	if (bss_info_ptr == PRGC_NIL)
		{
		/* Create the bss information record and store it in the BSS		*/
		/* mapping.															*/
		bss_info_ptr = (WlanT_Bss_Mapping_Info *) op_prg_mem_alloc (sizeof (WlanT_Bss_Mapping_Info));
		bss_info_ptr->bss_idx          	   = bssid;
		bss_info_ptr->non_erp_sta_count    = 0;
		bss_info_ptr->nqsta_count		   = 0;
		bss_info_ptr->ap_objid 			   = OPC_OBJID_INVALID;
		bss_info_ptr->ap_dist_edca_params  = OPC_FALSE;
		bss_info_ptr->is_nqbss			   = OPC_TRUE;
		bss_info_ptr->ap_block_ack_support = OPC_FALSE;
		prg_mapping_value_add (wlan_bss_mapping_hndl, bss_info_ptr);

		/* Annotate the global network load statistic, which is collected	*/
		/* separately for each BSS, here, so that we prevent redundant		*/
		/* repetition of the same	task by the other members of the BSS.	*/
		/* If the BSS IDs are auto-assigned then use the name of the subnet	*/
		/* as the annotation, otherwise use the BSS ID.						*/
		if (bss_id_type == WlanC_Entire_Subnet)
			{
			/* Get the name of the subnet, where the nodes of the BSS		*/
			/* reside.														*/
			op_ima_obj_attr_get_str (my_subnet_objid, "name", 128, subnet_name);
			
			/* If the subnet name is not unique, then use the hierarchical	*/
			/* name.														*/
			if (oms_tan_is_subnet_name_unique (subnet_name) == OPC_FALSE)
				{
				op_ima_obj_hname_get (my_subnet_objid, subnet_name, 128);
				
				/* Skip the "top." prefix of the hierarchical name.			*/
				reduced_subnet_hname = &(subnet_name [4]);
				
				/* Use the reduced name for annotation.						*/
				Oms_Dim_Stat_Annotate (global_network_load_handle, reduced_subnet_hname);
				}
			else
				Oms_Dim_Stat_Annotate (global_network_load_handle, subnet_name);				
			}
		else
			{
			sprintf (stat_info, "BSS %d", bssid);
			Oms_Dim_Stat_Annotate (global_network_load_handle, stat_info);
			}
		}

	/* Save the MAC address and module object ID of the AP for the given	*/
	/* BSS. Since the AP of the BSS is an QSTA (i.e., QAP), the BSS becomes	*/
	/* a QBSS.																*/
	if (sta_is_ap == OPC_BOOLINT_ENABLED)
		{
		bss_info_ptr->ap_sta_addr 		   = sta_addr;
		bss_info_ptr->ap_objid    		   = sta_mac_objid;
		bss_info_ptr->ap_phy_char 		   = phy_char;
		bss_info_ptr->ap_dist_edca_params  = (bss_edca_params_arr != OPC_NIL) ? OPC_TRUE : OPC_FALSE;
		bss_info_ptr->ap_prhndl			   = op_pro_self ();
		bss_info_ptr->is_nqbss			   = OPC_FALSE;
		bss_info_ptr->ap_block_ack_support = wlan_flags->ba_support;
		}

	/* Increment the count of 802.11/11b running STAs in the BSS if we are	*/
	/* one of them.															*/
	if (phy_type == WlanC_11b_PHY)
		{
		bss_info_ptr->non_erp_sta_count++;
	
		/* If this is not the association performed at initialization and	*/
		/* if we are the first non-ERP STA in the BSS and if the beacon		*/
		/* efficiency mode is enabled, then send a remote interrupt to the	*/
		/* AP of the BSS, so that it can inform the other STAs in the BSS	*/
		/* about the existence of a non-ERP STA in the LAN by sending		*/
		/* certain number of beacons.										*/
		if (bss_info_ptr->non_erp_sta_count == 1 && BEACON_TX_EFFICIENCY_ENABLED && current_time > 0.0)
			{
			op_intrpt_schedule_remote (current_time, WlanC_Beacon_Tx_Time, bss_info_ptr->ap_objid);
			beacon_intrpt_scheduled = OPC_TRUE;
			}
		}
	
	/* If a) we have a new AP, b) it is a QAP, c) it is advertizing EDCA	*/
	/* parameters to its BSS, and d) the beacon efficiency is enabled, then	*/
	/* send a remote interrupt to the AP so that it transmits specified 	*/
	/* number of beacons with EDCA Parameter Set for us to update our own	*/
	/* EDCA set, unless we have	already scheduled an interrupt above.		*/
	if (current_time > 0.0           && bss_info_ptr->ap_dist_edca_params == OPC_TRUE &&
		BEACON_TX_EFFICIENCY_ENABLED && beacon_intrpt_scheduled == OPC_FALSE            )
		{
		op_intrpt_schedule_remote (current_time, WlanC_Beacon_Tx_Time, bss_info_ptr->ap_objid);
		}
	
	FOUT;
	}

static void
wlan_hcf_sta_addr_deregister (int bssid, OpT_Int64 sta_addr)
	{
	PrgT_Mapping_Handle		wlan_bss_mapping_hndl;
	WlanT_Bss_Mapping_Info*	bss_info_ptr;
	
	/** This function removes the given STA address from the STA list of	**/
	/** the given BSS.														**/
	FIN (wlan_hcf_sta_addr_deregister (bssid, sta_addr));

	/* Get a handle to the mapping between BSS ID and BSS information.		*/
	wlan_bss_mapping_hndl = wlan_bss_mapping_get ();

	/* Access the BSS information.											*/
	bss_info_ptr = (WlanT_Bss_Mapping_Info *) prg_mapping_value_get (wlan_bss_mapping_hndl, &bssid);

	/* Decrement the count of 802.11/11b running STAs in the BSS if we were	*/
	/* one of them.															*/
	if (phy_type == WlanC_11b_PHY)
		{
		bss_info_ptr->non_erp_sta_count--;
		
		/* If we were the last non-ERP STA left in the BSS and if the		*/
		/* beacon efficiency mode is enabled, then send a remote interrupt	*/
		/* to the AP of the BSS, so that it can inform the other STAs in	*/
		/* the BSS about the departure of all non-ERP STAs from the LAN by	*/
		/* sending specified number of beacons.								*/
		if (bss_info_ptr->non_erp_sta_count == 0 && BEACON_TX_EFFICIENCY_ENABLED)
			{
			op_intrpt_schedule_remote (current_time, WlanC_Beacon_Tx_Time, bss_info_ptr->ap_objid);
			}
		}
	
	/* Inform the AP about our deassociation so that it can update its		*/
	/* tables.																*/
	op_intrpt_schedule_process (bss_info_ptr->ap_prhndl, current_time, 
		((int) sta_addr << WLANC_ADDRESS_BIT_SHIFT) + WLANC_QOS_SUPPORT_BIT + ((phy_char_flag == WlanC_ERP_OFDM_11g) ? WLANC_ERP_SUPPORT_BIT : 0));

	FOUT;
	}

static void
wlan_hcf_begin_new_scan (void)
	{
	/** This function switches the node's communication channel to a new	**/
	/** one at least for a short period in order to evaluate the AP of this	**/
	/** channel, if any, for possible connection.							**/
	FIN (wlan_hcf_begin_new_scan (void));
	
	/* Set the AP Connectivity stat to -1 if we lost connectivity with		*/
	/* previous AP and just started the scanning procedure.					*/
	if (!(intrpt_type == OPC_INTRPT_SELF && intrpt_code == WlanC_Scan_Timeout))
		op_stat_write (ap_conn_handle, WLANC_AP_UNCONNECTED); 
	
	/* Pick new channel so that it is five channels away-- the next 		*/
	/* non-overlapping channel (we first subtract one and then add one		*/
	/* because channel numbers start with 1 not 0).							*/
	channel_num = (channel_num - 1 + WLANC_CH_STEP_FOR_NO_OVERLAP) % channel_count + 1;
	
	/* If we are going to evaluate the new channel by listening to the		*/
	/* Beacons of its AP, configure our transceivers accordingly.			*/
	if (roam_state_ptr->scan_type == WlanC_Scan_Type_Beacon)
		{
		/* Set the transmitter and receiver to this channel.				*/
		wlan_set_transceiver_channel (channel_num, phy_type, txch_objid, rxch_objid);

		/* Initialize the BSS ID and reliability of the AP in this new		*/
		/* channel.															*/
		roam_state_ptr->ap_reliability = WLANC_AP_RELIABILITY_UNKNOWN;
		eval_bss_id = WLANC_BSS_ID_UNKNOWN;
		}
		
	/* Set a timer for slightly over two beacon periods, which will			*/
	/* indicate the end of the evaluation period of the new channel.		*/
	op_intrpt_schedule_self (current_time + beacon_int * WLANC_NEW_SCAN_BEACON_MULT, WlanC_Scan_Timeout);
	
	FOUT;
	}

static void
wlan_hcf_ap_switch (void)
	{
	int							queue_index, i, j;
	int							queue_size;
	int							old_phy_cw_min;
	int							new_mmpdu_count = 0;
	int							ac_queue_check_status = 0;
	Boolean						my_block_ack, done = OPC_FALSE;
	WlanT_HCF_Access_Category	ac;
	List*						temp_lptr;
	WlanT_HCF_Hld_Info*			hld_ptr;
	const IpT_Dgram_Fields*		ip_header_fields_ptr;
	WlanT_HCF_BA_State*			ap_tid_ba_info_ptr;
	char						pk_format_name [64];
	char						stat_info [16];
	
	/** The function performs switching from old BSS/AP to new BSS/AP.		**/
	FIN (wlan_hcf_ap_switch (void));

	/* First lock the mutex that manages accessing the global mapping		*/
	/* information between the APs and stations, since we will be updating	*/
	/* this information.													*/
	op_prg_mt_mutex_lock (mapping_info_mutex, OPC_MT_MUTEX_LOCK_WRITER);
	
	/* Remove this STA from the STA list of the old BSS.					*/
	wlan_hcf_sta_addr_deregister (bss_id, my_address);

	/* Update own BSS ID information.										*/
	bss_id = eval_bss_id;
	my_bss_info_ptr = wlan_bss_info_get (bss_id);
	
	/* Also update roaming state for later comparison while evaluating APs.	*/
	roam_state_ptr->current_bss_id = bss_id;
	
	/* Find out the MAC address of our new AP.								*/
	ap_mac_address     = wlan_get_ap_sta_addr (bss_id);

	/* Reset the peer information we maintain for the AP we are connected.	*/
	ap_peer_info_ptr->is_qsta  = (my_bss_info_ptr->is_nqbss == OPC_TRUE) ? OPC_FALSE : OPC_TRUE;
	ap_peer_info_ptr->seq_cntl =  0xFFFF;
	
	/* Check whether the new AP supports block ACKs, if we also do so.		*/
	ap_peer_info_ptr->ba_support = (wlan_flags->ba_support && my_bss_info_ptr->ap_block_ack_support) ? OPC_TRUE : OPC_FALSE;

	/* If any, flush block ACK state information with the old QAP.			*/
	if (ap_peer_info_ptr->ba_state_ptr_arr != OPC_NIL)
		{
		/* Go over BA state of each traffic class.							*/
		for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
			{
			if (ap_peer_info_ptr->ba_state_ptr_arr [i] != OPC_NIL)
				{
				/* We have active block-ACK agreement(s) with the old QAP.	*/
				/* Flush old the block-ACK information kept for this TC;	*/
				/* but first record whether we initiated an agreement,		*/
				/* which is an information we need later.					*/
				my_block_ack = (ap_peer_info_ptr->ba_state_ptr_arr [i]->status == WlanC_BA_Established) ? OPC_TRUE : OPC_FALSE;
				
				/* Destroy all the block-ACK state information in either	*/
				/* direction.												*/
				wlan_hcf_peer_tid_ba_info_flush (ap_peer_info_ptr->ba_state_ptr_arr [i], Wlanc_BA_Bidirectional);
				ap_peer_info_ptr->ba_state_ptr_arr [i] = OPC_NIL;
				
				/* Unless we have already done it for the previous TC using	*/
				/* the same AC, remove any block-ACK related packets (BARs	*/
				/* or block MPDU retransmissions) from AC's	transmission	*/
				/* queue, which have to be at the head of the queue with	*/
				/* the exception that the first two entry can be for		*/
				/* regular MSDUs.											*/
				ac = WLANC_UP_TO_AC_MAPPING_ARRAY [i];
				if (!(ac_queue_check_status & WLANC_AC_BITMAP_ARRAY [ac]) && op_prg_list_size (hlpk_lptr_arr [ac]) > 0)
					{
					queue_size = op_prg_list_size (hlpk_lptr_arr [ac]);
					j = 0;
					do
						{
						/* Check the current entry.							*/
						hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [ac], j);
						if (!(hld_ptr->type & WLANC_DATA_TYPE_BIT) || hld_ptr->ba_retx == OPC_TRUE)
							{
							/* This is either a BA control/management frame	*/
							/* or retransmission copy of a block MPDU.		*/
							/* Remove it from the buffer.					*/
							wlan_hcf_frame_remove (ac, j);
							queue_size--;
							}
						else
							{
							/* This is an MSDU entry. Change the ACK policy	*/
							/* if necessary.								*/
							if (hld_ptr->ack_policy == WlanC_Block_ACK)
								hld_ptr->ack_policy = WlanC_Normal_ACK;

							/* Exit the loop if all the remaining ones have	*/
							/* to be MSDU entries.							*/
							if (j == 2)
								done = OPC_TRUE;
							j++;
							}
						} while (j < queue_size && done == OPC_FALSE);
										
					/* If there are still packets queued for this TC and if	*/
					/* the new AP is also a QAP (otherwise this change will	*/
					/* be later in this function anyway) change the ACK		*/
					/* policy of the queued messages from block ACK to		*/
					/* normal ACK.											*/
					if (my_block_ack == OPC_TRUE && my_bss_info_ptr->is_nqbss == OPC_FALSE)
						{
						for (; j < queue_size; j++)
							{
							hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [ac], j);
							if (hld_ptr->ack_policy == WlanC_Block_ACK)
								hld_ptr->ack_policy = WlanC_Normal_ACK;
							}
						}
					
					/* If the AC's queue is emptied to due possible			*/
					/* removals above, update the ac queue status info.		*/
					if (queue_size == 0)
						{
						for (j = 0; ac_queue_status_arr [j] != ac; j++);
						do
							{
							ac_queue_status_arr [j] = ac_queue_status_arr [j + 1];
							j++;
							} while (ac_queue_status_arr [j] != WlanC_AC_None);
						}
					}
				
				/* Set that the queue of the AC of the current TC is		*/
				/* checked.													*/
				ac_queue_check_status |= WLANC_AC_BITMAP_ARRAY [ac];
				}
			}
		
		/* Also free the array if the new AP doesn't support block-ACKs.	*/
		if (ap_peer_info_ptr->ba_support == OPC_FALSE)
			{
			op_prg_mem_free (ap_peer_info_ptr->ba_state_ptr_arr);
			ap_peer_info_ptr->ba_state_ptr_arr = OPC_NIL;
			}
		}
	
	/* Add ourselves to the STA list of our new BSS.						*/
	wlan_hcf_sta_addr_register (bss_id, my_address, OPC_BOOLINT_DISABLED, OPC_OBJID_INVALID, phy_char_flag);
	
	/* Update our handle for the network load statistic, which is			*/
	/* dimensioned with respect to BSSs, since we belong to a new BSS now.	*/
	sprintf (stat_info, "%d", bss_id);
	global_network_load_handle = Oms_Dim_Stat_Reg (my_objid, "Wireless LAN", "Network Load (bits/sec)", stat_info, OPC_STAT_GLOBAL);
	
	/* Check whether the new AP support Extended Rate PHY (11g).			*/
	ap_peer_info_ptr->is_erp = (my_bss_info_ptr->ap_phy_char == WlanC_ERP_OFDM_11g) ? OPC_TRUE : OPC_FALSE;
	
	/* If we are an ERP-STA, then check whether there are any non-ERP STAs	*/
	/* in our new BSS.														*/
	if (phy_type == WlanC_11g_PHY)
		{
		/* Pick the value of the CWmin parameter based on whether the new	*/
		/* AP supports ERP (802.11g) operation and data rates. We may need	*/
		/* to adjust also our data transmission rate if the new AP doesn't	*/
		/* support 11g data rates.											*/	
		old_phy_cw_min = phy_cw_min;
		if (ap_peer_info_ptr->is_erp == OPC_TRUE)
			{
			/* The new AP also operates in 11g mode.						*/
			phy_cw_min = 15;
			operational_speed = data_tx_rate;
			}
		else
			{
			/* The new AP doesn't support 11g operation. Set the CWmin to	*/
			/* 31 and lower the transmission rate to an 11b data rate.		*/ 
			phy_cw_min = 31;
			if (data_tx_rate >= 11000000.0)
				operational_speed = 11000000.0;
			else if (data_tx_rate > 5500000.0)
				operational_speed = 5500000.0;
			}

		/* In case we have a new a PHY CWmin value, adjust the actual CWmin	*/
		/* and/or CWmax values used by each access category, if any of them	*/
		/* is derived from the PHY CWmin value.								*/
		if (phy_cw_min != old_phy_cw_min && (wlan_ac_flags->std_cwmin || wlan_ac_flags->std_cwmax))
			wlan_hcf_cw_values_adjust ();

		/* Compare the value of our non_erp_present flag with the situation	*/
		/* in our new BSS.													*/
		if (wlan_flags->non_erp_present == OPC_FALSE && my_bss_info_ptr->non_erp_sta_count > 0)
			{
			/* We have non-ERP STA(s) in our new BSS. Set the flag.			*/
			wlan_flags->non_erp_present = OPC_TRUE;
			
			/* Increase the slot time to 20 usec and recompute the			*/
			/* dependent parameters.										*/
			wlan_hcf_slot_time_set (20E-06);
			
			/* Reduce the control frame data rate to 802.11/11b mandatory	*/
			/* data rate.													*/
			control_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
			}
		
		else if (wlan_flags->non_erp_present == OPC_TRUE && my_bss_info_ptr->non_erp_sta_count == 0)
			{
			/* The new BSS doesn't have any non-ERP STA. Reset the flag.	*/
			wlan_flags->non_erp_present = OPC_FALSE;
			
			/* Decrease the slot time to 9 usec and recompute the dependent	*/
			/* parameters.													*/
			wlan_hcf_slot_time_set (9E-06);
			
			/* Reselect the control frame data rate. Choose the highest		*/
			/* mandatory data rate that is equal to or lower than the data	*/
			/* rate specified for data transmissions.						*/
			for (i = 0; data_tx_rate < WLANC_11g_MANDATORY_DRATE_ARRAY [i]; i++);
			control_data_rate = WLANC_11g_MANDATORY_DRATE_ARRAY [i];
			}		
		}
	
	/* Unlock the mutex that we locked at the beginning.					*/
	op_prg_mt_mutex_unlock (mapping_info_mutex);

	/* Inform the AP about our association with the BSS so that it can 		*/
	/* update its own tables.												*/
	op_intrpt_schedule_process (my_bss_info_ptr->ap_prhndl, current_time, (
		(int) my_address << WLANC_ADDRESS_BIT_SHIFT) | WLANC_ASSOCIATION_BIT | WLANC_QOS_SUPPORT_BIT |
		((phy_char_flag == WlanC_ERP_OFDM_11g) ? WLANC_ERP_SUPPORT_BIT : 0x0) |
		((wlan_flags->ba_support == OPC_TRUE)  ? WLANC_BA_SUPPORT_BIT  : 0x0));
	
	/* Check whether we have moved from a QBSS to an nQBSS.					*/
	if (wlan_flags->nqsta_operation == OPC_FALSE && my_bss_info_ptr->is_nqbss == OPC_TRUE)
		{
		/* Since we have moved from a QBSS to an nQBSS, we need to operate	*/
		/* as an nQSTA.														*/
		wlan_flags->nqsta_operation = OPC_TRUE;
		
		/* Since we won't be sending QoS data frames any more, there is no	*/
		/* need to maintain the frame sequence numbers separately for each	*/
		/* TID.																*/
		op_prg_mem_free (ap_peer_info_ptr->tid_seq_counter_arr);
		op_prg_mem_free (ap_peer_info_ptr->tid_rcvd_seq_cntl_arr);
		
		/* We will start using the "best effort" AC to buffer the higher	*/
		/* layer packets with DCF access parameters.						*/
		cwmin_arr [WlanC_AC_BE] = phy_cw_min;
		cwmax_arr [WlanC_AC_BE] = phy_cw_max;
		txop_limit_arr [WlanC_AC_BE] = 0.0;
							
		/* AIFS becomes DIFS, hence AIFSN becomes two slots.				*/
		aifsn_arr [WlanC_AC_BE] = 2;
		aifs_arr [WlanC_AC_BE]  = difs_time;
		
		/* Make sure that all the packets in AC queues are collected within	*/
		/* the queue of the best effort AC. Case 1: all the AC queues are	*/
		/* empty, then no operation is needed.								*/
		
		/* Case 2: there is only one AC with non-empty queue and it is the	*/
		/* best effort AC.													*/
		if (ac_queue_status_arr [0] == WlanC_AC_BE && ac_queue_status_arr [1] == WlanC_AC_None)
			{
			/* Access the record of each higher layer packet and change its	*/
			/* type from QoS_Data to Data, and its ACK policy to normal		*/
			/* ACK (except for broadcast frames), which may be set to a		*/
			/* different policy like No ACK or Block ACK.					*/
			for (i = op_prg_list_size (hlpk_lptr_arr [WlanC_AC_BE]) - 1; i >= 0; i--)
				{
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_BE], i);
				hld_ptr->type = WlanC_Data;
				if (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
					hld_ptr->ack_policy = WlanC_Normal_ACK;
				}
			}
		
		/* Case 3: there is only one AC with non-empty queue and it is not	*/
		/* the best effort AC.												*/
		else if (ac_queue_status_arr [0] != WlanC_AC_None && ac_queue_status_arr [0] != WlanC_AC_BE && 
			     ac_queue_status_arr [1] == WlanC_AC_None												)
			{
			/* Make the queue of the AC with non-empty queue the queue of	*/
			/* the best effort AC.											*/
			temp_lptr                               = hlpk_lptr_arr [WlanC_AC_BE];
			hlpk_lptr_arr [WlanC_AC_BE]             = hlpk_lptr_arr [ac_queue_status_arr [0]];
			hlpk_lptr_arr [ac_queue_status_arr [0]] = temp_lptr;
			
			/* Access the record of each higher layer packet and change its	*/
			/* type from QoS_Data to Data, and its ACK policy to normal ACK	*/
			/* unless it is a broadcast frame.								*/
			for (i = op_prg_list_size (hlpk_lptr_arr [WlanC_AC_BE]) - 1; i >= 0; i--)
				{
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_BE], i);
				hld_ptr->type = WlanC_Data;
				if (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
					hld_ptr->ack_policy = WlanC_Normal_ACK;
				}
			
			/* If necessary register the outgoing traffic statistics for	*/
			/* the best effort AC.											*/
			if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BE]))
				wlan_hcf_ac_statistics_register (WlanC_AC_BE, OPC_TRUE);
			
			/* Update the queue size statistics.							*/
			op_stat_write (ac_queue_size_shndl_arr [ac_queue_status_arr [0]], 0.0);
			op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_BE],             (double) op_prg_list_size (hlpk_lptr_arr [WlanC_AC_BE]));
			
			/* Finally update the AC queue status array.					*/
			ac_queue_status_arr [0] = WlanC_AC_BE;
			}
		
		/* Case 4: there are at least two ACs with non-empty queues.		*/
		else if (ac_queue_status_arr [1] != WlanC_AC_None)
			{
			/* If there are already some entries in the queue of the best	*/
			/* effort AC, change their types from QoS_Data to Data, and		*/
			/* their ACK policies to normal ACK unless they are broadcast.	*/
			for (i = op_prg_list_size (hlpk_lptr_arr [WlanC_AC_BE]) - 1; i >= 0; i--)
				{
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_BE], i);
				hld_ptr->type = WlanC_Data;
				if (hld_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
					hld_ptr->ack_policy = WlanC_Normal_ACK;
				}
			
			/* Merge all the non-empty AC queues into a single queue under	*/
			/* the best effort AC.											*/
			for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
				{
				if (ac_queue_status_arr [i] != WlanC_AC_BE)
					wlan_hcf_ac_queues_merge (ac_queue_status_arr [i], WlanC_AC_BE);
				}
			
			/* If necessary register the outgoing traffic statistics for	*/
			/* the best effort AC.											*/
			if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BE]))
				wlan_hcf_ac_statistics_register (WlanC_AC_BE, OPC_TRUE);
			
			/* Update the queue size statistics and the AC queue status		*/
			/* array.														*/
			for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
				{
				op_stat_write (ac_queue_size_shndl_arr [ac_queue_status_arr [i]], (double)
							   (ac_queue_status_arr [i] == WlanC_AC_BE ? op_prg_list_size (hlpk_lptr_arr [WlanC_AC_BE]) : 0));
				ac_queue_status_arr [i] = WlanC_AC_None;
				}
			ac_queue_status_arr [0] = WlanC_AC_BE;
			}		
		}
	
	/* Or did we move back from an nQBSS to a QBSS?							*/
	else if (wlan_flags->nqsta_operation == OPC_TRUE && my_bss_info_ptr->is_nqbss == OPC_FALSE)
		{
		/* We will resume with QSTA operation in the new QBSS.				*/
		wlan_flags->nqsta_operation = OPC_FALSE;
		
		/* Since we will be sending QoS data frames to the new AP, we need	*/
		/* to maintain the frame sequence numbers separately for each TID.	*/
		ap_peer_info_ptr->tid_seq_counter_arr   = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
		ap_peer_info_ptr->tid_rcvd_seq_cntl_arr = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
		for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
			{
			ap_peer_info_ptr->tid_seq_counter_arr [i] = 0;
			ap_peer_info_ptr->tid_rcvd_seq_cntl_arr [i] = 0xFFFF;
			}
		
		/* Restore the contention parameters for the best effort AC, which	*/
		/* were altered for DCF operation while being in nQBSS, unless we	*/
		/* have already set all of our EDCA parameters using the new QAPs	*/
		/* advertisement in its beacons.									*/
		if (wlan_flags->edca_params_updated == OPC_FALSE)
			wlan_hcf_edca_ac_parameter_set_read (op_topo_child (own_ac_edca_params_objid, OPC_OBJTYPE_GENERIC, 0), WlanC_AC_BE);
		
		/* Distribute all the higher layer packets, which are currently		*/
		/* collected in the queue of the best effort AC for DCF operation,	*/
		/* to the queues of their corresponding AC.	Exclude the MMPDUs		*/
		/* created during this process from total packet count.				*/
		for (i = 0, queue_index = 0; i < total_hlpk_num - new_mmpdu_count; i++)
			{
			/* Access the record of the current MSDU/MMPDU.					*/
			hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_BE], queue_index);
			
			/* Obtain the UP of the packet.	If it is not an IP datagram		*/
			/* then we will use the UP information that was already set in	*/
			/* the packet's information record.								*/
			op_pk_format (hld_ptr->pkptr, pk_format_name);
			if (strcmp (pk_format_name, "ip_dgram_v4") == 0)
				{
				/* Obtain the UP information from the ToS field of the IP	*/
				/* header. Shift the number to right by 5 bits to skip the	*/
				/* DSCP	bits.												*/
				op_pk_nfd_access_read_only_ptr (hld_ptr->pkptr, "fields", (const void**) &ip_header_fields_ptr);
				hld_ptr->up = (OpT_uInt8) (ip_header_fields_ptr->tos >> 5);
				}
			
			/* Make sure we have a valid user priority value.				*/
			if (hld_ptr->up > MAX_UP_VALUE)
				wlan_error_print ("Incorrect UP (user priority) value associated with the higher layer packet.", "", "");

			/* Determine the AC corresponding to the packet's UP.			*/
			ac = WLANC_UP_TO_AC_MAPPING_ARRAY [hld_ptr->up];
			
			/* Change the type to QoS_Data to use the correct frame type	*/
			/* during transmission.											*/
			hld_ptr->type = WlanC_QoS_Data;
			
			/* Now we can support the QoS acknowledgement policy configured	*/
			/* for the AC. Check the ACK policy for packet's UP. If it is	*/
			/* block ACK then we need to try to establish a block ACK		*/
			/* agreement with our new AP for that UP.						*/
			if (tc_config_arr [hld_ptr->up].ack_policy != WlanC_Block_ACK)
				hld_ptr->ack_policy = tc_config_arr [hld_ptr->up].ack_policy;
	
			else
				{
				/* Since we just connected to the new AP, we don't have any	*/
				/* BA agreements already established. Set the ACK policy to	*/
				/* normal ACK for time being.								*/
				hld_ptr->ack_policy = WlanC_Normal_ACK;
				
				/* Does the new AP supports block ACKs?						*/
				if (ap_peer_info_ptr->ba_support == OPC_TRUE)
					{
					/* Get our BA record with the AP for the packet's UP.	*/
					/* This function will create the record if it doesn't	*/
					/* exist.												*/
					ap_tid_ba_info_ptr = wlan_hcf_ba_state_info_get (ap_peer_info_ptr, ap_mac_address, hld_ptr->up);
					
					/* Send an ADDBA request to the AP for packet's TID,	*/
					/* unless we haven't already done it.					*/					
					if (ap_tid_ba_info_ptr->status == WlanC_BA_Uninitiated) 
						{
						/* Send a ADDBA frame to the peer to initiate the	*/
						/* packet exchange to establish a block ACK			*/
						/* agreement.										*/
						ap_tid_ba_info_ptr->status = WlanC_BA_Requested;
						wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_ADDBA_Request, hld_ptr->up, ap_mac_address, 
																   ap_peer_info_ptr->tid_seq_counter_arr [hld_ptr->up], OPC_TRUE);
						new_mmpdu_count++;
						}
					}
				}
			
			/* Move the MSDU/MMPDU to its AC's queue.						*/
			if (ac != WlanC_AC_BE)
				{
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [WlanC_AC_BE], queue_index);
				op_prg_list_insert (hlpk_lptr_arr [ac], hld_ptr, OPC_LISTPOS_TAIL);
				}
			else
				queue_index++;
			}
		
		/* Update the AC queue status array and queue size statistics		*/
		/* accordingly.														*/
		if (total_hlpk_num > 0)
			{
			/* Check the queue size of each access category.				*/
			for (i = WLANC_HCF_AC_COUNT - 1, j = 0; i >= 0; i--)
				{
				queue_size = op_prg_list_size (hlpk_lptr_arr [i]);
				if (queue_size > 0)
					{
					/* Add the AC to the list of active ACs.				*/
					ac_queue_status_arr [j] = (WlanT_HCF_Access_Category) i;
					j++;

					/* If necessary register the outgoing traffic			*/
					/* statistics for this AC.								*/
					if (!(wlan_ac_flags->stats_registered & WLANC_AC_BITMAP_ARRAY [i]))
						wlan_hcf_ac_statistics_register ((WlanT_HCF_Access_Category) i, OPC_TRUE);
					
					/* Update the AC queue size statistic.					*/
					op_stat_write (ac_queue_size_shndl_arr [i], (double) queue_size);
					}
				
				else if (i == WlanC_AC_BE)
					/* We have emptied the queue of the best effort AC.		*/
					op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_BE], 0.0);
				}
			}
		}
	
	else if (wlan_flags->nqsta_operation == OPC_FALSE)
		{
		/* If we reach this point then that means we moved from a QAP to	*/
		/* another QAP.														*/
		
		/* Reset the frame sequence numbers and counters maintained			*/
		/* separately for each TID.											*/
		for (i = 0; i < WLANC_HCF_TC_COUNT; i++)
			{
			ap_peer_info_ptr->tid_seq_counter_arr [i] = 0;
			ap_peer_info_ptr->tid_rcvd_seq_cntl_arr [i] = 0xFFFF;
			}

		/* If we can have block ACK agreements with the new QAP, and we if	*/
		/* we have packets already queued for a TC whose ACK policy is 		*/
		/* block ACK, then send ADDBA requests messages to the new AP for	*/
		/* those TCs.														*/
		if (ap_peer_info_ptr->ba_support == OPC_TRUE)
			{
			for (i = WLANC_HCF_TC_COUNT - 1; i >= 0; i--)
				{
				if (tc_config_arr [i].ack_policy == WlanC_Block_ACK && op_prg_list_size (hlpk_lptr_arr [WLANC_UP_TO_AC_MAPPING_ARRAY [i]]) > 0)
					{
					/* Check whether the queue of AC contains any packets	*/
					/* belonging to the current TC.							*/					
					ac = WLANC_UP_TO_AC_MAPPING_ARRAY [i];
					queue_size = op_prg_list_size (hlpk_lptr_arr [ac]);
					j = 0;
					do
						{
						hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [ac], j);
						if (hld_ptr->up == i && hld_ptr->ack_policy == WlanC_Normal_ACK)
							{
							/* Create the state record for the current TID.	*/
							ap_tid_ba_info_ptr = wlan_hcf_ba_state_info_get (ap_peer_info_ptr, ap_mac_address, (OpT_uInt8) i);

							/* Send the ADDBA request message.				*/
							ap_tid_ba_info_ptr->status = WlanC_BA_Requested;
							wlan_hcf_action_mmpdu_prepare_and_enqueue (WlanC_Category_Block_ACK, WlanC_Action_ADDBA_Request, i, ap_mac_address, 
																	   ap_peer_info_ptr->tid_seq_counter_arr [i], OPC_TRUE);
							
							/* Quit the loop since we don't need to check	*/
							/* other packets in the queue.					*/
							j = queue_size;
							}
						else
							j++;
						} while (j < queue_size);
					}
				}
			}
		}
	
	FOUT;
	}

static void
wlan_hcf_ac_queues_merge (WlanT_HCF_Access_Category src_ac, WlanT_HCF_Access_Category dst_ac)
	{
	int					src_index = 0;
	int					dst_index = 0;
	int					mrg_index = 0;
	int					src_size, dst_size;
	WlanT_HCF_Hld_Info*	dst_entry_ptr;
	WlanT_HCF_Hld_Info*	src_entry_ptr;
	List*				temp_lptr;
	
	/** This function moves the higher layer packets in the queue of the AC **/
	/** dst_ac into the queue of the AC src_ac. The packets in the src_ac's	**/
	/** queue remain sorted with respect to their arrival times after merge.**/
	FIN (wlan_hcf_ac_queues_merge (src_ac, dst_ac));
	
	/* Determine the size of each queue.									*/
	src_size = op_prg_list_size (hlpk_lptr_arr [src_ac]);
	dst_size = op_prg_list_size (hlpk_lptr_arr [dst_ac]);

	/* First cover the special case when the destination queue is empty.	*/
	if (dst_size == 0)
		{
		/* Swap the queues of both ACs.										*/
		temp_lptr              = hlpk_lptr_arr [dst_ac];
		hlpk_lptr_arr [dst_ac] = hlpk_lptr_arr [src_ac];
		hlpk_lptr_arr [src_ac] = temp_lptr;
	
		/* Change the type of the packets from QoS_Data to Data, and their	*/
		/* ACK policies to normal ACK, which may have been set to no ACK or	*/
		/* block ACK. If we are an AP or an STA in a ad hoc BSS, leave the	*/
		/* ACK policy of the broadcast frames as no ACK, since we won't		*/
		/* expect ACKs for those in any case.								*/
		for (dst_index = 0; dst_index < src_size; dst_index++)
			{
			dst_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_BE], dst_index);
			dst_entry_ptr->type = WlanC_Data;
			if (dst_entry_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
				dst_entry_ptr->ack_policy = WlanC_Normal_ACK;
			}
		
		/* Quit the function since we are done.								*/
		FOUT;
		}
	
	/* Remove the first entry from the source queue and access the first	*/
	/* entry of the destination queue. Meanwhile change the type and ACK	*/
	/* policy of the entry from the source queue.							*/
	dst_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [dst_ac], mrg_index);
	src_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [src_ac], OPC_LISTPOS_HEAD);	
	src_entry_ptr->type = WlanC_Data;
	if (src_entry_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
		src_entry_ptr->ack_policy = WlanC_Normal_ACK;
	
	/* Compare the arrival time of the entries of both queues and merge		*/
	/* them accordingly, until we reach the end of one of the queues.		*/
	while (OPC_TRUE)
		{
		if (dst_entry_ptr->time_rcvd <= src_entry_ptr->time_rcvd)
			{
			/* Destination queue entry is received earlier. Move to the		*/
			/* next one in the destination queue.							*/
			dst_index++;
			mrg_index++;
			if (dst_index < dst_size)
				dst_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [dst_ac], mrg_index);
			else
				break;
			}
		else
			{
			/* Source queue entry is received earlier. Insert it into the	*/
			/* current position of the destination queue and remove the		*/
			/* next entry from the source queue, if any, and change its		*/
			/* type and ACK policy, unless it is a broadcast frame.			*/
			op_prg_list_insert (hlpk_lptr_arr [dst_ac], src_entry_ptr, mrg_index);
			mrg_index++;
			src_index++;
			if (src_index < src_size)
				{
				src_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [src_ac], OPC_LISTPOS_HEAD);
				src_entry_ptr->type = WlanC_Data;
				if (src_entry_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
					src_entry_ptr->ack_policy = WlanC_Normal_ACK;
				}
			else
				break;
			}
		}
	
	/* If we have reached end of the destination queue first, insert the	*/
	/* entry from the source queue we were comparing in the destination		*/
	/* queue.																*/
	if (dst_index == dst_size)
		{
		op_prg_list_insert (hlpk_lptr_arr [dst_ac], src_entry_ptr, mrg_index);
		mrg_index++;
		src_index++;
		}
	
	/* If we have more entries in the source queue when we reached the end	*/
	/* of the destination queue, remove those entries and append them to	*/
	/* the destination queue. Change the type and ACK policy of entry for	*/
	/* nQSTA operation.														*/
	while (src_index < src_size)
		{
		src_entry_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [src_ac], OPC_LISTPOS_HEAD);
		src_entry_ptr->type = WlanC_Data;
		if (src_entry_ptr->dest_addr >= 0 || wlan_flags->ad_hoc_or_ap == OPC_FALSE)
			src_entry_ptr->ack_policy = WlanC_Normal_ACK;
		op_prg_list_insert (hlpk_lptr_arr [dst_ac], src_entry_ptr, OPC_LISTPOS_TAIL);
		src_index++;
		}
	
	FOUT;
	}

static void
wlan_hcf_sv_reset (void)
	{
	int					i, j;
	int					voice_ac_queue_size, initial_size;
	WlanT_HCF_Hld_Info*	hld_ptr;
	Packet*				mpdu_data_pkptr;
	
	/** This function is called when the STA joins a new BSS. The state of	**/
	/** the MAC must be reset to ensure that old state does not disrupt the	**/
	/** correct operation of the MAC protocol. 								**/
	FIN (wlan_hcf_sv_reset (void));

	/* Reset the applicable flags for contention in the new BSS.			*/ 
	wlan_flags->rts_sent		   	= OPC_FALSE;
	wlan_flags->rcvd_bad_packet		= OPC_FALSE;
	wlan_flags->bad_packet_dropped	= OPC_FALSE;
	wlan_flags->transmitter_busy	= OPC_FALSE;
	wlan_flags->wait_eifs_dur		= OPC_FALSE;
	wlan_flags->immediate_xmt		= OPC_FALSE;
	wlan_flags->forced_bk_end  	    = OPC_FALSE;
	wlan_flags->nav_updated			= OPC_FALSE;
	wlan_flags->rcvd_bad_cts		= OPC_FALSE;
	wlan_ac_flags->cw_required		= 0;

	/* Reset the AC specific parameters.									*/
	for (i = 0; i < WLANC_HCF_AC_COUNT; i++)
		{
		/* Cancel any backoff and reset the contention window size.			*/
		deference_info_arr [i].backoff_slots = BACKOFF_SLOTS_UNSET;

		/* If possible, recover the packets whose transmissions have failed	*/
		/* in the previous BSS. If recovery is not possible then discard	*/
		/* the higher layer packet. We can recover the ones that are not	*/
		/* actually transmitted, yet (i.e., whose RTS or CTS-to-self		*/
		/* transmission have failed), or the ones that are not fragmented.	*/
		if (src_arr [i] + lrc_arr [i] > 0)
			{
			/* Retrieve the information record of the higher layer packet.	*/
			hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [i], OPC_LISTPOS_HEAD);
				
			if (op_sar_buf_size (fragmentation_buffer_arr [i]) == hld_ptr->size)
				{
				/* The packet is actually not transmitted. Recover it from	*/
				/* the segmentation buffer.									*/
				mpdu_data_pkptr = op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [i], hld_ptr->size);
				op_sar_rsmbuf_seg_insert (common_rsmbuf_ptr, mpdu_data_pkptr);
				hld_ptr->pkptr = op_sar_rsmbuf_pk_remove (common_rsmbuf_ptr);
				}
			else if (op_sar_buf_size (fragmentation_buffer_arr [i]) == 0)
				{
				/* Segmentation buffer is empty. Is the retransmitted frame	*/
				/* an MPDU belonging to an MSDU/MMPDU, or a BAR or delayed	*/
				/* BA frame? For BAR/BA frames and block-MPDU				*/
				/* retransmissions, no action is needed since the 			*/
				/* retransmission copy is the entire frame and it can be	*/
				/* reused for new trials to save time (note: such frames	*/
				/* will be discarded below and in wlan_hcf_ap_switch() if	*/
				/* the new AP is different than the old AP, which is very	*/
				/* likely).													*/
				if (!(hld_ptr->type & WLANC_CONTROL_TYPE_BIT) && hld_ptr->ba_retx == OPC_FALSE)
					{
					/* Check whether the MPDU encapsulates the entire		*/
					/* MSDU/MMPDU.											*/
					op_pk_fd_get_pkt (mpdu_retx_copy_arr [i], WLANC_DATA_BODY_FD, &mpdu_data_pkptr);
					if (op_pk_total_size_get (mpdu_data_pkptr) == hld_ptr->size)
						{
						/* Recover the MSDU/MMPDU for delivery in the new	*/
						/* BSS.												*/
						hld_ptr->pkptr = mpdu_data_pkptr;
						}
					else
						{
						/* Discard the higher layer data since it is		*/
						/* fragmented and partially transmitted. Note that	*/
						/* this is a extremely rare case to happen.			*/
						op_pk_destroy (mpdu_data_pkptr);
						wlan_hcf_hlpk_dequeue ((WlanT_HCF_Access_Category) i, 0);
						}
				
					/* Destroy the MPDU retransmission copy since we won't	*/
					/* use it.												*/
					op_pk_destroy (mpdu_retx_copy_arr [i]);
					}
				}
			else
				{
				/* MSDU/MMPDU was fragmented and in the middle of its		*/
				/* transmission we moved to a new BSS. This is extremely	*/
				/* rare case to happen. We can still recover the packet, if	*/
				/* the copy we kept contains the very first fragment.		*/
				/* Otherwise, discard the higher layer packet by flushing	*/
				/* the segmentation buffer and destroying the copy of the	*/
				/* MPDU kept for retransmission.							*/
				if (mpdu_retx_copy_arr [i] == OPC_NIL)
					{
					/* The copy of the last transmitted fragment doesn't	*/
					/* exist. Discard the remaining fragments.				*/
					op_sar_srcbuf_bits_flush (fragmentation_buffer_arr [i], 0, op_sar_buf_size (fragmentation_buffer_arr [i]));
					wlan_hcf_hlpk_dequeue ((WlanT_HCF_Access_Category) i, 0);
					}
				else
					{
					/* Retrieve the fragment's data from MPDU.				*/
					op_pk_fd_get_pkt (mpdu_retx_copy_arr [i], WLANC_DATA_BODY_FD, &mpdu_data_pkptr);
					
					/* Is this the first fragment?							*/
					if (op_pk_total_size_get (mpdu_data_pkptr) + op_sar_buf_size (fragmentation_buffer_arr [i]) == hld_ptr->size)
						{
						/* We have all the bits; hence we can recover the	*/
						/* MSDU/MMPDU.										*/
						op_sar_rsmbuf_seg_insert (common_rsmbuf_ptr, mpdu_data_pkptr);
						op_sar_rsmbuf_seg_insert (common_rsmbuf_ptr, 
												  op_sar_srcbuf_seg_remove (fragmentation_buffer_arr [i], op_sar_buf_size (fragmentation_buffer_arr [i])));
						hld_ptr->pkptr = op_sar_rsmbuf_pk_remove (common_rsmbuf_ptr);
						}
					else
						{
						/* We can't recover the MSDU/MMPDU. Discard the		*/
						/* remaining fragments we have.						*/
						op_sar_srcbuf_bits_flush (fragmentation_buffer_arr [i], 0, op_sar_buf_size (fragmentation_buffer_arr [i]));
						op_pk_destroy (mpdu_data_pkptr);
						wlan_hcf_hlpk_dequeue ((WlanT_HCF_Access_Category) i, 0);
						}

					/* Destroy the MPDU.									*/
					op_pk_destroy (mpdu_retx_copy_arr [i]);
					}
				}
			
			/* Update the retransmission attempts statistics.				*/
			op_stat_write (retrans_handle,        (double) (src_arr [i] + lrc_arr [i]));
			op_stat_write (global_retrans_handle, (double) (src_arr [i] + lrc_arr [i]));

			/* Reset the retry counts.										*/
			src_arr [i] = 0;
			lrc_arr [i] = 0;
			}
		
		/* For voice AC, if the queue contains any MMPDUs or block-ACKs,	*/
		/* remove them.	Skip this actually the new AP is same of the old AP.*/
		if (i == WlanC_AC_VO && eval_bss_id != bss_id)
			{
			voice_ac_queue_size = op_prg_list_size (hlpk_lptr_arr [WlanC_AC_VO]);
			for (j = 0, initial_size = voice_ac_queue_size; j < voice_ac_queue_size; )
				{
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [WlanC_AC_VO], j);
				if (hld_ptr->type == WlanC_Action || hld_ptr->type == WlanC_BA)
					{
					/* This is an action MMPDU. Remove it.					*/
					hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_remove (hlpk_lptr_arr [WlanC_AC_VO], j);
					voice_ac_queue_size--;
					
					/* Also update the related state variables.				*/
					if(LorenDebugFlag)
					{
						printf("Total_hlpk_num before decrement #6 = %d, total_hlpk_size before decrement #6 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
					}
					total_hlpk_num--;
					total_hlpk_size -= hld_ptr->size;
										if(LorenDebugFlag)
					{
						printf("Total_hlpk_num after decrement #6 = %d, total_hlpk_size after decrement #6 = %d\n", (int)total_hlpk_num, (int)total_hlpk_size);
					}
					
					/* Destroy the packet (action frame body) and			*/
					/* information record.									*/
					if (hld_ptr->type == WlanC_Action)
						op_pk_destroy (hld_ptr->pkptr);
					op_prg_mem_free (hld_ptr);
					}
				else
					{
					/* The MMPDUs have to be at the head of the queue. So	*/
					/* if we hit an MSDU then we can skip the rest of the	*/
					/* queue (exception: the first two packets can still be	*/
					/* MSDUs even if the queue also contains MMPDUs).		*/
					if (j == 2)
						j = voice_ac_queue_size;
					else
						/* Move to the next packet.							*/
						j++;
					}
				}
			
			/* If there are any packets removed, updated the statistics.	*/
			if (initial_size != voice_ac_queue_size)
				{
				op_stat_write (hl_packets_rcvd,                       (double) total_hlpk_num);
				op_stat_write (ac_queue_size_shndl_arr [WlanC_AC_VO], (double) voice_ac_queue_size);
				}
			}			
		}
	
	/* Since cw_required flag is reset and some packets may be discarded,	*/
	/* update the AC queue status array if necessary.						*/
	for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
		{
		if (op_prg_list_size (hlpk_lptr_arr [ac_queue_status_arr [i]]) == 0)
			{
			/* The queue of the AC is empty. Remove it from the list of the	*/
			/* active ACs.													*/
			for (j = i; ac_queue_status_arr [j] != WlanC_AC_None; j++)				
				ac_queue_status_arr [j] = ac_queue_status_arr [j + 1];
			
			/* Adjust the loop index for the next iteration since we have	*/
			/* removed one entry from the queue	status array.				*/
			i--;
			}
		}
	
	/* Initialize NAV duration.												*/
	nav_duration = current_time;
	
	/* Initialize receiver idle timer. 										*/
	rcv_idle_time = current_time;

	/* Initialize the variables related to ongoing frame transmission		*/
	/* sequences.															*/
	fresp_to_send       = WlanC_None;
	expected_frame_type = WlanC_None;
	txframe_type        = WlanC_None;
	
	FOUT;
	}

static void
wlan_hcf_cw_values_adjust (void)
	{
	/** This function computes the CWmin and CWmax values of the ACs that	**/
	/** are specified as a function of the PHY's CWmin and CWmax values,	**/
	/** which is the case when the values recommended by the 802.11e		**/
	/** standard are used. This function is typically called when the PHY	**/
	/** CWmin and CWmax values change as a result of roaming.				**/
	FIN (wlan_hcf_cw_values_adjust (void));
	
	/* For any access category whose CWmin depends on the PHY CWmin value,	*/
	/* compute the new CWmin value.											*/
	if (wlan_ac_flags->std_cwmin & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO])
		cwmin_arr [WlanC_AC_VO] = (phy_cw_min + 1) / 4 - 1;
	if (wlan_ac_flags->std_cwmin & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VI])
		cwmin_arr [WlanC_AC_VI] = (phy_cw_min + 1) / 2 - 1;
	if (wlan_ac_flags->std_cwmin & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BE])
		cwmin_arr [WlanC_AC_BE] = phy_cw_min;
	if (wlan_ac_flags->std_cwmin & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BK])
		cwmin_arr [WlanC_AC_BK] = phy_cw_min;
		
	/* For any access category whose CWmax depends on the PHY CWmin value,	*/
	/* compute the new CWmax value.											*/
	if (wlan_ac_flags->std_cwmax & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO])
		cwmax_arr [WlanC_AC_VO] = (phy_cw_min + 1) / 2 - 1;
	if (wlan_ac_flags->std_cwmax & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VI])
		cwmax_arr [WlanC_AC_VI] = phy_cw_min;
	if (wlan_ac_flags->std_cwmax & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BE])
		cwmax_arr [WlanC_AC_BE] = 4 * (phy_cw_min + 1) - 1;
			
	FOUT;
	}

static void 
wlan_hcf_find_new_ap_virtual (void)
	{
	WlanT_AP_Position_Info	*ap_info_ptr;
	double					distance, ap_rx_pow;
	double					lat, lon, alt, x_pos, y_pos, z_pos;

	/** Find the first AP that is closer than the acceptable threshold for	**/
	/** a new connection.													**/
	FIN (wlan_hcf_find_new_ap_virtual (void));

	/* Get current position for comparison with previously cached position. */
	op_ima_obj_pos_get (my_node_objid, &lat, &lon, &alt, &x_pos, &y_pos, &z_pos);

	/* Check whether our position has changed. 								*/
	if ((roam_state_ptr->lat != lat) || (roam_state_ptr->lon != lon) || (roam_state_ptr->alt != alt))
		{
		/* Position has been changed. Cache the new position. 				*/
		roam_state_ptr->lat = lat;
		roam_state_ptr->lon = lon;
		roam_state_ptr->alt = alt;
		}

	/* Loop over all the APs in the network.								*/
	for (ap_info_ptr = global_ap_pos_info_head; ap_info_ptr != OPC_NIL; ap_info_ptr = ap_info_ptr->next_ptr)
		{
		/* Consider only those APs that are on the same channel as our		*/
		/* current channel, which we are scanning.							*/
		if (channel_num != ap_info_ptr->ap_channel_num)
			continue;

		/* Calculate the distance between this STA and an AP from the list. */
		distance = prg_geo_lat_long_distance_get (lat, lon, alt, ap_info_ptr->lat, ap_info_ptr->lon, ap_info_ptr->alt);
		
		/* Compute expected signal strength. 								*/
		ap_rx_pow = wlan_ap_signal_strength_calc (distance, ap_info_ptr, channel_num, phy_type);

		/* Pick the first AP that passes the new connection threshold		*/
		/* check. Note that the beacon-based scanning algorithm picks the	*/
		/* first reliable connection. However, the APs picked may not match	*/
		/* in the different methods.                             			*/
		if (ap_rx_pow > WLANC_ROAM_NEW_CONN_VIRTUAL_THRESH (rx_power_threshold))
			{
			/* STA has found a connection-- move it out of scan mode.		*/
			roam_state_ptr->scan_mode = OPC_FALSE;

			/* Update state variables that permit the STA to connect to the	*/
			/* new AP.														*/
			eval_bss_id = ap_info_ptr->ap_bss_id;
			wlan_set_transceiver_channel (channel_num, phy_type, txch_objid, rxch_objid);
			conn_ap_pos_info_ptr = ap_info_ptr;
			
			break;
			}
		}

	FOUT;
	}

static int
wlan_hcf_seq_a_minus_seq_b (int seq_a, int seq_b, int block_size)
	{
	int		comp_block_size;
	
	/** This function computes the difference between the given two			**/
	/** frame sequence numbers (seq_a - seq_b) while considering the		**/
	/** possibility that the sequence numbers may be wrapped around. The	**/
	/** given block size is used to determine the set of valid sequence		**/
	/** numbers.															**/
	FIN (wlan_hcf_seq_a_minus_seq_b (seq_a, seq_b, block_size));
	
	/* To handle the cases with very small block size properly, assume that	*/
	/* block size is at least 64.											*/
	comp_block_size = (block_size > 64) ? block_size : 64;
	
	/* First check which sequence number is greater.						*/
	if (SEQ_A_GREATER_THAN_SEQ_B (seq_a, seq_b, comp_block_size))
		{
		/* Since A is greater, the difference must be always positive.		*/
		FRET ((seq_a > seq_b ? seq_a - seq_b : seq_a - seq_b + WLANC_SEQ_NUM_WRAP_VALUE));
		}
	else
		{
		/* Since A is smaller (or equal), the difference must be always		*/
		/* non-positive.													*/
		FRET ((seq_a <= seq_b ? seq_a - seq_b : seq_a - seq_b - WLANC_SEQ_NUM_WRAP_VALUE));
		}
	}

static void
wlan_hcf_ptr_fields_print_functions_set (void)
	{
	static Boolean	functions_already_set    = OPC_FALSE;
	
	/** This function sets the print functions for 11e specific structure	**/
	/** type packet fields. Redundant settings are prevented by using a 	**/
	/** static Boolean variable.											**/
	FIN (wlan_hcf_ptr_fields_print_functions_set (void));
	
	/* If this is the first call of the function, set the print functions	*/
	/* for the "structure" type WLAN packet fields that are populated only	*/
	/* by QSTA MACs.														*/
	if (functions_already_set == OPC_FALSE)
		{
		op_pk_format_print_proc_set ("wlan_mac",     "QoS Control",      wlan_hcf_data_qos_info_print);		 
		op_pk_format_print_proc_set ("wlan_control", "Block_ACK_Fields", wlan_hcf_ba_control_info_print);		 
				
		/* Prevent redundant sets.											*/
		functions_already_set = OPC_TRUE;
		}
		
	FOUT;
	}

/*** Call-back Functions ***/

static void
wlan_hcf_data_qos_info_print (void* structure_ptr, PrgT_List* output_list)
	{
	WlanT_QoS_Control_Fields*	qos_info_ptr;
	char*						alloc_str;
	char						temp_str [128];

	/** This call-back function prints the contents of the given QoS		**/
	/** Control field data structure.										**/ 
	FIN (wlan_hcf_data_qos_info_print (structure_ptr, output_list));

	/* Cast the void*.														*/
    qos_info_ptr = (WlanT_QoS_Control_Fields *) structure_ptr;

	/* Print the fields of the data structure.								*/
	sprintf(temp_str, "      TID              int         %-16d(4)", qos_info_ptr->tid);
	PKPRINT_STRING_INSERT (alloc_str, temp_str, output_list)

	sprintf(temp_str, "      ACK Policy       Enumeration %-16s(2)", 
		(qos_info_ptr->ack_policy == WlanC_Normal_ACK) ? "Normal ACK" : ((qos_info_ptr->ack_policy == WlanC_Block_ACK) ? "Block ACK" : "No ACK"));
	PKPRINT_STRING_INSERT (alloc_str, temp_str, output_list)
		
	FOUT;
	}

static void
wlan_hcf_ba_control_info_print (void* structure_ptr, PrgT_List* output_list)
	{
	WlanT_BA_Control_Fields*	ba_cntl_info_ptr;
	char*						alloc_str;
	char						temp_str [128];

	/** This call-back function prints the contents of the given BAR/BA		**/
	/** Control field data structure.										**/ 
	FIN (wlan_hcf_ba_control_info_print (structure_ptr, output_list));

	/* Cast the void*.														*/
    ba_cntl_info_ptr = (WlanT_BA_Control_Fields *) structure_ptr;

	/* Print the fields of the data structure. Don't print the status		*/
	/* bitmap, which is set only for BAs anyway, since it too large to		*/
	/* present all of its contents.											*/
	sprintf(temp_str, "      TID              int         %-16d(4)",  ba_cntl_info_ptr->tid);
	PKPRINT_STRING_INSERT (alloc_str, temp_str, output_list)

	sprintf(temp_str, "      Starting Seq#    int         %-16d(12)", ba_cntl_info_ptr->starting_seq_num);
	PKPRINT_STRING_INSERT (alloc_str, temp_str, output_list)
	PKPRINT_STRING_INSERT (alloc_str, "      Status Bitmap    array       ...             (0 or 1024)", output_list);
		
	FOUT;
	}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

/* Undefine shortcuts to state variables because the */
/* following functions are part of the state class */
#undef a_stat
#undef ac_access_delay_shndl_arr
#undef ac_backoff_slots_shndl_arr
#undef ac_delay_shndl_arr
#undef ac_dropped_buffer_bits_shndl_arr
#undef ac_dropped_buffer_pkts_shndl_arr
#undef ac_dropped_retx_bits_shndl_arr
#undef ac_dropped_retx_pkts_shndl_arr
#undef ac_gb_access_delay_shndl_arr
#undef ac_gb_delay_shndl_arr
#undef ac_gb_dropped_buffer_shndl_arr
#undef ac_gb_dropped_retx_shndl_arr
#undef ac_gb_load_shndl_arr
#undef ac_gb_throughput_shndl_arr
#undef ac_internal_coll_shndl_arr
#undef ac_load_bits_shndl_arr
#undef ac_load_pkts_shndl_arr
#undef ac_queue_size_shndl_arr
#undef ac_queue_status_arr
#undef ac_throughput_shndl_arr
#undef accept_large_packets
#undef accuracyCalculationCounter
#undef accuracyCalculationCounter2
#undef accuracyConstant_a
#undef accuracyConstant_b
#undef accuracyConstant_c
#undef aifs_arr
#undef aifsn_arr
#undef ap_conn_handle
#undef ap_connectivity_check_evhndl
#undef ap_connectivity_check_interval
#undef ap_connectivity_check_time
#undef ap_flag
#undef AP_Lambda_stat
#undef ap_mac_address
#undef ap_peer_info_ptr
#undef appRateBits
#undef average_accuracy
#undef average_distortion
#undef average_stream_DataRate
#undef b_stat
#undef backoff_ac
#undef backoff_elapsed_evh
#undef beacon_int
#undef beacon_interval_stat
#undef beacon_tx_count
#undef beacon_tx_time
#undef bits_load_handle
#undef bits_sent_in_the_last_TXOP
#undef bk_medium_idle_time
#undef bss_edca_params_arr
#undef bss_flag
#undef bss_id
#undef buffer_drop_bits_handle
#undef buffer_drop_pkts_handle
#undef c_stat
#undef channel_bandwidth
#undef channel_count
#undef channel_num
#undef channel_spacing
#undef common_rsmbuf_ptr
#undef common_seq_count
#undef completeFrameRecievedFlag
#undef completeFrames
#undef concealedFrames
#undef config_log_handle
#undef conn_ap_pos_info_ptr
#undef control_data_rate
#undef ctrl_traffic_rcvd_handle
#undef ctrl_traffic_rcvd_handle_inbits
#undef ctrl_traffic_sent_handle
#undef ctrl_traffic_sent_handle_inbits
#undef cur_tx_ac
#undef current_lambda
#undef current_state_name
#undef current_time
#undef CVAccuracyA
#undef CVAccuracyC
#undef CVAccuracyI
#undef cw_arr
#undef cwmax_arr
#undef cwmin_arr
#undef data_frames_sent_in_the_last_stateREport_int_count
#undef data_frames_sent_in_the_last_stateREport_int_count_stat
#undef data_packet_dropped
#undef data_packet_droppedB_in_the_last_stateReport_int_count
#undef data_packet_loaded_in_the_last_stateReport_int_count
#undef data_packet_sent_count
#undef data_packet_sent_count_stat
#undef data_traffic_rcvd_handle
#undef data_traffic_rcvd_handle_inbits
#undef data_traffic_sent_handle
#undef data_traffic_sent_handle_inbits
#undef data_tx_rate
#undef dataRatePeriodCounter
#undef debug_mode
#undef deference_info_arr
#undef defragmentation_list_ptr
#undef difs_time
#undef directoryName
#undef disassociating_sta_lptr
#undef drop_pkt_entry_log_flag
#undef drop_pkt_log_handle
#undef duplicate_entry
#undef EA_stat
#undef EAcounter
#undef EAsum
#undef EDCA_last_DataRate_reset_time
#undef eifs_time
#undef ete_delay_handle
#undef eval_bss_id
#undef expected_frame_type
#undef fee_stat
#undef first_chan_min_freq
#undef frag_threshold
#undef fragmentation_buffer_arr
#undef frame_timeout_evh
#undef frameRate
#undef frameRate_stat
#undef frameRecievedFlag
#undef frameSizeOfNode
#undef fresp_ifs_evh
#undef fresp_to_send
#undef global_buffer_drop_handle
#undef global_ete_delay_handle
#undef global_load_handle
#undef global_mac_delay_handle
#undef global_network_load_handle
#undef global_retrans_handle
#undef global_retx_drop_handle
#undef global_throughput_handle
#undef hl_packets_rcvd
#undef hld_max_size
#undef hld_pmh
#undef hlpk_lptr_arr
#undef i_strm
#undef imageName
#undef imageNo
#undef importance
#undef importance_stat
#undef incompleteFrames
#undef incrementCounter
#undef instrm_from_mac_if
#undef intrpt_code
#undef intrpt_time
#undef intrpt_type
#undef lambda_stat
#undef last_calculated_average_TXOP_displasement
#undef last_calculated_droppedB_prob
#undef last_DataRate_reset_time
#undef last_DataRate_reset_time2
#undef last_DataRate_reset_time_PERIODIC
#undef last_my_droppedB_calculated_time
#undef last_my_droppedR_calculated_time
#undef last_my_load_calculated_time
#undef last_my_sent_calculated_time
#undef last_rcvd_duration
#undef last_sent_averageProtocolOverhead
#undef last_sent_droppedBRate
#undef last_sent_droppedRRate
#undef last_sent_loadRate
#undef last_sent_physicalRate
#undef last_sent_protocolOverheadRate
#undef last_sent_sentRate
#undef last_sent_video_frame_size
#undef last_sent_video_frame_size_without_header
#undef last_sent_video_frame_time
#undef last_tx_frtype_arr
#undef last_TXOP_start_time
#undef lastFrameN
#undef lastFrameSizeInPackets
#undef lastImageLineNumber
#undef lastPacketN
#undef lastQ
#undef linesIndex
#undef llc_iciptr
#undef long_retry_limit
#undef LoopSum_stat
#undef lostPackets
#undef lostPacketsCounter
#undef lrc_arr
#undef Ls
#undef mac_appRate_stat
#undef mac_client_reassembly_buffer
#undef mapping_info_mutex
#undef max_frags_per_msdu
#undef max_operational_speed
#undef max_operational_speed_stat
#undef max_receive_lifetime
#undef maxLoad
#undef maxLoad_stat
#undef media_access_delay
#undef mgmt_retx_drop_bits_handle
#undef mgmt_retx_drop_pkts_handle
#undef mgmt_traffic_rcvd_handle
#undef mgmt_traffic_rcvd_handle_inbits
#undef mgmt_traffic_sent_handle
#undef mgmt_traffic_sent_handle_inbits
#undef missedFrames
#undef mpdu_retx_copy_arr
#undef my_address
#undef my_bss_info_ptr
#undef my_droppedB_stat
#undef my_droppedB_sum
#undef my_droppedR_stat
#undef my_droppedR_sum
#undef my_load_stat
#undef my_load_sum
#undef my_node_objid
#undef my_objid
#undef my_sent_stat
#undef my_sent_sum
#undef my_subnet_objid
#undef myDataRates
#undef MyExcecutionTrace
#undef MyExcecutionTracename
#undef nav_duration
#undef nav_end_evh
#undef nav_reset_evh
#undef new_variable
#undef num_fragments_arr
#undef number_of_stations
#undef number_of_TXOP_in_calculation_period
#undef numberOfInputDataRates
#undef oms_aa_handle
#undef operational_speed
#undef Os
#undef outstrm_to_mac_if
#undef own_ac_edca_params_objid
#undef own_process_record_handle
#undef packet_data_percent_stat
#undef packet_load_handle
#undef packet_size_stat
#undef packetCounter
#undef peer_info_hash_tbl
#undef peerAddress
#undef peerStreamAccuracy
#undef peerStreamAccuracy2
#undef peerStreamAccuracyError
#undef peerStreamAccuracyError2
#undef peerStreamData
#undef peerStreamData2
#undef peerStreamDataForRate
#undef peerStreamDataForRate2
#undef peerStreamDataRate
#undef peerStreamDataRate2
#undef peerStreamDistortion
#undef peerStreamDistortion2
#undef phy_char_flag
#undef phy_cw_max
#undef phy_cw_min
#undef phy_type
#undef physicalRate
#undef physicalRate_readfromtransmiter_stat
#undef physicalRate_stat
#undef pkt_seq_cntl_arr
#undef plcp_overhead_control
#undef plcp_overhead_data
#undef pruning_percent
#undef rcv_idle_time
#undef rcvd_bar_tid
#undef rcvd_frame_drate
#undef receive_time
#undef received_beacon_count
#undef received_beacon_count_stat
#undef received_RTS_count
#undef received_RTS_count_stat
#undef received_stateReport_count
#undef received_stateReport_count_stat
#undef receivedPacketTrace
#undef rem_beacon_tx
#undef remainder_size_arr
#undef response_sta_addr
#undef retrans_handle
#undef retx_drop_bits_handle
#undef retx_drop_pkts_handle
#undef roam_state_ptr
#undef rts_threshold
#undef rx_objid
#undef rx_power_threshold
#undef rx_state_info_ptr
#undef rxch_objid
#undef sent_beacon_count
#undef sent_beacon_count_stat
#undef sent_stateReport_count
#undef sent_stateReport_count_stat
#undef sentPacketTrace
#undef served_pk_id_arr
#undef short_retry_limit
#undef sifs_time
#undef sizes
#undef slot_time
#undef src_arr
#undef start_times
#undef stateReport_int
#undef stateReport_tx_time
#undef stateReportStarted
#undef sumD_stat
#undef tc_config_arr
#undef temp_ph_rate
#undef tempAccuracy
#undef tempFrameSize
#undef throughput_handle
#undef total_ba_reorder_buf_size
#undef total_bits_sent_in_the_last_TXOP
#undef total_data_header_size_sent
#undef total_data_sent
#undef total_data_size_sent_without_headers
#undef total_hlpk_num
#undef total_hlpk_size
#undef total_reorder_size_handle
#undef totalDataResetedFalg
#undef totalDataResetedFalgArray
#undef totalFrames
#undef totalPeerStreamData
#undef totalPeerStreamData2
#undef trimmedAccuracyCounter
#undef trimmedAccuracyCounter2
#undef tx_objid
#undef txch_objid
#undef txframe_type
#undef TXOP_counter
#undef TXOP_displasement_stat
#undef TXOP_displasement_total
#undef txop_limit_arr
#undef txop_start_time
#undef video_TXOP_stat
#undef weighted_accuracy_sum
#undef wlan_ac_flags
#undef wlan_flags
#undef wlan_trace_active

/* Access from C kernel using C linkage */
extern "C"
{
	VosT_Obtype _op_wlan_mac_hcf_init (int * init_block_ptr);
	VosT_Address _op_wlan_mac_hcf_alloc (VosT_Obtype, int);
	void wlan_mac_hcf (OP_SIM_CONTEXT_ARG_OPT)
		{
		((wlan_mac_hcf_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->wlan_mac_hcf (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_wlan_mac_hcf_svar (void *, const char *, void **);

	void _op_wlan_mac_hcf_diag (OP_SIM_CONTEXT_ARG_OPT)
		{
		((wlan_mac_hcf_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))->_op_wlan_mac_hcf_diag (OP_SIM_CONTEXT_PTR_OPT);
		}

	void _op_wlan_mac_hcf_terminate (OP_SIM_CONTEXT_ARG_OPT)
		{
		/* The destructor is the Termination Block */
		delete (wlan_mac_hcf_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr);
		}


} /* end of 'extern "C"' */




/* Process model interrupt handling procedure */


void
wlan_mac_hcf_state::wlan_mac_hcf (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wlan_mac_hcf_state::wlan_mac_hcf ());
	try
		{
		/* Temporary Variables */
		OmsT_Pr_Handle			process_record_handle;
		List*					proc_record_handle_list_ptr;
		OpT_Int64*				sta_addr_ptr;
		int						record_handle_list_size;
		int						ap_count;
		OpT_Int64				sta_addr;
		int						statype;
		Boolean					ap_ba_support;
		Objid					mac_objid;
		Objid					mac_if_module_objid;
		Objid					parent_subnet_objid;
		char					name_str [128];
		Objid					params_attr_objid;
		Objid					wlan_params_comp_attr_objid;
		int						addr_index;
		Prohandle				own_prohandle;
		WlanT_HCF_Peer_Info*	peer_info_ptr;
		void*					dummy_ptr;
		char					msg1 [256];
		WlanT_Phy_Char_Code		sta_phy_char_flag, ap_phy_char_flag;
		Boolean					bad_packet_rcvd = OPC_FALSE;
		Boolean					bad_cts_to_self_rcvd;
		double					tx_power;
		double					x_pos, y_pos, z_pos;
		
		int							ac_total_slots, min_backoff_slots, max_cw_slots;
		WlanT_HCF_Access_Category	ac, min_backoff_ac, max_cw_ac;
		int							slots_completed, ac_slots_completed;
		WlanT_HCF_Access_Category	new_hlpk_ac;
		
		Boolean						state_reentered = OPC_FALSE;
		int							i, j;
		int							integer_mac_address = -1;
		
		double 							sum = 0;
		/* End of Temporary Variables */


		FSM_ENTER ("wlan_mac_hcf")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "INIT", "wlan_mac_hcf [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [INIT enter execs]", state0_enter_exec)
				{
				
				
				
				
				/* Initialization of the process model. All the 		*/
				/* attributes are loaded in this routine.				*/
				
				MyExcecutionTracename = (char*) calloc (500,sizeof(char));
				
				
				mac_appRate_stat = op_stat_reg ("application rate from mac",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
				wlan_hcf_sv_init ();
				
				
				
				//{mohammad
				
				
					sent_beacon_count  = 0;
					sent_beacon_count_stat = op_stat_reg ("sent beacon count",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					sent_stateReport_count  = 0;
					sent_stateReport_count_stat = op_stat_reg ("sent stateReport count",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					received_stateReport_count  = 0;
					received_stateReport_count_stat = op_stat_reg ("received stateReport count",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					received_beacon_count  = 0;
					received_beacon_count_stat = op_stat_reg ("received beacon count",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					received_RTS_count = 0;
					received_RTS_count_stat = op_stat_reg ("received RTS count",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					
					
					frameRate_stat = op_stat_reg ("Frame Rate (frame/sec) from mac",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					packet_size_stat = op_stat_reg ("my packet size",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					
					lambda_stat = op_stat_reg ("lambda in node",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					beacon_interval_stat = op_stat_reg ("beacon interval",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					video_TXOP_stat = op_stat_reg ("video_TXOP_stat",
							OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					importance_stat= op_stat_reg ("importance_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					AP_Lambda_stat = op_stat_reg ("lambda in AP",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					LoopSum_stat = op_stat_reg ("sum from loop in AP",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					number_of_stations = op_stat_reg ("number of stations in network",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					fee_stat = op_stat_reg ("fee",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					EA_stat = op_stat_reg ("EA",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					a_stat= op_stat_reg ("a_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					b_stat= op_stat_reg ("b_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);	
					c_stat= op_stat_reg ("c_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);		
					physicalRate_stat= op_stat_reg ("physicalRate_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);		
					physicalRate_readfromtransmiter_stat = op_stat_reg ("physicalRate_readfromtransmiter_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					data_packet_sent_count_stat = op_stat_reg ("data_packet_sent_count_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					data_frames_sent_in_the_last_stateREport_int_count_stat = op_stat_reg ("data_frames_sent_in_the_last_stateREport_int_count_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					data_packet_sent_count = 0;
					
					average_distortion = op_stat_reg ("average_distortion",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					average_accuracy = op_stat_reg ("average_accuracy",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					average_stream_DataRate = op_stat_reg ("average_stream_DataRate",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				
					packet_data_percent_stat = op_stat_reg ("packet_data_percent_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					weighted_accuracy_sum = op_stat_reg ("weighted_accuracy_sum",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					max_operational_speed_stat = op_stat_reg ("max_operational_speed_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					
					my_droppedB_stat = op_stat_reg ("my_droppedB_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					my_droppedR_stat = op_stat_reg ("my_droppedR_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					my_load_stat = op_stat_reg ("my_load_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					my_sent_stat = op_stat_reg ("my_sent_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					CVAccuracyC = op_stat_reg ("CVAccuracyC",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					CVAccuracyI = op_stat_reg ("CVAccuracyI",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					CVAccuracyA = op_stat_reg ("CVAccuracyA",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					TXOP_displasement_stat = op_stat_reg ("TXOP_displasement_stat",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					sumD_stat = op_stat_reg ("sumD",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
					maxLoad_stat = op_stat_reg ("maxLoad",OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); 
					EACalculationLastTime = EAestimationTime;
					
					
					//initialize my variables for each entry in hash table
					if(myStringDebug)
					{
						sprintf(myString,"I am  %d:Bandwidth Allocation Method is %s\n",(int)my_address,tempBnadwidth_allocation_method);
						op_prg_odb_print_major(myString,OPC_NIL);
					}
					
						if(strcmp(tempBnadwidth_allocation_method,"wdis2")==0||strcmp(tempBnadwidth_allocation_method,"dist2")==0)//power of two distortion curve
							{
							//loren
							opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
							fprintf(opencvDebugFile,"I am  %d:Bandwidth Allocation Method is %s, took 1.\n",(int)my_address,tempBnadwidth_allocation_method);
							fclose(opencvDebugFile);
							if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 4.381;
								accuracyConstant_b =203.8;
								accuracyConstant_c = 0;
								}
							
							else if(strcmp(curve,"accu_quality_GT_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 4.031;//4.381;
								accuracyConstant_b =63.03;//203.8;
								accuracyConstant_c = 0;
								}
							
							else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 4.19;//4.031;//4.381;
								accuracyConstant_b = 102.6;//63.03;//203.8;
								accuracyConstant_c = 0;
								}
							
							else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 4.501;
								accuracyConstant_b =2668;
								accuracyConstant_c = 0;
								}
							
							else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 4.338;
								accuracyConstant_b =1481;
								accuracyConstant_c = 0;
								}
							
							else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 4.165;//need editting
								accuracyConstant_b =647.7;
								accuracyConstant_c = 0;
								}
							else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
								{	
								accuracyConstant_a = 4.087;//6.778;//updated to new curve
								accuracyConstant_b = 50.55;//-0.2555;//updated to new curve
								accuracyConstant_c = 0;//-10.63;//updated to new curve
								}
							
							else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
								{
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt_tree.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt_tree.xml");
								accuracyConstant_a = 3.944;//6.778;//updated to new curve
								accuracyConstant_b = 47;//-0.2555;//updated to new curve
								accuracyConstant_c = 0;//-10.63;//updated to new curve
								}
							
							
							
							else
								op_sim_end ("Bandwidth allocation method and curve used are not compatable", "", "", "");
							
							}
					
							
							
						
						else if(strcmp(tempBnadwidth_allocation_method,"dist")==0 || strcmp(tempBnadwidth_allocation_method,"wdis")==0
							|| strcmp(tempBnadwidth_allocation_method,"dist_app")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link")==0
							||strcmp(tempBnadwidth_allocation_method,"wdis_link")==0||strcmp(tempBnadwidth_allocation_method,"wdis_app")==0
							
							||strcmp(tempBnadwidth_allocation_method,"dist_H")==0 || strcmp(tempBnadwidth_allocation_method,"wdis_H")==0
							|| strcmp(tempBnadwidth_allocation_method,"dist_app_H")==0 ||strcmp(tempBnadwidth_allocation_method,"dist_link_H")==0
							||strcmp(tempBnadwidth_allocation_method,"wdis_link_H")==0||strcmp(tempBnadwidth_allocation_method,"wdis_app_H")==0
							||strcmp(tempBnadwidth_allocation_method,"dist_D")==0||strcmp(tempBnadwidth_allocation_method,"wdis_D")==0
							|| strcmp(tempBnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0|| strcmp(tempBnadwidth_allocation_method,"wdis_withoutAnyEnhancement")==0
							)
							{
							//loren
							opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
							fprintf(opencvDebugFile,"I am  %d:Bandwidth Allocation Method is %s, took 2.\n",(int)my_address,tempBnadwidth_allocation_method);
							fclose(opencvDebugFile);
							if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0)//in Mbytes
								{
								//loren
								opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
								fprintf(opencvDebugFile,"I am  %d:Curve is %s, took 2.\n",(int)my_address,curve);
								fclose(opencvDebugFile);
								
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt_tree.xml");				
								accuracyConstant_a = 3.216;
								accuracyConstant_b =-0.3144;
								accuracyConstant_c = -8.569;
								}
							else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 6.783;//need editting
								accuracyConstant_b =-0.1983;
								accuracyConstant_c = -23.1;
								}
							else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 0.3801;//need editting
								accuracyConstant_b =-0.1966;
								accuracyConstant_c = -1.142;
								}
							
							else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
								{
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 17.93;//6.778;//ubdated to new curve
								accuracyConstant_b = -0.143;//-0.2555;//ubdated to new curve
								accuracyConstant_c = -23.72;//-10.63;//ubdated to new curve
								}
							else if(strcmp(curve,"accu_quality_frontal")==0)
								{
								accuracyConstant_a = 8.417E-7;
								accuracyConstant_b = -3.937;
								accuracyConstant_c = 0;
								}
							else if(strcmp(curve,"accu_resolution_frontal")==0)
								{
								accuracyConstant_a = 0.1403;
								accuracyConstant_b = -0.6785;
								accuracyConstant_c = 0;
								}
							else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
								{
								/*sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt_tree.xml");
								accuracyConstant_a = 39.55;//6.778;//ubdated to new curve
								accuracyConstant_b = -0.07729;//-0.2555;//ubdated to new curve
								accuracyConstant_c = -46.01;//-10.63;//ubdated to new curve*/
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 39.55;//6.778;//ubdated to new curve
								accuracyConstant_b = -0.07729;//-0.2555;//ubdated to new curve
								accuracyConstant_c = -46.01;//-10.63;//ubdated to new curve
								}
							else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
								{
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 9.545;//6.778;//ubdated to new curve
								accuracyConstant_b = -0.1845;//-0.2555;//ubdated to new curve
								accuracyConstant_c = -15.41;//-10.63;//ubdated to new curve
								}	
							else
								op_sim_end ("Bandwidth allocation method and curve used are not compatable", "", "", "");
							if(myStringDebug)
								{
							sprintf(myString,"I am  %d:Distortion constants initialized\n",(int)my_address);
							op_prg_odb_print_major(myString,OPC_NIL);
							}
							
							}
						else if (strcmp(tempBnadwidth_allocation_method,"EDCA")==0 ||strcmp(tempBnadwidth_allocation_method,"EDCA_estimation")==0 ||strcmp(tempBnadwidth_allocation_method,"EDCA_estimation_txop")==0 ||strcmp(tempBnadwidth_allocation_method,"faccu")==0 ||strcmp(tempBnadwidth_allocation_method,"accu")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link")==0||strcmp(tempBnadwidth_allocation_method,"accu_app")==0
							||strcmp(tempBnadwidth_allocation_method,"accu_H")==0 || strcmp(tempBnadwidth_allocation_method,"accu_link_H")==0||strcmp(tempBnadwidth_allocation_method,"accu_app_H")==0
							||strcmp(tempBnadwidth_allocation_method,"accu_link_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_app_D")==0
							||strcmp(tempBnadwidth_allocation_method,"accu_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_withoutAnyEnhancement")==0 
							|| strcmp(tempBnadwidth_allocation_method,"accu_D2_withoutAnyEnhancement")==0 || strcmp(tempBnadwidth_allocation_method,"accu_D2")==0
							|| strcmp(tempBnadwidth_allocation_method,"accu_onlyApp_D")==0 || strcmp(tempBnadwidth_allocation_method,"accu_onlylink_D")==0
							)
							{
							
							//loren
							opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
							fprintf(opencvDebugFile,"I am  %d:Bandwidth Allocation Method is %s, took 3.\n",(int)my_address,tempBnadwidth_allocation_method);
							fclose(opencvDebugFile);
							
							if(strcmp(curve,"accu_quality_GT50_withNI")==0)//in Mbytes
								{
								
								//Loren
								opencvDebugFile = fopen("C:\\opnetTraceFiles\\opencvTrace.txt","a");
								fprintf(opencvDebugFile,"I am  %d:Curve is %s, took 3.\n",(int)my_address,curve);
								fclose(opencvDebugFile);
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt_tree.xml");	
								accuracyConstant_a = 8.597e-013;
								accuracyConstant_b =-3.654;
								accuracyConstant_c = 0.08355;
								}
							
							else if(strcmp(curve,"accu_quality_GT_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 1.936e-10;//3.487e-016;
								accuracyConstant_b =-3.191;//-4.748;
								accuracyConstant_c = 0.02927;//0.04805;
								}
							else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0)//in Mbytes
								{
								
								accuracyConstant_a = 1.01E-9;//1.936e-10;//3.487e-016;
								accuracyConstant_b =-2.78;//-3.191;//-4.748;
								accuracyConstant_c = 0.02325;//0.02927;//0.04805;
								}
							else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 2.158E-8;
								accuracyConstant_b =-1.807;
								accuracyConstant_c = 0.04894;
								}
							
							
							else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 9.399e-13;
								accuracyConstant_b =-2.997;
								accuracyConstant_c = 0.005403;
								}
							
							else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0)//in Mbytes
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								accuracyConstant_a = 1.991e-011;
								accuracyConstant_b =-2.732;
								accuracyConstant_c = 0.01739;
								}
							
							else if(strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)//in Mbytes
								{
							
								//for curve accuracy error = 1-detectionIndex
								accuracyConstant_a = 2.301E-8;
								accuracyConstant_b = -1.8;
								accuracyConstant_c = 0.04801;
								}
							
							else if(strcmp(curve,"accu_quality_cmumit_withNI")==0)//fixed
								{
								//for curve accuracy error = 1-detectionIndex + false detection index
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 3.498e-8;//1.266E-7;//ubdated to new curve
								accuracyConstant_b =  -2.663;//-2.529;//ubdated to new curve
								accuracyConstant_c = 0.1954;//0.2362;//ubdated to new curve
								}
							else if(strcmp(curve,"accu_quality_cmumit_withoutNI")==0)//fixed
								{
							
								//for curve accuracy error = 1-detectionIndex
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 9.88e-7;//1.266E-7;//ubdated to new curve
								accuracyConstant_b =  -2.134;//-2.529;//ubdated to new curve
								accuracyConstant_c = 0.08131;//0.2362;//ubdated to new curve
								}
							
							else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
								{
								/*sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt_tree.xml");
								accuracyConstant_a = 9.963E-6;
								accuracyConstant_b = -1.725;
								accuracyConstant_c = 0.1813;*/
								
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 1.964E-6;
								accuracyConstant_b = -2.022;
								accuracyConstant_c = 0.08224;
								}
							else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
								{
								sprintf(cascade_name,"%s","C:\\OpenCV2.4\\opencv\\data\\haarcascades\\haarcascade_frontalface_alt.xml");
								//sprintf(cascade_name,"%s","C:/OpenCV2.1/data/haarcascades/haarcascade_frontalface_alt.xml");
								accuracyConstant_a = 4.977E-8;//6.778;//ubdated to new curve
								accuracyConstant_b = -2.346;//-0.2555;//ubdated to new curve
								accuracyConstant_c = 0.09305;//-10.63;//ubdated to new curve
								}	
							
							else if(strcmp(curve,"accu_quality_frontal")==0)
								{
								accuracyConstant_a = 4.346E-16;
								accuracyConstant_b = -8.104;
								accuracyConstant_c = 0.1797;
								}
							else if(strcmp(curve,"accu_resolution_frontal")==0)
								{
								accuracyConstant_a = 5.079E-008;
								accuracyConstant_b = -2.28;
								accuracyConstant_c = 0.2446;
								}
							else
								op_sim_end ("Bandwidth allocation methon and curve used are not compatable", "", "", "");
								
									
							
							
							if(myStringDebug)
								{
								sprintf(myString,"I am  %d:Accuracy constants initialized\n",(int)my_address);
								op_prg_odb_print_major(myString,OPC_NIL);
								}
							
							}
						
						
						else
							{
							if(myStringDebug)
								{
							sprintf(myString,"I am  %d:Curve Constants not initialized (%d)\n",(int)my_address, strcmp(tempBnadwidth_allocation_method,"wdis"));
							op_prg_odb_print_major(myString,OPC_NIL);
							}
							}
							
						//importance = op_dist_uniform (100) ;
						frameRate = 20;//op_stat_local_read(2);
						//physicalRate = max_operational_speed;
					
					temp_ph_rate = 0;
					//last_sent_physicalRate = physicalRate;
					last_sent_protocolOverheadRate = 0;
					data_frames_sent_in_the_last_stateREport_int_count =0;
					data_packet_sent_count = 0;
					data_packet_dropped = 0;
					data_packet_droppedB_in_the_last_stateReport_int_count=0;
					data_packet_loaded_in_the_last_stateReport_int_count = 0;
					last_calculated_droppedB_prob = 0;
					Ls = 5815;
					Os = 787;
						
					EDCA_last_DataRate_reset_time = 0;
					last_DataRate_reset_time2=0;
						
					last_sent_droppedBRate = 0;
					last_sent_droppedRRate = 0;
					last_sent_loadRate = 0;
					last_sent_sentRate = 0;
						
					
					my_droppedB_sum = 1;
					my_droppedR_sum = 1;
					my_load_sum =1;
					my_sent_sum = 1;
					
					last_my_droppedB_calculated_time = -1;
					last_my_droppedR_calculated_time = -1;
					last_my_load_calculated_time = -1;
					last_my_sent_calculated_time = -1;
						
					last_TXOP_start_time = 0;
					number_of_TXOP_in_calculation_period = 0;
					TXOP_displasement_total=0;
					bits_sent_in_the_last_TXOP = 0;
					total_bits_sent_in_the_last_TXOP = 0;
					TXOP_counter = 0;
					last_DataRate_reset_time_PERIODIC = 0;
					completeFrameRecievedFlag = 0;
					frameRecievedFlag = 0;
						
					total_data_sent = 0;
						
					stateReportStarted = 0;
					totalDataResetedFalg = 0;
						
						incrementCounter = 0;
						EAsum = 0;
						EAcounter = 0;
						
						
						incompleteFrames = 0;
						completeFrames = 0;
						missedFrames = 0;
						totalFrames = 0;
						concealedFrames=0;
						
						maxLoad = 0;
						
					
					
					
					//loading size info
					//Is this brace necessary	
					{
						char line[300];
						FILE * sizeInfo;
						int lineNo, q;
						
						if(strcmp(curve,"accu_quality_GT50_withNI")==0 || strcmp(curve,"accu_quality_GT50_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\georgiaTech\\gt_db50\\sizeInfo50.txt","r");
						else if(strcmp(curve,"accu_quality_GT_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\georgiaTech\\sizeInfo.txt","r");
						else if(strcmp(curve,"accu_quality_GT75_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\georgiaTech\\gt_db75\\sizeInfo75.txt","r");
						else if(strcmp(curve,"accu_quality_scfaced1_withNI")==0 || strcmp(curve,"accu_quality_scfaced1_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance1.txt","r");
						else if(strcmp(curve,"accu_quality_scfaced2_withNI")==0 || strcmp(curve,"accu_quality_scfaced2_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance2.txt","r");
						else if(strcmp(curve,"accu_quality_scfaced3_withNI")==0 || strcmp(curve,"accu_quality_scfaced3_withoutNI")==0)
							sizeInfo = fopen("C:\\facedatabase\\SCFace\\sizeInfo_distance3.txt","r");
						else if(strcmp(curve,"accu_quality_cmumit_withNI")==0||strcmp(curve,"accu_quality_cmumit_withoutNI")==0)
								
							sizeInfo = fopen("C:\\facedatabase\\CMU_MIT\\sizeInfo.txt","r");
						else if(strcmp(curve,"accu_quality_NEWcmumit_withoutNI")==0)
								
							sizeInfo = fopen("C:\\facedatabase\\CMU_MIT\\anew\\NewCMUSizeInfo.txt","r");
						else if(strcmp(curve,"accu_quality_NEWcmumitSmall_withoutNI")==0)
								
							sizeInfo = fopen("C:\\facedatabase\\CMU_MIT\\anewSmall\\sizeInfo.txt","r");
					
						if(!sizeInfo)
							op_sim_end("size info file could not be opend"," ","","");
					
						fgets(line, 1000,sizeInfo);
						if(opencvDebugFlag)
							{
							sprintf(myString,"first line is %s\n",line);
							op_prg_odb_print_major(myString,OPC_NIL);
							}
						//Loren: Debugging
						if(LorenDebugFlag)
						{	
							printf("first line is %s\n",line);
						}
						
						sscanf(line,"%d",&imageNo);//read image number from the size info file first line
						//imageLineNo = rand() % imageNo + 1; // the image line number randomly this is the line number that we want to read from the size info file
						
						sizes = (int**)calloc (imageNo+1,sizeof(int*));
						directoryName = (char**) calloc (imageNo+1,sizeof(char*));
						imageName = (char**) calloc (imageNo+1,sizeof(char*));
						
						for(lineNo = 1 ; lineNo < imageNo+1;lineNo++)
						{
							
							sizes[lineNo]= (int*)calloc (101,sizeof(int));
							directoryName[lineNo] = (char*) calloc (20,sizeof(char));
							imageName[lineNo] = (char*) calloc (50,sizeof(char));
							fscanf(sizeInfo,"%s%s",imageName[lineNo], directoryName[lineNo]);
							
							for(q = 1 ; q < 101;q++)
								fscanf(sizeInfo,"%d",&sizes[lineNo][q]);
							
							if(LorenDebugFlag)
							{
								printf("%s%s\n",imageName[lineNo], directoryName[lineNo]);
							}
							
						}
							
							
							
							fclose(sizeInfo);
							
					//Is this brace necessary		
					}
					
					
					
					
				
				//}
				
				
				
						
				/* Schedule a self interrupt to wait for mac interface 	*/
				/* to move to next state after registering				*/
				op_intrpt_schedule_self (op_sim_time (), 0);
						
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"wlan_mac_hcf")


			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "INIT", "wlan_mac_hcf [INIT exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [INIT exit execs]", state0_exit_exec)
				{
				/* Obtain the process's process handle.					*/
				own_prohandle = op_pro_self ();
				
				/* Obtain the values assigned to the various attributes.*/
				op_ima_obj_attr_get (my_objid, "Wireless LAN Parameters", &wlan_params_comp_attr_objid);
				params_attr_objid = op_topo_child (wlan_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
				
				/* Obtain the name of the process.						*/
				op_ima_obj_attr_get (my_objid, "process model", name_str);
				
				/* Determine the assigned MAC address which will be		*/
				/* used for address resolution. Note this is not the	*/
				/* final MAC address as there may be static assignments	*/
				/* in the network.										*/
				op_ima_obj_attr_get (my_objid, "Address", &integer_mac_address);
				
				/* Perform auto-addressing for the MAC address. Apart	*/
				/* from dynamically addressing, if auto-assigned, the	*/
				/* address resolution function also detects duplicate	*/
				/* static assignments. The function also initializes 	*/
				/* every MAC address as a valid destination.			*/
				oms_aa_address_resolve (oms_aa_handle, my_objid, &integer_mac_address);
				my_address = integer_mac_address;
					
				/* Register Wlan MAC process in the model wide registry	*/
				own_process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register (my_node_objid, my_objid, own_prohandle, name_str);
				
				/* Initialize the channels of our transmitter and		*/
				/* receiver.											*/
				wlan_hcf_transceiver_channel_init ();
				
				/* If this station is an access point then it has to be registered as an Access Point.	*/
				/* This is because the network will be treated as Infrastructure network once AP is		*/
				/* detected.																			*/
				if (ap_flag == OPC_BOOLINT_ENABLED)
					{
					/* Allocation of record that stores position information for the AP-- STAs obtain a */
					/* pointer to this record to calculate their distance to the AP for "virtual roam". */
					conn_ap_pos_info_ptr = (WlanT_AP_Position_Info*) op_prg_mem_alloc (sizeof (WlanT_AP_Position_Info));
				
					/* Access and store node position and transmit power. */
					op_ima_obj_pos_get (my_node_objid, &(conn_ap_pos_info_ptr->lat), &(conn_ap_pos_info_ptr->lon),
						&(conn_ap_pos_info_ptr->alt), &x_pos, &y_pos, &z_pos);
					op_ima_obj_attr_get (params_attr_objid, "Transmit Power", &tx_power);
					conn_ap_pos_info_ptr->tx_power = tx_power;
				
					/* Save the BSS ID & channel number in this record-- used when the STA switches to another AP */
					conn_ap_pos_info_ptr->ap_bss_id = bss_id;
					conn_ap_pos_info_ptr->ap_channel_num = channel_num;
				
					oms_pr_attr_set (own_process_record_handle,
						"protocol",				OMSC_PR_STRING,			"mac",
						"mac_type",				OMSC_PR_STRING,			"wireless_lan",
						"subprotocol", 			OMSC_PR_INT32,			WlanC_QAP,
						"domain_id",			OMSC_PR_NUMBER,			(double) bss_id,
						"PHY_type",				OMSC_PR_NUMBER,			(double) phy_type,
						"QoS support",			OMSC_PR_INT32,			(int) OPC_TRUE,
						"Block ACK capability",	OMSC_PR_INT32,			(int) wlan_flags->ba_support,
						"subnetid",				OMSC_PR_OBJID,		    my_subnet_objid,
						"ratx_objid",			OMSC_PR_OBJID,			tx_objid,
						"rarx_objid",			OMSC_PR_OBJID,			rx_objid,
						"address",			    OMSC_PR_INT64,			my_address,
						"link_speed",			OMSC_PR_NUMBER,			data_tx_rate,
						"auto address handle",  OMSC_PR_POINTER,  	    oms_aa_handle,
						"position record",  	OMSC_PR_POINTER,  	    conn_ap_pos_info_ptr,
						"PCF active",			OMSC_PR_NUMBER,			0.0,
						OPC_NIL);
					}
				else
					{
				   	oms_pr_attr_set (own_process_record_handle,
						"protocol",				OMSC_PR_STRING,			"mac",
						"mac_type",				OMSC_PR_STRING,			"wireless_lan",
						"subprotocol", 			OMSC_PR_INT32,			WlanC_nAP_QSTA,
						"domain_id",			OMSC_PR_NUMBER,		    (double) bss_id,
						"PHY_type",				OMSC_PR_NUMBER,			(double) phy_type,
						"QoS support",			OMSC_PR_INT32,			(int) OPC_TRUE,
						"Block ACK capability",	OMSC_PR_INT32,			(int) wlan_flags->ba_support,
						"subnetid",				OMSC_PR_OBJID,			my_subnet_objid,
						"ratx_objid",			OMSC_PR_OBJID,			tx_objid,
						"rarx_objid",			OMSC_PR_OBJID,			rx_objid,
						"address",				OMSC_PR_INT64,			my_address,
						"link_speed",			OMSC_PR_NUMBER,			data_tx_rate,
						"auto address handle",	OMSC_PR_POINTER,		oms_aa_handle,
						"PCF active",			OMSC_PR_NUMBER,			0.0,
						OPC_NIL);                                       
					}
				
				/* Obtain the MAC layer information for the local MAC	*/
				/* process from the model-wide registry.				*/
				/* This is to check if the node is a gateway or not.	*/
				proc_record_handle_list_ptr = op_prg_list_create ();
				
				oms_pr_process_discover (OPC_OBJID_INVALID, proc_record_handle_list_ptr, 
					"node objid",					OMSC_PR_OBJID,			 my_node_objid,
					"protocol", 					OMSC_PR_STRING, 		 "bridge",
				 	 OPC_NIL);
				
				/* If the MAC interface process registered itself,	*/
				/* then there must be a valid match					*/
				record_handle_list_size = op_prg_list_size (proc_record_handle_list_ptr);
				
				if (record_handle_list_size != 0)
					{
					wlan_flags->bridge_flag = OPC_TRUE;
					}
				
				/* If the station is not a bridge only then check for arp	*/
				if (wlan_flags->bridge_flag == OPC_FALSE)
					{
					/* Deallocate memory used for process discovery	*/
					while (op_prg_list_size (proc_record_handle_list_ptr))
						{
						op_prg_list_remove (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
						}
					op_prg_mem_free (proc_record_handle_list_ptr);
				
					/* Obtain the MAC layer information for the local MAC	*/
					/* process from the model-wide registry.				*/
					proc_record_handle_list_ptr = op_prg_list_create ();
					
					oms_pr_process_discover (my_objid, proc_record_handle_list_ptr, 
						"node objid",			OMSC_PR_OBJID,			my_node_objid,
						"protocol", 			OMSC_PR_STRING,			"arp", 
						OPC_NIL);
				
					/* If the MAC interface process registered itself,	*/
					/* then there must be a valid match					*/
					record_handle_list_size = op_prg_list_size (proc_record_handle_list_ptr);
					}
				
				if (record_handle_list_size != 1)
					{
					/* An error should be created if there are more	*/
					/* than one WLAN-MAC process in the local node,	*/
					/* or if no match is found.						*/
					wlan_error_print ("Either zero or several WLAN MAC interface processes found in the node.", OPC_NIL, OPC_NIL);
					}
				else
					{
					/*	Obtain a handle on the process record	*/
					process_record_handle = (OmsT_Pr_Handle) op_prg_list_access (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
				
					/* Obtain the module objid for the Wlan MAC Interface module	*/
					oms_pr_attr_get (process_record_handle, "module objid", OMSC_PR_OBJID, &mac_if_module_objid);
				
					/* Obtain the stream numbers connected to and from the	*/
					/* Wlan MAC Interface layer process						*/
					oms_tan_neighbor_streams_find (my_objid, mac_if_module_objid, &instrm_from_mac_if, &outstrm_to_mac_if);
					}
					
				/* Deallocate memory used for process discovery	*/
				while (op_prg_list_size (proc_record_handle_list_ptr))
					{
					op_prg_list_remove (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
					}
				
				op_prg_mem_free (proc_record_handle_list_ptr);
				
				if (debug_mode)
					{
					/* Cache the state name from which this function was	*/
					/* called.												*/
					strcpy (current_state_name, "BSS_INIT");  
					}
				}
				FSM_PROFILE_SECTION_OUT (state0_exit_exec)


			/** state (INIT) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "INIT", "BSS INIT", "tr_292", "wlan_mac_hcf [INIT -> BSS INIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (IDLE) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "IDLE", state1_enter_exec, "wlan_mac_hcf [IDLE enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IDLE enter execs]", state1_enter_exec)
				{
				/* The MAC enters into this state and remains in this state		*/
				/* when all the conditions below are true.						*/
				/* 1. Initialization is complete.								*/
				/* 2. There are no higher layer packets to transmit.			*/
				/* 3. There are no management frames (e.g., beacon) to send.	*/
				/* 4. There are no response frames (e.g., ACK) to send.			*/
				/* 5. There is no CW-backoff following a successful				*/
				/*    transmission to perform.									*/
				/* 6. If the MAC is connected to an AP (not in ad-hoc BSS or	*/
				/*    not an AP itself), the connection is reliable.			*/
				
				/* Record the state name for debugging purposes.				*/
				if (debug_mode)	
					strcpy (current_state_name, "IDLE");
				
				/* If roaming is enabled on this node, then ensure that			*/
				/* connectivity is checked every few beacon intervals. If the	*/
				/* scan type is "virtual" (where the distance or pathloss to	*/
				/* all AP's are evaluated directly) then AP evaluation is done	*/
				/* if needed whenever any new interrupt is processed. Moreover,	*/
				/* the time at which connectivity to the AP should be next		*/
				/* evaluated is also updated each time this evaluation is		*/
				/* performed. Therefore, we need not update the next evaluation	*/
				/* time. On the other hand, if the scan type is based on 		*/
				/* actual beacon or signal strength evaluation, the next		*/
				/* evaluation time is not updated when new interrupts are		*/
				/* processed. Therefore the next evaluation time must be		*/
				/* updated. See wlan_interrupts_process() for clarification.	*/
				if (roam_state_ptr->enable_roaming) 
					{
					if (roam_state_ptr->scan_type != WlanC_Scan_Type_Distance)
						{
						ap_connectivity_check_time = current_time + beacon_int * WLANC_CONN_CHK_BEACON_MULT;
						}
					ap_connectivity_check_evhndl = op_intrpt_schedule_self (ap_connectivity_check_time, WlanC_AP_Check_Timeout);
					}
				
				/* Reset the forced backoff end flag that may have been set in	*/
				/* the BACKOFF state under rare, special cases.					*/
				wlan_flags->forced_bk_end = OPC_FALSE;
				
				/* Unlock the mutex that serializes accessing the roaming		*/
				/* related information of this MAC. 							*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"wlan_mac_hcf")


			/** state (IDLE) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "IDLE", "wlan_mac_hcf [IDLE exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IDLE exit execs]", state1_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Interrupt processing routine.									*/
				//Loren
				//printf("I am %d: Calling the wlan_hcf_interrupts_process 1.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				
				/* If the medium is not busy, and we don't have a response frame to	*/
				/* send and we have a higher layer frame to send, then check		*/
				/* whether the medium was idling long enough so that we can			*/
				/* transmit the higher layer frame without performing a backoff.	*/
				if (HL_FRAME_TO_SEND && MEDIUM_IS_IDLE && fresp_to_send == WlanC_None)
					{
					/* Check whether the medium was idling sufficiently long, so	*/
					/* that we can start our transmission without a backoff.		*/
					/* Compare the idle period with the AIFS of the AC of interest.	*/
					/* If EIFS flag is set then medium has to be idling for         */
					/* "EIFS - DIFS + AIFS" for immediate transmission.				*/
					if (current_time - MEDIUM_IDLE_TIME >= aifs_arr [ac_queue_status_arr [0]] &&
						(wlan_flags->wait_eifs_dur == OPC_FALSE || current_time - rcv_idle_time >= eifs_time - difs_time + aifs_arr [ac_queue_status_arr [0]]))
						{
						/* We can start the transmission immediately.				*/
						wlan_flags->immediate_xmt = OPC_TRUE;
						cur_tx_ac = ac_queue_status_arr [0];
						}
					}
				
				/* If roaming is enabled, there must be a periodic self interrupt	*/
				/* scheduled for checking connectivity. Cancel this interrupt when	*/
				/* exiting this state. 												*/
				if (roam_state_ptr->enable_roaming && (intrpt_type != OPC_INTRPT_SELF || intrpt_code != WlanC_AP_Check_Timeout))
					{
					op_ev_cancel (ap_connectivity_check_evhndl);
					}
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (IDLE) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IDLE trans conditions]", state1_trans_conds)
			FSM_INIT_COND (IMMEDIATE_XMT)
			FSM_TEST_COND (RESPONSE_TO_SEND)
			FSM_TEST_COND (HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE)
			FSM_TEST_COND (DEFER)
			FSM_TEST_COND (AP_DISCONNECTED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("IDLE")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "IMMEDIATE_XMT", "", "IDLE", "TRANSMIT", "tr_295", "wlan_mac_hcf [IDLE -> TRANSMIT : IMMEDIATE_XMT / ]")
				FSM_CASE_TRANSIT (1, 7, state7_enter_exec, ;, "RESPONSE_TO_SEND", "", "IDLE", "SIFS", "tr_26", "wlan_mac_hcf [IDLE -> SIFS : RESPONSE_TO_SEND / ]")
				FSM_CASE_TRANSIT (2, 8, state8_enter_exec, ;, "HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE", "", "IDLE", "MEDIUM BUSY", "tr_31", "wlan_mac_hcf [IDLE -> MEDIUM BUSY : HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE / ]")
				FSM_CASE_TRANSIT (3, 9, state9_enter_exec, ;, "DEFER", "", "IDLE", "IFS and BACKOFF", "tr_33", "wlan_mac_hcf [IDLE -> IFS and BACKOFF : DEFER / ]")
				FSM_CASE_TRANSIT (4, 6, state6_enter_exec, ;, "AP_DISCONNECTED", "", "IDLE", "SCAN", "tr_43", "wlan_mac_hcf [IDLE -> SCAN : AP_DISCONNECTED / ]")
				FSM_CASE_TRANSIT (5, 1, state1_enter_exec, ;, "default", "", "IDLE", "IDLE", "tr_290", "wlan_mac_hcf [IDLE -> IDLE : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (TRANSMIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "TRANSMIT", state2_enter_exec, "wlan_mac_hcf [TRANSMIT enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [TRANSMIT enter execs]", state2_enter_exec)
				{
				/* We enter into this state to transmit a frame following a			*/
				/* deference period that covered the required inter-frame spacing	*/
				/* period and, if needed, a backoff period, which also implies that	*/
				/* the medium is currently idle. The only exception about this rule	*/ 
				/* is that when we are in this state to transmit an ACK frame, the	*/
				/* MAC may be sensing the medium as busy, but we will still 		*/
				/* continue with our transmission since the ACK transmission		*/
				/* procedure ignores the busy medium status (section 9.2.8.).		*/
				
				/* Make sure this is not a reentry into this state.					*/
				if (state_reentered == OPC_FALSE)
					{
					/* If what we will send is not a response frame, then this is	*/
					/* the start of a new TXOP.										*/
					if (fresp_to_send == WlanC_None)
						txop_start_time = current_time;
					
					/* Start the transmission of the frame.							*/
					wlan_hcf_frame_transmit ();
					
					/* Was this a start of a frame sequence without deference?		*/
					if (wlan_flags->immediate_xmt == OPC_TRUE)
						{
						/* Reset the immediate transmission flag.					*/
						wlan_flags->immediate_xmt = OPC_FALSE;
						
						/* Also reset the EIFS flag which may have set.				*/
						wlan_flags->wait_eifs_dur = OPC_FALSE;
						}
				
					/* Or was it a "forced backoff end" case?						*/
					else if (wlan_flags->forced_bk_end == OPC_TRUE)
						{
						/* This flag indicates a rare case: at the exact time when	*/
						/* we completed our backoff	and started our transmission,	*/
						/* we also started receiving a packet. Hence, mark the		*/
						/* currently being received packet as a	bad packet.			*/
						wlan_flags->rcvd_bad_packet = OPC_TRUE;
						
						/* If we are transmitting a CTS-to-self, then mark it as	*/
						/* bad, too.												*/
						if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Cts && expected_frame_type == WlanC_Cts)
							wlan_flags->rcvd_bad_cts = OPC_TRUE;
						
						/* Reset the flag.											*/
						wlan_flags->forced_bk_end = OPC_FALSE;		
						}
					
					/* Update the state name info for debugging purposes.			*/
					if (debug_mode)
						{
						/* Determine the current state name.						*/
						strcpy (current_state_name, "TRANSMIT");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"wlan_mac_hcf")


			/** state (TRANSMIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "TRANSMIT", "wlan_mac_hcf [TRANSMIT exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [TRANSMIT exit execs]", state2_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related			*/
				/* information of this MAC. 											*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Check the interrupt type.											*/
				if (op_intrpt_type () == OPC_INTRPT_STAT)
					{
					/* If the packet is received while the the station is transmitting	*/
					/* then mark the received packet as bad.							*/
					intrpt_code = (WlanT_Mac_Intrpt_Code) op_intrpt_stat ();
					if (intrpt_code < TRANSMITTER_BUSY_INSTAT && op_stat_local_read (intrpt_code) > rx_power_threshold &&
						wlan_flags->rcvd_bad_packet == OPC_FALSE && 
						(wlan_flags->bad_packet_dropped == OPC_FALSE || wlan_flags->receiver_busy == OPC_FALSE) &&
						rx_state_info_ptr->busy_due_to_jammer == OPC_FALSE)
						{	
						wlan_flags->rcvd_bad_packet = OPC_TRUE;
				
						/* If we are transmitting a CTS-to-self, then mark it as bad,	*/
						/* too.															*/
						if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Cts && expected_frame_type == WlanC_Cts)
							wlan_flags->rcvd_bad_cts = OPC_TRUE;				
						}
					
					/* If we completed the transmission then reset the transmitter flag.*/
					else if (intrpt_code == TRANSMITTER_BUSY_INSTAT)
						{
						wlan_flags->transmitter_busy = OPC_FALSE;
						
						/* Also update the receiver idle time, since with the end of	*/
						/* our transmission, the medium may become idle again. If the	*/
						/* transmission requires 11g signal extension, model the 6-usec	*/
						/* no-transmission duration of signal extension by adjusting	*/
						/* the receiver idle time accordingly.							*/
						if (wlan_flags->wait_signal_ext == OPC_FALSE)
							rcv_idle_time = op_sim_time ();
						else
							{
							rcv_idle_time = op_sim_time () + WLANC_11g_SIGNAL_EXTENSION;
							wlan_flags->wait_signal_ext = OPC_FALSE;
							}
						
						/* "Response frame to send" will be set to QoS_Data if the		*/
						/* current transmission is broadcast and we were planning to	*/
						/* continue with another transmission within the current TXOP.	*/
						/* When the transmission completes, if the receiver is busy,	*/
						/* then this STA detects the collision involving its			*/
						/* transmission and terminates its TXOP prematurely.			*/
						if (wlan_flags->receiver_busy == OPC_TRUE && fresp_to_send == WlanC_QoS_Data)
							fresp_to_send = WlanC_None;
				
						/* If we transmitted a CTS-to-self that is marked bad because	*/
						/* of a colliding reception, then reset the corresponding flag,	*/
						/* if our receiver is currently not	busy. That means, the		*/
						/* reception has started and ended while we were transmitting	*/
						/* our CTS-to-self, and	therefore we can't detect that			*/
						/* collision. Hence, we have to assume that our CTS-to-self		*/
						/* transmission was	successful and to continue the frame		*/
						/* sequence with the transmission of the data frame.			*/
						if (wlan_flags->rcvd_bad_cts == OPC_TRUE && wlan_flags->receiver_busy == OPC_FALSE)
							wlan_flags->rcvd_bad_cts = OPC_FALSE;
						}
					}
				
				else if ((op_intrpt_type () == OPC_INTRPT_STRM) && (op_intrpt_strm () != instrm_from_mac_if))
					{
					/* While transmitting, we received a packet from physical layer.	*/
					/* Mark the packet as bad.											*/
					wlan_flags->rcvd_bad_packet = OPC_TRUE;
				
					/* If we are transmitting a CTS-to-self, then mark it as bad too.	*/
					if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Cts && expected_frame_type == WlanC_Cts)
						wlan_flags->rcvd_bad_cts = OPC_TRUE;
					}
				
				/* Call the interrupt processing routine for each interrupt.			*/
				//Loren
				//printf("I am %d: calling wlan_hcf_interrupts_process 2.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				}
				FSM_PROFILE_SECTION_OUT (state2_exit_exec)


			/** state (TRANSMIT) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [TRANSMIT trans conditions]", state2_trans_conds)
			FSM_INIT_COND (TX_COMPLETE && !RESPONSE_EXPECTED)
			FSM_TEST_COND (TX_COMPLETE && RESPONSE_EXPECTED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("TRANSMIT")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 3, state3_enter_exec, ;, "TX_COMPLETE && !RESPONSE_EXPECTED", "", "TRANSMIT", "FRAME END", "tr_226", "wlan_mac_hcf [TRANSMIT -> FRAME END : TX_COMPLETE && !RESPONSE_EXPECTED / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "TX_COMPLETE && RESPONSE_EXPECTED", "", "TRANSMIT", "WAIT FOR RESPONSE", "tr_41", "wlan_mac_hcf [TRANSMIT -> WAIT FOR RESPONSE : TX_COMPLETE && RESPONSE_EXPECTED / ]")
				FSM_CASE_TRANSIT (2, 2, state2_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "TRANSMIT", "TRANSMIT", "tr_269", "wlan_mac_hcf [TRANSMIT -> TRANSMIT : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			/** state (FRAME END) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "FRAME END", state3_enter_exec, "wlan_mac_hcf [FRAME END enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [FRAME END enter execs]", state3_enter_exec)
				{
				/* The purpose of this state is to determine the next unforced		*/
				/* state after completing a transmission or scanning procedure.		*/
				/* This state is visited under the following conditions:			*/
				/* a) completing the transmission of a frame that doesn't require	*/
				/*    a response,													*/
				/* b) expiry of the timer for the response frame of our last		*/
				/*	  transmission,													*/
				/* c) reception of a frame from the physical layer following our	*/
				/*    last transmission, which required a response, and when the	*/
				/*    receiver is idle again, or									*/
				/* d) completing the scanning procedure as a result of getting		*/
				/*    connected with a new access point.							*/
				
				/* If we were performing a burst of transmissions in our TXOP, and	*/
				/* if it is over then reset the not_first_in_txop flag, which may	*/
				/* have set the during the burst.									*/
				if (fresp_to_send != WlanC_QoS_Data)
					{
					wlan_flags->not_first_in_txop = OPC_FALSE;
				
					/* Since reaching this line indicates completing a transmission	*/
					/* and also not continuing the current TXOP with another 		*/
					/* transmission, check whether there are any queued				*/
					/* disassociation information from x-member STAs that need to	*/
					/* be processed (this condition can be true only for APs).		*/
					for (i = op_prg_list_size (disassociating_sta_lptr); i > 0; i--)
						{
						sta_addr_ptr = (OpT_Int64 *) op_prg_list_remove (disassociating_sta_lptr, OPC_LISTPOS_HEAD);
						wlan_hcf_sta_disassociation_process (*sta_addr_ptr);
						op_prg_mem_free (sta_addr_ptr);
						}
					}
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (FRAME END) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "FRAME END", "wlan_mac_hcf [FRAME END exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [FRAME END exit execs]", state3_exit_exec)
				{
				
				}
				FSM_PROFILE_SECTION_OUT (state3_exit_exec)


			/** state (FRAME END) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [FRAME END trans conditions]", state3_trans_conds)
			FSM_INIT_COND (FRM_END_TO_IDLE)
			FSM_TEST_COND (RESPONSE_TO_SEND)
			FSM_TEST_COND (HL_FRAME_TO_SEND && MEDIUM_IS_IDLE && !RESPONSE_TO_SEND)
			FSM_TEST_COND (HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE)
			FSM_TEST_COND (AP_DISCONNECTED)
			FSM_TEST_LOGIC ("FRAME END")
			FSM_PROFILE_SECTION_OUT (state3_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ;, "FRM_END_TO_IDLE", "", "FRAME END", "IDLE", "tr_227", "wlan_mac_hcf [FRAME END -> IDLE : FRM_END_TO_IDLE / ]")
				FSM_CASE_TRANSIT (1, 7, state7_enter_exec, ;, "RESPONSE_TO_SEND", "", "FRAME END", "SIFS", "tr_32", "wlan_mac_hcf [FRAME END -> SIFS : RESPONSE_TO_SEND / ]")
				FSM_CASE_TRANSIT (2, 9, state9_enter_exec, ;, "HL_FRAME_TO_SEND && MEDIUM_IS_IDLE && !RESPONSE_TO_SEND", "", "FRAME END", "IFS and BACKOFF", "tr_36", "wlan_mac_hcf [FRAME END -> IFS and BACKOFF : HL_FRAME_TO_SEND && MEDIUM_IS_IDLE && !RESPONSE_TO_SEND / ]")
				FSM_CASE_TRANSIT (3, 8, state8_enter_exec, ;, "HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE", "", "FRAME END", "MEDIUM BUSY", "tr_42", "wlan_mac_hcf [FRAME END -> MEDIUM BUSY : HL_FRAME_TO_SEND && !MEDIUM_IS_IDLE / ]")
				FSM_CASE_TRANSIT (4, 6, state6_enter_exec, ;, "AP_DISCONNECTED", "", "FRAME END", "SCAN", "tr_46", "wlan_mac_hcf [FRAME END -> SCAN : AP_DISCONNECTED / ]")
				}
				/*---------------------------------------------------------*/



			/** state (WAIT FOR RESPONSE) enter executives **/
			FSM_STATE_ENTER_UNFORCED (4, "WAIT FOR RESPONSE", state4_enter_exec, "wlan_mac_hcf [WAIT FOR RESPONSE enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [WAIT FOR RESPONSE enter execs]", state4_enter_exec)
				{
				/* We enter into this state after completing the transmission of a	*/
				/* frame that requires a response, to wait for that response. We	*/
				/* will leave this state when one of two following events happen:	*/
				/* a) we receive a packet from the physical layer and the medium    */
				/*    becomes idle,                                                 */
				/* b) the timer set for the arrival of response frame expires.      */
				
				/* Make sure this is not a reentry into this state.					*/
				if (state_reentered == OPC_FALSE)
					{
					/* Schedule a self interrupt for the expiry of the response		*/
					/* frame timeout timer. The timer duration is equal to 			*/
					/* "EIFS - DIFS", which is SIFS + ACK transmission time with	*/
					/* PLCP header.													*/
					frame_timeout_evh = op_intrpt_schedule_self (current_time + eifs_time - difs_time, WlanC_Frame_Timeout);
				
					/* Update the state name information for debugging purposes.	*/
					if (debug_mode)
						{
						/* Determine the current state name.						*/
						strcpy (current_state_name, "WAIT FOR RESPONSE");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (9,"wlan_mac_hcf")


			/** state (WAIT FOR RESPONSE) exit executives **/
			FSM_STATE_EXIT_UNFORCED (4, "WAIT FOR RESPONSE", "wlan_mac_hcf [WAIT FOR RESPONSE exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [WAIT FOR RESPONSE exit execs]", state4_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* First store the values of the bad packet and bad CTS-to-self		*/
				/* received flags since their values are needed for the state		*/
				/* transition and the call of the function wlan_interrupts_process()*/
				/* below may reset these flags.										*/
				bad_packet_rcvd      = wlan_flags->rcvd_bad_packet;
				bad_cts_to_self_rcvd = wlan_flags->rcvd_bad_cts;
				
				/* Determine the interrupt type and the stream index in the case of	*/
				/* stream interrupt, since this information will be	in the next if	*/
				/* statement condition.												*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					i_strm = op_intrpt_strm ();
				
				/* Clear the frame timeout interrupt once the receiver is busy or	*/
				/* the frame is received (in case of collisions, the frames whose	*/
				/* reception has started while we were transmitting are excluded in	*/
				/* the FRAME_RCVD macro).											*/
				if (((intrpt_type == OPC_INTRPT_STAT && op_intrpt_stat () < TRANSMITTER_BUSY_INSTAT && 
					  op_stat_local_read (op_intrpt_stat ()) > rx_power_threshold && !wlan_flags->receiver_busy) ||
					 FRAME_RCVD) &&
					(op_ev_valid (frame_timeout_evh) == OPC_TRUE))
					{
					op_ev_cancel (frame_timeout_evh);
					}
				
				/* Call the interrupt processing routine for each interrupt			*/
				/* request.															*/
				//*Loren
				//printf("I am %d: Calling wlan_hcf_interrupts_process 3.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				
				/* Set the flag for state transition, if we received a bad CTS-to-	*/
				/* self at this invocation. If the flag "rcvd_bad_cts" is cleared	*/
				/* at this interrupt, then this is the case.						*/
				bad_cts_to_self_rcvd = bad_cts_to_self_rcvd ^ wlan_flags->rcvd_bad_cts;
				
				/* If expected frame is not received in the set duration or the		*/
				/* there is a collision at the receiver then set the expected frame	*/
				/* type to be none because the station needs to	retransmit the		*/
				/* frame.									 						*/
				if (intrpt_type == OPC_INTRPT_SELF && intrpt_code == WlanC_Frame_Timeout)
					{
					/* Setting expected frame type to none frame.					*/
					expected_frame_type = WlanC_None;
					
					/* Set the flag that indicates collision.						*/
					wlan_flags->wait_eifs_dur = OPC_TRUE;
					
					/* Increment the appropriate retransmission count. If our RTS	*/
					/* transmission or data transmission whose size	is smaller than	*/
					/* RTS/CTS threshold has failed, then increment short retry		*/
					/* count; otherwise increment the long retry count.				*/
					if (last_tx_frtype_arr [cur_tx_ac] == WlanC_Rts || !(wlan_ac_flags->frsize_req_rts & WLANC_AC_BITMAP_ARRAY [cur_tx_ac]))
						src_arr [cur_tx_ac] += 1;
					else
						lrc_arr [cur_tx_ac] += 1;
					
					/* Also reset the rts_sent flag since we need to recontend for	*/
					/* the medium.													*/
					wlan_flags->rts_sent = OPC_FALSE;
					
					/* Check whether further retries are possible or the data frame	*/
					/* needs to be discarded.										*/
					wlan_hcf_frame_discard (cur_tx_ac);
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state4_exit_exec)


			/** state (WAIT FOR RESPONSE) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [WAIT FOR RESPONSE trans conditions]", state4_trans_conds)
			FSM_INIT_COND (FRAME_TIMEOUT || FRAME_RCVD)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("WAIT FOR RESPONSE")
			FSM_PROFILE_SECTION_OUT (state4_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 3, state3_enter_exec, ;, "FRAME_TIMEOUT || FRAME_RCVD", "", "WAIT FOR RESPONSE", "FRAME END", "tr_249", "wlan_mac_hcf [WAIT FOR RESPONSE -> FRAME END : FRAME_TIMEOUT || FRAME_RCVD / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "WAIT FOR RESPONSE", "WAIT FOR RESPONSE", "tr_265", "wlan_mac_hcf [WAIT FOR RESPONSE -> WAIT FOR RESPONSE : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			/** state (BSS INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED (5, "BSS INIT", state5_enter_exec, "wlan_mac_hcf [BSS INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [BSS INIT enter execs]", state5_enter_exec)
				{
				/* Schedule a self interrupt to wait for mac interface 	*/
				/* to move to next state after registering				*/
				op_intrpt_schedule_self (op_sim_time (), 0);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"wlan_mac_hcf")


			/** state (BSS INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "BSS INIT", "wlan_mac_hcf [BSS INIT exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [BSS INIT exit execs]", state5_exit_exec)
				{
				
				/* Obtain the values assigned to the various attributes				*/
				op_ima_obj_attr_get (my_objid, "Wireless LAN Parameters", &wlan_params_comp_attr_objid);
				params_attr_objid = op_topo_child (wlan_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
				
				/* Determining the final MAC address after address resolution.		*/
				op_ima_obj_attr_get (my_objid, "Address", &integer_mac_address);
				my_address = integer_mac_address;
				
				
				//mohammad
				if(myDebugFlag)
					{
					sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
					MyExcecutionTrace = fopen(MyExcecutionTracename,"w");
					
					fprintf(MyExcecutionTrace,"Time %f node %d is initializing\n",(double)op_sim_time(),(int)my_address);
					fclose(MyExcecutionTrace);
					}
				
				if(myStringDebug)
						{
						sprintf(myString,"I am  %d:i am initializing",(int)my_address);
						op_prg_odb_print_major(myString,OPC_NIL);
						}
				//end mohammad
				
				
				/* Update our own process registery record with the final address	*/
				/* information.														*/
				oms_pr_attr_set (own_process_record_handle, "address", OMSC_PR_INT64, my_address, OPC_NIL);                                       
				
				/* Destroy the global list of BSS IDs that was used while assigning	*/
				/* channels to BSSs.												*/
				wlan_bss_id_list_manage (bss_id, phy_type, "destroy_list");
				
				/* Since the frequency band of the channels of all radio nodes are	*/
				/* determined, refresh our potential receiver group to exclude the	*/
				/* receiver channels that have non-overlapping bands with ours,		*/
				/* which we can't reach and interfere, to improve simulation		*/
				/* performance.														*/
				wlan_rxgroup_reduce (txch_objid, phy_char_flag, roam_state_ptr);
				
				/* Create the pool of station addresses of the same BSS using BSS	*/
				/* ID information.													*/
				wlan_hcf_sta_addr_register (bss_id, my_address, ap_flag, my_objid, phy_char_flag);
				
				/* Get a handle to the information record of our own BSS, which		*/
				/* also contains the STA list of our BSS.							*/
				my_bss_info_ptr = wlan_bss_info_get (bss_id);
				
				/* If we are operating in a bridge/switch node, indicate that our	*/
				/* address is not a valid destination address, since the station	*/
				/* models may choose their destination addresses randomly from the	*/
				/* address pool.													*/
				if (wlan_flags->bridge_flag)
					oms_aa_dest_status_set (oms_aa_handle, (int) my_address, OmsC_Aa_Invalid_Destination);
				
				/* Search for the other WLAN MACs that are in the same LAN with us.	*/
				proc_record_handle_list_ptr = op_prg_list_create ();
				
				/* If the subnet is BSS based then do the process discovery using	*/
				/* BSS ID (domain_id), otherwise do it using subnet ID.				*/
				if (bss_id_type == WlanC_Bss_Divided_Subnet)
					{
				    oms_pr_process_discover (OPC_OBJID_INVALID, proc_record_handle_list_ptr, 
					  "domain_id",			OMSC_PR_NUMBER,  		 (double) bss_id,
					  "mac_type",			OMSC_PR_STRING,	 		 "wireless_lan",
					  "protocol",			OMSC_PR_STRING,			 "mac",
					   OPC_NIL);
				    }
				else
					{
					oms_pr_process_discover (OPC_OBJID_INVALID, proc_record_handle_list_ptr, 
					  "subnetid",			OMSC_PR_OBJID,			 my_subnet_objid,
					  "mac_type",			OMSC_PR_STRING,			"wireless_lan",
					  "protocol",			OMSC_PR_STRING,			"mac",
				 	   OPC_NIL);
					}
				
				/* Find out the number of WLAN MACs belonging to our BSS, including	*/
				/* this MAC.														*/
				
				
				
				record_handle_list_size = op_prg_list_size (proc_record_handle_list_ptr);
				
				
				current_lambda = record_handle_list_size / 2.0;
				//nodes_no = record_handle_list_size -1;
				if(ap_flag== OPC_BOOLINT_ENABLED)
					{
					
					sprintf(myString,"I am  %d:cascade name is %s",(int)my_address,cascade_name);
					op_prg_odb_print_major(myString,OPC_NIL);
					cascade = (CvHaarClassifierCascade*)cvLoad( cascade_name, 0, 0, 0 );
					storage = cvCreateMemStorage(0);
					
					if(!cascade)
						op_sim_end("Could not load cascade","","","");
					
					peerStreamData = (double*)calloc (record_handle_list_size,sizeof(double));
					totalPeerStreamData = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamDataRate = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamAccuracy = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamDistortion = (double*)calloc (record_handle_list_size,sizeof(double));
					accuracyCalculationCounter= (int*)calloc (record_handle_list_size,sizeof(int));
					trimmedAccuracyCounter= (int*)calloc (record_handle_list_size,sizeof(int));
					frameSizeOfNode = (double*)calloc (record_handle_list_size,sizeof(double));
					last_DataRate_reset_time = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamAccuracyError= (double*)calloc (record_handle_list_size,sizeof(double));
					
					peerStreamDataForRate2 = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamDataForRate = (double*)calloc (record_handle_list_size,sizeof(double));
					
					peerStreamData2 = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamDataRate2 = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamAccuracy2 = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamDistortion2 = (double*)calloc (record_handle_list_size,sizeof(double));
					peerStreamAccuracyError2= (double*)calloc (record_handle_list_size,sizeof(double));
					accuracyCalculationCounter2= (int*)calloc (record_handle_list_size,sizeof(int));
					trimmedAccuracyCounter2= (int*)calloc (record_handle_list_size,sizeof(int));
					totalPeerStreamData2 = (double*)calloc (record_handle_list_size,sizeof(double));
					totalPeerStreamData2 = (double*)calloc (record_handle_list_size,sizeof(double));
					last_DataRate_reset_time2 = (double*)calloc (record_handle_list_size,sizeof(double));
					
					packetCounter = (int*)calloc (record_handle_list_size,sizeof(int));
					lastPacketN = (int*)calloc (record_handle_list_size,sizeof(int));
					lastFrameN = (int*)calloc (record_handle_list_size,sizeof(int));
					lastFrameSizeInPackets=(int*)calloc (record_handle_list_size,sizeof(int));
					lastImageLineNumber = (int*)calloc (record_handle_list_size,sizeof(int));
					lastQ = (int*)calloc (record_handle_list_size,sizeof(int));
					totalDataResetedFalgArray = (int*)calloc (record_handle_list_size,sizeof(int));
					
					start_times = (double*)calloc (record_handle_list_size,sizeof(double));
					
					
					completeFrames = (int*)calloc (record_handle_list_size,sizeof(int));
					missedFrames = (int*)calloc (record_handle_list_size,sizeof(int));
					incompleteFrames=(int*)calloc (record_handle_list_size,sizeof(int));
					concealedFrames = (int*)calloc (record_handle_list_size,sizeof(int));
					totalFrames = (int*)calloc (record_handle_list_size,sizeof(int));
					
					}
				
				if(myDebugFlag)
					{
					sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
					MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					fprintf(MyExcecutionTrace,"Time %f %d nodes found in network\n",op_sim_time(),record_handle_list_size);
					fprintf(MyExcecutionTrace,"Time %f current_lambda is initialized with %f\n",op_sim_time(),current_lambda);
					fclose(MyExcecutionTrace);
					}
				
				if(myStringDebug)
					{
						sprintf(myString,"I am  %d: %d nodes found in network, current_lambda is initialized with %f",(int)my_address,(int)record_handle_list_size,current_lambda);
						op_prg_odb_print_major(myString,OPC_NIL);
					}
				//end Mohammad
				
				/* Initialize the address list index to zero.						*/
				addr_index = 0; 
				
				
				/* Variable to counting number of access point in the network.		*/
				ap_count = 0;
				
				/* Create the binary Hash table that will be used to access the		*/
				/* information record of other STAs in our BSS. Set the table size	*/
				/* to approximately twice of the number of STAs in the BSS.			*/
				if (record_handle_list_size <= 2)
					peer_info_hash_tbl = prg_bin_hash_table_create (2, sizeof (OpT_Int64));
				else
					peer_info_hash_tbl = prg_bin_hash_table_create ((int) floor (log (record_handle_list_size * 1.5) / log (2.0)) + 1, sizeof (OpT_Int64));
				
				/* First assume that there is no QAP in the BSS or it doesn't		*/
				/* support block-ACK.												*/
				ap_ba_support = OPC_FALSE;
				
				/* Traversing the process record handle list to determine if there	*/
				/* is any access point in the subnet and to collect information		*/
				/* about other STAs in our BSS.										*/
				
				//sum = 0;
				for (i = 0; i < record_handle_list_size; i++ )
					{
					int stationIphusicalRate;
					
					//mohammad: initialize dataRate array
					if(ap_flag== OPC_BOOLINT_ENABLED)
						{
						totalPeerStreamData[i] = 0;
						peerStreamData[i] = 0;
						peerStreamDataRate[i]= 0;
						peerStreamAccuracy[i]= 0;
						peerStreamDistortion[i] = 0;
						accuracyCalculationCounter[i] = 0;
						trimmedAccuracyCounter[i] = 0;
						frameSizeOfNode[i] = 800000;
						last_DataRate_reset_time[i] = 0;
						peerStreamAccuracyError[i] = 0;
						
						peerStreamDataForRate[i] = 0;
						peerStreamDataForRate2[i] = 0;
						
						peerStreamData2[i] = 0;
						peerStreamDataRate2[i]= 0;
						peerStreamAccuracy2[i]= 0;
						peerStreamDistortion2[i] = 0;
						peerStreamAccuracyError2[i] = 0;
						accuracyCalculationCounter2[i] = 0;
						trimmedAccuracyCounter2[i] = 0;
						last_DataRate_reset_time2[i] = 0;
						packetCounter[i]=0;
						
						lastPacketN[i] = 1000000;
						lastFrameN[i] = -1;
						lastFrameSizeInPackets[i] = 0;
						lastImageLineNumber[i]= -1;
						lostPacketsCounter[i] = 0;
						lastQ[i] = 0;
						
						totalDataResetedFalgArray[i]=0;
						dropping[i]=0;
						
						completeFrames[i]=0;
						missedFrames[i]=0;
						incompleteFrames[i]=0;
						concealedFrames[i]=0;
						totalFrames[i]=0;
								
						
						}
						
						
					/* Obtain a handle on the process record.						*/
					process_record_handle = (OmsT_Pr_Handle) op_prg_list_access (proc_record_handle_list_ptr, i);
				
					/* Get the station type.										*/
					oms_pr_attr_get (process_record_handle, "subprotocol", OMSC_PR_INT32, &statype);
				
					/* Obtain the MAC address of the STA. Read the value of the		*/
					/* corresponding attribute to make sure that we get the final	*/
					/* value.														*/
					oms_pr_attr_get (process_record_handle, "module objid", OMSC_PR_OBJID, &mac_objid);
					op_ima_obj_attr_get (mac_objid, "Address", &integer_mac_address);
					sta_addr = integer_mac_address;
					
					/* If the station is an Access Point then its station id will	*/
					/* be a BSS id for all the station in that subnet.				*/
					if (statype == WlanC_QAP || statype == WlanC_AP)
						{
						/* If access point found then it means that it is a			*/
						/* Infrastructured BSS.										*/
						bss_flag = OPC_TRUE;
					
						/* Record the station address of the access point.			*/
						ap_mac_address = sta_addr;
						if(myDebugFlag)
							{
							sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							fprintf(MyExcecutionTrace,"Time %f station %d is the AP of this BSS\n",op_sim_time(),sta_addr);
							fclose(MyExcecutionTrace);
							}
						
						/* According to IEEE 802.11 there cannot be more than one	*/
						/* access point in the same BSS.							*/
				   		ap_count = ap_count + 1;
						if (ap_count == 2)
							{
							sprintf(msg1,"More than one Access Point found within the same BSS (BSS ID = %d)" , bss_id);
							wlan_error_print (msg1,"or in the same OPNET subnet.","Check the configuration.");
							}		 
				
						/* Save position information of the connected AP for		*/
						/* "virtual" roaming.										*/ 
						if (ap_flag == OPC_BOOLINT_DISABLED)
							oms_pr_attr_get (process_record_handle, "position record", OMSC_PR_POINTER, &conn_ap_pos_info_ptr);	 
				
						/* If we are a part of an nQBSS, then we need to turn off	*/
						/* all the QSTA procedures and access mechanism.			*/
						if (statype == WlanC_AP)
							{
							wlan_flags->nqsta_operation = OPC_TRUE;
							
							/* We will use the "best effort" AC to buffer the		*/
							/* higher layer packets with DCF access parameters.		*/
							cwmin_arr [WlanC_AC_BE] = phy_cw_min;
							cwmax_arr [WlanC_AC_BE] = phy_cw_max;
							txop_limit_arr [WlanC_AC_BE] = 0.0;
							
							/* AIFS becomes DIFS, hence AIFSN becomes two slots.	*/
							aifsn_arr [WlanC_AC_BE] = 2;
							aifs_arr [WlanC_AC_BE]  = difs_time;
							}
						}
					    
					/* Checking the physical characteristic configuration for the	*/
					/* subnet. Obtain the values assigned to the various attributes.*/
					op_ima_obj_attr_get (mac_objid, "Wireless LAN Parameters", &wlan_params_comp_attr_objid);
					params_attr_objid = op_topo_child (wlan_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
				
					/* Load the appropriate physical layer characteristics.			*/	
					op_ima_obj_attr_get (params_attr_objid, "Physical Characteristics", &sta_phy_char_flag);
				
					/* If we support block ACK and connected to a QAP, then check	*/
					/* whether also QAP supports block ACK operation.				*/ 
					if (wlan_flags->ba_support == OPC_TRUE && statype == WlanC_QAP)
						oms_pr_attr_get (process_record_handle, "Block ACK capability", OMSC_PR_INT32, &ap_ba_support);
					
					/* Store the physical layer technology used by the AP, which we may need	*/
					/* below.																	*/
					if (statype == WlanC_QAP || statype == WlanC_AP)
						ap_phy_char_flag = sta_phy_char_flag;
					
					/* Mismatching physical layer technologies within the same BSS are not		*/
					/* allowed.																	*/
					if (sta_phy_char_flag != phy_char_flag)
						{
						/* With one exception: 11g and 11/11b-DSSS STAs can coexist in the same	*/
						/* BSS.																	*/
						
						/* If we are an 11g STA, then set the non_erp_present flag if there are	*/
						/* some non-ERP (11/11b) STAs in our (I)BSS.							*/
						if (phy_char_flag == WlanC_ERP_OFDM_11g && sta_phy_char_flag == WlanC_Direct_Sequence)
							wlan_flags->non_erp_present = OPC_TRUE;
				
						/* Terminate the simulation unless it is the exception case.			*/
						else if (phy_char_flag != WlanC_Direct_Sequence || sta_phy_char_flag != WlanC_ERP_OFDM_11g)
							{
							wlan_error_print ("Physical Characteristic configuration mismatch in WLAN BSS. All stations in the same BSS (in",
								              "the same subnet if BSS IDs are auto-assigned) should have the same physical characteristics",
										      "(exception: Direct Sequence and ERP stations can coexist). Check the configuration.");
							}
						}	
					
					/* If we belong to an IBSS or we are a QAP, create an information record	*/
					/* for each STA in our BSS.													*/
					if (ap_flag == OPC_BOOLINT_ENABLED || bss_flag == OPC_FALSE)
						{
						peer_info_ptr = (WlanT_HCF_Peer_Info *) op_prg_mem_alloc (sizeof (WlanT_HCF_Peer_Info));
					
						/* Record whether the peer STA supports QoS facilities (11e) and		*/
						/* Extended Rate PHY (11g).												*/
						oms_pr_attr_get (process_record_handle, "QoS support", OMSC_PR_INT32, &(peer_info_ptr->is_qsta));
						peer_info_ptr->is_erp = (sta_phy_char_flag == WlanC_ERP_OFDM_11g) ? OPC_TRUE : OPC_FALSE; 
						
						/* Initialize the last received frame sequence ID information, which	*/
						/* will be used for duplicate detection.								*/
						peer_info_ptr->seq_cntl = 0xFFFF;
				
						/* If the peer is a QSTA, then we need a sequence counter and last 		*/
						/* received sequence control information also maintained separately for	*/
						/* each TID.															*/
						if (peer_info_ptr->is_qsta == OPC_TRUE)
							{
							peer_info_ptr->tid_seq_counter_arr   = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
							peer_info_ptr->tid_rcvd_seq_cntl_arr = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
							for (j = 0; j < WLANC_HCF_TC_COUNT; j++)
								{
								peer_info_ptr->tid_seq_counter_arr [j]   = 0;
								peer_info_ptr->tid_rcvd_seq_cntl_arr [j] = 0xFFFF;
								}
							}
						
						/* If the peer is 11e capable and if we support block ACKs, then check	*/
						/* whether it supports block ACKs.										*/
						if (wlan_flags->ba_support == OPC_TRUE && peer_info_ptr->is_qsta == OPC_TRUE)
							oms_pr_attr_get (process_record_handle, "Block ACK capability", OMSC_PR_INT32, &(peer_info_ptr->ba_support));
						else
							peer_info_ptr->ba_support = OPC_FALSE;
						
						/* We will create peer BA state information when BA is actually active	*/
						/* at least for one TID.												*/
						peer_info_ptr->ba_state_ptr_arr = OPC_NIL;
						
						
						if(myDebugFlag)
						{
							sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							fprintf(MyExcecutionTrace,"Time %f My variables are being added to hash table for station %d; this means that i am either an AP or i am in adhoc network\n",op_sim_time(),sta_addr);
							fclose(MyExcecutionTrace);
						}
						
						/*
						if((int) sta_addr !=0)//read initial physical rate for station sta_addr
							{
							
							FILE* dataRatesInputFile;
							char tempInputLine[20];
							char dataRatesInputFileName[200];
				
							sprintf(dataRatesInputFileName,"C:/opnetInputFiles/node%d.txt",(int)sta_addr);
						
							dataRatesInputFile = fopen(dataRatesInputFileName,"r");
						
							if(dataRatesInputFile != NULL)
								{
								sprintf(myString,"I am  %d:input file input file was opened successfuly for read",(int)my_address);
								op_prg_odb_print_major(myString,OPC_NIL);
							
								}
							else
								{
								sprintf(myString,"I am  %d:input file input file was opened INsuccessfuly for read",(int)my_address);
								op_prg_odb_print_major(myString,OPC_NIL);
								
								}
				
							fgets(tempInputLine, 10,dataRatesInputFile); //read and discard first line in the file 
									
							fgets(tempInputLine, 10,dataRatesInputFile);//read phusical rate for station sta_addr
							stationIphusicalRate=atoi(tempInputLine);
								
						
							fclose(dataRatesInputFile);
							}*/
						if((int) sta_addr !=0)//read initial physical rate for station sta_addr
											{
											
											FILE* dataRatesInputFile;
											char tempInputLine[20];
											char dataRatesInputFileName[200];
								
											sprintf(dataRatesInputFileName,"C:/opnetInputFiles/%d/node%d_ph.txt",nodes_no,(int)sta_addr);
										
											dataRatesInputFile = fopen(dataRatesInputFileName,"r");
										
											if(dataRatesInputFile != NULL)
												{
												sprintf(myString,"I am  %d:input file input file was opened successfuly for read",(int)my_address);
												op_prg_odb_print_major(myString,OPC_NIL);
											
												}
											else
												{
												sprintf(myString,"I am  %d:input file input file was opened INsuccessfuly for read",(int)my_address);
												op_prg_odb_print_major(myString,OPC_NIL);
												
												}
								
											fgets(tempInputLine, 10,dataRatesInputFile); //read and discard first line in the file 
													
											fgets(tempInputLine, 10,dataRatesInputFile);//read phusical rate for station sta_addr
											stationIphusicalRate=atoi(tempInputLine);
												
										
											fclose(dataRatesInputFile);
											}
						
						if((int) sta_addr !=0 )  //Read importance input file
							{
							FILE * importanceFile;
							char importanceFileName[500];
							char tempInputLine[20];
				
							sprintf(importanceFileName,"C:/opnetInputFiles/%d/node%d_importance.txt",nodes_no,(int) sta_addr);
				
							importanceFile = fopen(importanceFileName,"r");
					
						
							if(importanceFile != NULL)
								{
						
								sprintf(myString,"I am  %d:input file input file was opened successfuly for read",(int)my_address);
								op_prg_odb_print_major(myString,OPC_NIL);
								}
						
							else
								{
								sprintf(myString,"I am  %d:input file input file was opened INsuccessfuly for read",(int)my_address);
								op_prg_odb_print_major(myString,OPC_NIL);
								}
							
							fgets(tempInputLine, 10,importanceFile);  
							importance = atof(tempInputLine);
				
							fclose(importanceFile);
					
							}	
						
								
						//add my variables for each entry in hash table
						peer_info_ptr -> peer_addr 				= sta_addr;
						peer_info_ptr -> peer_a 				= accuracyConstant_a;
						peer_info_ptr -> peer_b 				= accuracyConstant_b;
						peer_info_ptr -> peer_c 				= accuracyConstant_c;
						peer_info_ptr -> peer_importance		= importance;//
						peer_info_ptr -> peer_physicalRate 		= stationIphusicalRate;
						peer_info_ptr -> peer_frameRate 		= frameRate;
						peer_info_ptr -> peer_averageProtocolOverhead		= 0;
						peer_info_ptr -> peer_droppedBRate = 0;
						peer_info_ptr -> peer_droppedRRate = 0;
						peer_info_ptr -> peer_TXOP = 0.003;
						peer_info_ptr -> peer_appRate = appRateBits;
						
						
						if(myStringDebug)
						{
						sprintf(myString,"I am  %d:data of %d is being inserted to the hash table",(int)my_address,(int)sta_addr);
						op_prg_odb_print_major(myString,OPC_NIL);
						}
						
						
						/* Insert the record into our local binary Hash table for quick access.	*/
						prg_bin_hash_table_item_insert (peer_info_hash_tbl, (void *) &sta_addr, peer_info_ptr, &dummy_ptr);
						
						//sprintf(myString,"I am  %d:importance of %d is initialized to %f\n",(int)my_address,(int)sta_addr, peer_info_ptr -> peer_importance);
						}
					//if (statype != WlanC_QAP && statype != WlanC_AP)
					
					//	sum += accuracyConstant_a * accuracyConstant_b * importance * 
					//	pow((double)frameRate/(importance * accuracyConstant_a * accuracyConstant_b * physicalRate),
					//	accuracyConstant_b/(accuracyConstant_b-1.0));
					}
				
				
				//initialize LAMBDA
				//current_lambda = exp((accuracyConstant_b - 1.0) * log((double)(1.0/( 1.0 + (2.0*(record_handle_list_size-1)/(double)(cwmin_arr [WlanC_AC_VI]+ 2.0))*pow(1-2.0/cwmin_arr [WlanC_AC_VI],record_handle_list_size-2)))/sum));
				
				
				/* Do we belong to an IBSS or infrastructure BSS?								*/
				if (bss_flag == OPC_TRUE)
					{
					/* Write our BSS ID into the AP connectivity statistic since we belong to	*/
					/* an infrastructure BSS.													*/
					op_stat_write (ap_conn_handle, bss_id);
					
					if(myDebugFlag)
						{
						sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
						MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
					
						fprintf(MyExcecutionTrace,"Time %f I am in infrastructure network\n",op_sim_time());
						fclose(MyExcecutionTrace);
						}
					
					/* If we are not the AP of the BSS, then we won't keep STA records.			*/
					if (ap_flag == OPC_BOOLINT_DISABLED)
						{
						
						if(myDebugFlag)
							{
							sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
							MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
							fprintf(MyExcecutionTrace,"Time %f I am not the AP; ap_peer_info is created\n",op_sim_time());
							fclose(MyExcecutionTrace);
							}
						
						prg_bin_hash_table_destroy (peer_info_hash_tbl, op_prg_mem_free);
						peer_info_hash_tbl = OPC_NIL;
						
						/* Instead just keep an information record of our AP, which we will use	*/
						/* for duplicate frame detection while receiving frames from it.		*/
						ap_peer_info_ptr = (WlanT_HCF_Peer_Info *) op_prg_mem_alloc (sizeof (WlanT_HCF_Peer_Info));
						ap_peer_info_ptr->is_qsta          = (wlan_flags->nqsta_operation == OPC_TRUE)           ? OPC_FALSE : OPC_TRUE;
						ap_peer_info_ptr->is_erp           = (ap_phy_char_flag            == WlanC_ERP_OFDM_11g) ? OPC_TRUE  : OPC_FALSE;
						ap_peer_info_ptr->ba_support       = ap_ba_support;
						ap_peer_info_ptr->ba_state_ptr_arr = OPC_NIL;
						ap_peer_info_ptr->seq_cntl         = 0xFFFF;
						
						
						
						/* If the AP is a QSTA, then we need a sequence counter and last 		*/
						/* received sequence control information also maintained separately for	*/
						/* each TID.															*/
						if (ap_peer_info_ptr->is_qsta == OPC_TRUE)
							{
							ap_peer_info_ptr->tid_seq_counter_arr   = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
							ap_peer_info_ptr->tid_rcvd_seq_cntl_arr = (OpT_uInt16 *) op_prg_mem_alloc (WLANC_HCF_TC_COUNT * sizeof (OpT_uInt16));
							for (j = 0; j < WLANC_HCF_TC_COUNT; j++)
								{
								ap_peer_info_ptr->tid_seq_counter_arr [j]   = 0;
								ap_peer_info_ptr->tid_rcvd_seq_cntl_arr [j] = 0xFFFF;
								}
							}
						
						/* We are a non-AP STA in a infrastructure BSS.							*/
						wlan_flags->ad_hoc_or_ap = OPC_FALSE;
						}
					else
						/* Set the flag that indicates either ad-hoc or AP operation.			*/
						wlan_flags->ad_hoc_or_ap = OPC_TRUE;
					}
				else
					{
					/* We belong to an independent (ad-hoc) BSS. No AP connectivity.			*/
					op_stat_write (ap_conn_handle, WLANC_AP_UNCONNECTED);
					wlan_flags->ad_hoc_or_ap = OPC_TRUE;
					
					if(myDebugFlag)
						{
						sprintf(MyExcecutionTracename,"C:\\opnetTraceFiles\\traceFile_node_%d.txt",my_address);
						MyExcecutionTrace = fopen(MyExcecutionTracename,"a");
						fprintf(MyExcecutionTrace,"Time %f I am in adhoc network; ap_peer_info is not created\n",op_sim_time());	
						fclose(MyExcecutionTrace);
						}
						
					
					/* Since there is at least one QSTA in our IBSS, which is us, it becomes a	*/
					/* QIBSS.																	*/
					my_bss_info_ptr->is_nqbss = OPC_FALSE;
					}
				
				/* Disable roaming if this MAC is actually an AP or if it belongs to an IBSS.	*/
				if (roam_state_ptr->enable_roaming && (ap_count == 0 || ap_flag == OPC_BOOLINT_ENABLED))
					{
					roam_state_ptr->enable_roaming = OPC_FALSE;
					
					/* Write a simulation log message to report this configuration change.	*/
					op_prg_log_entry_write (config_log_handle,
						"WARNING:\n"
						" Cannot enable roaming functionality at the Wireless LAN MAC\n"
						" layer. Roaming cannot be supported if the WLAN MAC itself is\n"
						" actually an access point, or if it is configured to belong\n"
						" to an independent (ad-hoc) WLAN.\n"
						"\n"
						" If you like the MAC layer of this node to execute roaming\n"
						" procedures and switch access points when available and\n"
						" necessary, then reconfigure the WLAN parameters on this\n"
						" node and/or on the other WLAN nodes of its LAN so that\n"
						" none of the conditions above is correct.\n");	
					}
				
				/* Even if enabled, disable the roaming if the surrounding node is fixed,	*/
				/* all the parent subnets are fixed and the beacon efficiency mode is		*/
				/* enabled, which assumes that the APs are not changing the locations. In	*/
				/* other words, there is no need to run roaming functions if the distance	*/
				/* between our node and any AP in the network will not change.				*/
				else if (roam_state_ptr->enable_roaming && op_id_to_type (my_node_objid) == OPC_OBJTYPE_NDFIX &&
						 BEACON_TX_EFFICIENCY_ENABLED)
					{
					/* Make sure all the parent subnets are also fixed.	Disable the roaming	*/
					/* and enable it back if one of the parent subnets is not fixed.		*/
					parent_subnet_objid = my_subnet_objid;
					roam_state_ptr->enable_roaming = OPC_FALSE;
					do
						{		
						if (op_id_to_type (parent_subnet_objid) != OPC_OBJTYPE_SUBNET_FIX)
							roam_state_ptr->enable_roaming = OPC_TRUE;
						
						/* Move to the parent subnet.										*/
						parent_subnet_objid = op_topo_parent (parent_subnet_objid);
						}
					while (!roam_state_ptr->enable_roaming && parent_subnet_objid != OPC_OBJID_NULL);
					}
				
				/* If we are an ERP STA (i.e. an 802.11g MAC), then we may need to change	*/
				/* some of our parameters due to other STAs in our BSS.						*/
				if (phy_type == WlanC_11g_PHY)
					{
					/* If we are operating in an ad-hoc WLAN or in a BSS with non-ERP STAs	*/
					/* then increase our slot time to 20 usec and recompute the frame		*/
					/* spacing parameters, which depend on slot time and SIFS.				*/
					if (bss_flag == OPC_FALSE || wlan_flags->non_erp_present == OPC_TRUE)
						{
						wlan_hcf_slot_time_set (20E-06);
						}
					
					/* Check the existence of non-ERP STAs.									*/
					if (wlan_flags->non_erp_present)
						{
						/* Reduce the control frame data rate to 802.11/11b mandatory data	*/
						/* rate.															*/
						control_data_rate = WLANC_11b_MIN_MANDATORY_DRATE;
						
						/* Increase the minimum contention window size unless we are in a	*/
						/* BSS with an AP and our AP supports ERP data rates.				*/
						if (ap_flag == OPC_BOOLINT_DISABLED)
							{
							if (!bss_flag || ap_peer_info_ptr->is_erp == OPC_FALSE)
								{
								phy_cw_min = 31;
							
								/* Adjust the actual CWmin and/or CWmax values used by each	*/
								/* access category if any of them is derived from the PHY	*/
								/* CWmin value.												*/
								if (wlan_ac_flags->std_cwmin || wlan_ac_flags->std_cwmax)
									wlan_hcf_cw_values_adjust ();
								}
						
							/* If our AP doesn't support 11g data rates, then, if			*/
							/* necessary, lower our data transmission rate to the highest	*/
							/* possible 11b	rate so that the AP can decode our				*/
							/* transmissions.												*/
							if (bss_flag && ap_peer_info_ptr->is_erp == OPC_FALSE)
								{
								if (data_tx_rate >= 11000000.0)
									operational_speed = 11000000.0;
								else if (data_tx_rate > 5500000.0)
									operational_speed = 5500000.0;
								}
							}
						}
					}
				
				/* Deallocate memory used for process discovery	*/
				while (op_prg_list_size (proc_record_handle_list_ptr))
					{
					op_prg_list_remove (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
					}
				op_prg_mem_free (proc_record_handle_list_ptr);
				
				/* Obtain the MAC layer information for the local MAC	*/
				/* process from the model-wide registry.				*/
				/* This is to check if the node is a gateway or not.	*/
				proc_record_handle_list_ptr = op_prg_list_create ();
				
				oms_pr_process_discover (OPC_OBJID_INVALID, proc_record_handle_list_ptr, 
					"node objid",					OMSC_PR_OBJID,			 my_node_objid,
					"gateway node",					OMSC_PR_STRING,			"gateway",
				 	 OPC_NIL);
				
				/* If the MAC interface process registered itself,	*/
				/* then there must be a valid match					*/
				record_handle_list_size = op_prg_list_size (proc_record_handle_list_ptr);
				
				if (record_handle_list_size != 0)
					{
					wlan_flags->gateway_flag = OPC_TRUE;
					}
				
				/* Deallocate memory used for process discovery.	*/
				while (op_prg_list_size (proc_record_handle_list_ptr))
					{
					op_prg_list_remove (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
					}
				op_prg_mem_free (proc_record_handle_list_ptr);
				
				/* To enable roaming, all APs must send Beacons. 	*/
				if (ap_flag == OPC_BOOLINT_ENABLED && beacon_tx_count == WLANC_PERIODIC_BEACON_TX)
					{
					/* Schedule a self interrupt to kick off the Beacon timer.	*/
					beacon_tx_time = beacon_int;
					op_intrpt_schedule_self (beacon_tx_time, WlanC_Beacon_Tx_Time);
					
					/* Initialize the remaining beacon transmission count for	*/
					/* continuous periodic transmissions.						*/
					rem_beacon_tx = WLANC_PERIODIC_BEACON_TX;
					}
				
				/* If the beacon efficiency mode is on, we will scan the best AP based on the distance. */
				if (BEACON_TX_EFFICIENCY_ENABLED)
					{
					if (roam_state_ptr->enable_roaming == OPC_TRUE)
						{
						/* Set the scan_type to distance based since beacon efficiency is on. */
						roam_state_ptr->scan_type = WlanC_Scan_Type_Distance;
						if (op_ima_sim_attr_exists ("WLAN AP Connectivity Check Interval"))
							{
							op_ima_sim_attr_get (OPC_IMA_DOUBLE, "WLAN AP Connectivity Check Interval", &ap_connectivity_check_interval);
							}
						else
							{
							/* Use the default for now and issue a warning. */
							ap_connectivity_check_interval = WLANC_CONN_CHK_DIST_INTERVAL;
							op_sim_message ("WLAN MAC Roaming", "Cannot access sim attribute \"WLAN AP Connectivity Check Interval\".");
							}
				
						ap_connectivity_check_time = ap_connectivity_check_interval;
						}
					
					if (ap_flag == OPC_BOOLINT_ENABLED)
						{
						/* Insert the AP location information in the global list. */
						wlan_ap_position_publish (conn_ap_pos_info_ptr);
						}
					}
				
				/* Create the mutex that will be used to serialize the accessing of roaming	*/
				/* information between the receiver's power stage and MAC. Since each MAC-	*/
				/* receiver pair will have its own mutex, include the MAC's address in the	*/
				/* name of the mutex.														*/
				sprintf (name_str, "MAC "OPC_INT64_FMT" Roaming Info Mutex", my_address);
				roam_state_ptr->roam_info_mutex = op_prg_mt_mutex_create (OPC_MT_MUTEX_NO_OPTIONS, 0, name_str);
				
				/* Lock the mutex. It will be locked at the beginning of exit execs, and	*/
				/* unlocked at the end of enter execs, of each unforced state excluding the	*/
				/* initialization states.													*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				//(mohammad) this code is to start the state report timer and to star sending state reports.
				
				if(strcmp(tempBnadwidth_allocation_method,"EDCA")==0 || strcmp(tempBnadwidth_allocation_method,"dist_withoutAnyEnhancement")==0)
					transitionTime=10;
				
				
				
				
				if(strcmp(bnadwidth_allocation_method,"matlabOptimization_accu") != 0 && strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD") != 0
					&& strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")!=0 &&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")!=0
					
					//strcmp(bnadwidth_allocation_method,"matlabOptimization_accu") != 0 && strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD") != 0
					//&& strcmp(bnadwidth_allocation_method,"matlabOptimization_dist")!=0 &&strcmp(bnadwidth_allocation_method,"matlabOptimization_wdist")!=0
					
					)
					{
					//If we are not access point, set interrupt to send a state report 	
					if (ap_flag == OPC_BOOLINT_DISABLED && strcmp(bnadwidth_allocation_method,"EDCA")!=0 && strcmp(bnadwidth_allocation_method,"app_only")!=0&& strcmp(bnadwidth_allocation_method,"link_only")!=0)
						{
						//Schedule a self interrupt to kick off the state report timer.	
						stateReport_tx_time = op_sim_time() + op_dist_uniform((int)stateReport_int);
						op_intrpt_schedule_self (stateReport_tx_time, WlanC_StateReport_Tx_Time);
						
						stateReportStarted = 1;
						
						if(myStringDebug)
							{
						sprintf(myString,"I am  %d:bnadwidth_allocation_method is %s, next state report will be sent at %f",(int)my_address,bnadwidth_allocation_method,(float)stateReport_tx_time);
						op_prg_odb_print_major(myString,OPC_NIL);
						}
					
						}
					}
				
				else
					{//set interebt for access point to perform optimization and for nodes to ubdate thier information
					op_intrpt_schedule_self (op_sim_time() + op_dist_uniform(1), WlanC_matlabOptimization);
					if(myStringDebug)
					{
						sprintf(myString,"I am  %d:bnadwidth_allocation_method is %s, interept is set to either update data or do optimization",(int)my_address,bnadwidth_allocation_method,(float)stateReport_tx_time);
						op_prg_odb_print_major(myString,OPC_NIL);
					}
					
					}
					
				
				}
				FSM_PROFILE_SECTION_OUT (state5_exit_exec)


			/** state (BSS INIT) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "BSS INIT", "IDLE", "tr_293", "wlan_mac_hcf [BSS INIT -> IDLE : default / ]")
				/*---------------------------------------------------------*/



			/** state (SCAN) enter executives **/
			FSM_STATE_ENTER_UNFORCED (6, "SCAN", state6_enter_exec, "wlan_mac_hcf [SCAN enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SCAN enter execs]", state6_enter_exec)
				{
				/* We enter into this state when we lose our connectivity with our	*/
				/* current AP to look for a new AP by scanning the operational WLAN	*/
				/* transmission channels. Only the WLAN MACs whose roaming			*/
				/* capability is enabled will evaluate their current APs, and may	*/
				/* enter into this state.											*/
				
				/* Make sure this is not a reentry into this state.					*/
				if (state_reentered == OPC_FALSE)
					{
					/* Initiate the scanning procedure.								*/
					wlan_hcf_begin_new_scan ();
				
					/* Set the flag indicating the ongoing scanning procedure.		*/
					wlan_flags->scanning = OPC_TRUE;
					
					/* Since we are deassociated from our AP, reset the flag that	*/
					/* have been set if we were using the EDCA Parameter Set		*/
					/* advertised by that AP and revert back to our own				*/
					/* configuration for EDCA parameters. Do this if beacon			*/
					/* efficiency mode is enabled; otherwise we will wait until the	*/
					/* beacons of our new AP.										*/
					if (roam_state_ptr->scan_type == WlanC_Scan_Type_Distance)
						{
						wlan_flags->edca_params_updated = OPC_FALSE;
						wlan_hcf_edca_parameter_set_read (own_ac_edca_params_objid);
						}
						
					/* Record the state name for debugging purposes.				*/
					if (debug_mode)
						{
						strcpy (current_state_name, "SCAN");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (13,"wlan_mac_hcf")


			/** state (SCAN) exit executives **/
			FSM_STATE_EXIT_UNFORCED (6, "SCAN", "wlan_mac_hcf [SCAN exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SCAN exit execs]", state6_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Interrupt processing routine.									*/
				//*Loren
				//printf("I am %d: Calling wlan_hcf_interrupts_process 4.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				
				/* Check whether the self interrupt set for the expiry of the scan	*/
				/* period is delivered.												*/
				if (intrpt_type == OPC_INTRPT_SELF && intrpt_code == WlanC_Scan_Timeout)
					{
					switch (roam_state_ptr->scan_type)
						{
						case WlanC_Scan_Type_Distance:
							{
							/* Attempt to find a new access point based on actual	*/
							/* distances.											*/
							wlan_hcf_find_new_ap_virtual ();
							break;
							}
						case WlanC_Scan_Type_Beacon:
							{
							/* Check whether the AP of the current channel was		*/
							/* reliable during the last evaluation (scan) period.	*/
							if (roam_state_ptr->ap_reliability == WLANC_AP_RELIABLE)
								{
								/* The STA has found a connection to a reliable AP 	*/
								/* Stop scanning to stay with this new AP.			*/
								roam_state_ptr->scan_mode = OPC_FALSE;
								}
							break;
							}
						default:
							{
							break;
							}
						}
				
					/* A new AP has been found, associate with the new AP.			*/
					if (roam_state_ptr->scan_mode == OPC_FALSE)
						{
						/* Reset state variables like nav_duration, rcv_idle_time	*/
						/* etc. 													*/
						wlan_hcf_sv_reset ();
				
						/* Set the AP Connectivity stat to to the BSS ID of the new	*/
						/* AP since we are now connected with an AP again.			*/
						op_stat_write (ap_conn_handle, eval_bss_id);
					
						/* Deassociate with the old AP and associate with the new	*/
						/* AP, unless we moved back to the same AP.					*/
						if (eval_bss_id != bss_id)
							wlan_hcf_ap_switch ();
				
						/* Write a debug message if enabled.						*/
						if (wlan_trace_active == OPC_TRUE)
							{
							sprintf (msg1, "STA connected to AP with BSS ID %d.", bss_id);
							op_prg_odb_print_major (msg1, OPC_NIL, OPC_NIL);
							}
						
						/* Reset the related flag since scanning is complete.		*/
						wlan_flags->scanning = OPC_FALSE;		
						}
					
					/* If a connection could not be established in the current		*/
					/* channel continue scanning by switching to a new channel.		*/
					else
						{
						wlan_hcf_begin_new_scan ();
						}
					}
				}
				FSM_PROFILE_SECTION_OUT (state6_exit_exec)


			/** state (SCAN) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SCAN trans conditions]", state6_trans_conds)
			FSM_INIT_COND (AP_CONNECTED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("SCAN")
			FSM_PROFILE_SECTION_OUT (state6_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 3, state3_enter_exec, ;, "AP_CONNECTED", "", "SCAN", "FRAME END", "tr_45", "wlan_mac_hcf [SCAN -> FRAME END : AP_CONNECTED / ]")
				FSM_CASE_TRANSIT (1, 6, state6_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "SCAN", "SCAN", "tr_305", "wlan_mac_hcf [SCAN -> SCAN : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			/** state (SIFS) enter executives **/
			FSM_STATE_ENTER_UNFORCED (7, "SIFS", state7_enter_exec, "wlan_mac_hcf [SIFS enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SIFS enter execs]", state7_enter_exec)
				{
				/* We enter into this state when we have a response frame to send.	*/
				/* For any type of response frame, the interframe spacing is SIFS.	*/
				/* So wait for a SIFS period before starting the transmission.		*/
				
				/* Make sure we didn't reenter into this state, which can happen	*/
				/* when a higher layer packet arrives.								*/
				if (state_reentered == OPC_FALSE)
					{
					/* Schedule a self interrupt for the end of SIFS period.		*/
					fresp_ifs_evh = op_intrpt_schedule_self (rcv_idle_time + sifs_time, WlanC_End_Of_SIFS);
				
					/* Record the state name for debugging purposes.				*/
					if (debug_mode)
						{
						strcpy (current_state_name, "SIFS");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state7_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (15,"wlan_mac_hcf")


			/** state (SIFS) exit executives **/
			FSM_STATE_EXIT_UNFORCED (7, "SIFS", "wlan_mac_hcf [SIFS exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SIFS exit execs]", state7_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Interrupt processing routine.									*/
				//*Loren
				//printf("I am %d: Calling wlan_hcf_interrupts_process 5.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				}
				FSM_PROFILE_SECTION_OUT (state7_exit_exec)


			/** state (SIFS) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [SIFS trans conditions]", state7_trans_conds)
			FSM_INIT_COND (END_OF_SIFS)
			FSM_TEST_COND (!MEDIUM_IS_IDLE)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("SIFS")
			FSM_PROFILE_SECTION_OUT (state7_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "END_OF_SIFS", "", "SIFS", "TRANSMIT", "tr_28", "wlan_mac_hcf [SIFS -> TRANSMIT : END_OF_SIFS / ]")
				FSM_CASE_TRANSIT (1, 8, state8_enter_exec, ;, "!MEDIUM_IS_IDLE", "", "SIFS", "MEDIUM BUSY", "tr_29", "wlan_mac_hcf [SIFS -> MEDIUM BUSY : !MEDIUM_IS_IDLE / ]")
				FSM_CASE_TRANSIT (2, 7, state7_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "SIFS", "SIFS", "tr_27", "wlan_mac_hcf [SIFS -> SIFS : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			/** state (MEDIUM BUSY) enter executives **/
			FSM_STATE_ENTER_UNFORCED (8, "MEDIUM BUSY", state8_enter_exec, "wlan_mac_hcf [MEDIUM BUSY enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [MEDIUM BUSY enter execs]", state8_enter_exec)
				{
				/* If we enter into this state if we have a frame to send (either	*/
				/* a packet of higher layer, a management frame or a response		*/
				/* response frame) and the medium is currently busy. We will leave	*/
				/* this state when both physical and virtual carrier sensing		*/
				/* indicate that the medium is idle.								*/
				
				/* Make sure this is not a reentry into this state.					*/
				if (state_reentered == OPC_FALSE)
					{
					/* If the NAV duration is passed the current time, schedule a	*/
					/* self interrupt for the end of NAV duration.					*/
					if (nav_duration > current_time)
						nav_end_evh = op_intrpt_schedule_self (nav_duration, WlanC_End_Of_NAV);
				
					/* Reset the nav_updated flag, which may have set in the		*/
					/* previous state (like IDLE).									*/
					wlan_flags->nav_updated = OPC_FALSE;
					
					/* Reset the "response frame to send" information. If the		*/
					/* medium became busy while we are waiting for the SIFS period	*/
					/* to send our response, we won't send the response anymore,	*/
					/* since the frame sequence is ruined with this unexpected		*/
					/* activity on the medium.										*/
					fresp_to_send = WlanC_None;
					
					/* Record the state name for debugging purposes.				*/
					if (debug_mode)
						{
						strcpy (current_state_name, "MEDIUM BUSY");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state8_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (17,"wlan_mac_hcf")


			/** state (MEDIUM BUSY) exit executives **/
			FSM_STATE_EXIT_UNFORCED (8, "MEDIUM BUSY", "wlan_mac_hcf [MEDIUM BUSY exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [MEDIUM BUSY exit execs]", state8_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Call the interrupt processing routine for each interrupt.		*/
				///*Loren
				//printf("I am %d: Calling wlan_hcf_interrupts_process 6.\n", (int)my_address);
				
				wlan_hcf_interrupts_process ();
				
				/* If the receiver is not busy, we are not expecting a frame from	*/
				/* the physical layer, NAV duration is passed or equal to the 		*/
				/* current time and there is already an interrupt scheduled for the	*/
				/* end of NAV duration, then cancel it.								*/
				if (wlan_flags->receiver_busy == OPC_FALSE && wlan_flags->phy_pkt_expected == OPC_FALSE &&
					nav_duration <= current_time + PRECISION_RECOVERY && intrpt_type != OPC_INTRPT_SELF && op_ev_valid (nav_end_evh))
					op_ev_cancel (nav_end_evh);
				
				/* If we have a new NAV value then (re)schedule the end of NAV		*/
				/* interrupt.														*/
				if (wlan_flags->nav_updated == OPC_TRUE)
					{
					/* Cancel the current interrupt if any.							*/
					if (op_ev_valid (nav_end_evh))
						op_ev_cancel (nav_end_evh);
					
					/* Schedule the new one. Make sure that the new NAV value is in	*/
					/* future. This check is necessary since some received frames	*/
					/* like CF-End or CF-End+ACK can reset the NAV.					*/
					if (nav_duration > current_time + PRECISION_RECOVERY)
						nav_end_evh = op_intrpt_schedule_self (nav_duration, WlanC_End_Of_NAV);
					
					/* Reset the flag.												*/
					wlan_flags->nav_updated = OPC_FALSE;
					}
				}
				FSM_PROFILE_SECTION_OUT (state8_exit_exec)


			/** state (MEDIUM BUSY) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [MEDIUM BUSY trans conditions]", state8_trans_conds)
			FSM_INIT_COND (MEDIUM_IS_IDLE && RESPONSE_TO_SEND)
			FSM_TEST_COND (MEDIUM_IS_IDLE && !RESPONSE_TO_SEND)
			FSM_TEST_COND (TX_QUEUE_FLUSHED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("MEDIUM BUSY")
			FSM_PROFILE_SECTION_OUT (state8_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 7, state7_enter_exec, ;, "MEDIUM_IS_IDLE && RESPONSE_TO_SEND", "", "MEDIUM BUSY", "SIFS", "tr_37", "wlan_mac_hcf [MEDIUM BUSY -> SIFS : MEDIUM_IS_IDLE && RESPONSE_TO_SEND / ]")
				FSM_CASE_TRANSIT (1, 9, state9_enter_exec, ;, "MEDIUM_IS_IDLE && !RESPONSE_TO_SEND", "", "MEDIUM BUSY", "IFS and BACKOFF", "tr_38", "wlan_mac_hcf [MEDIUM BUSY -> IFS and BACKOFF : MEDIUM_IS_IDLE && !RESPONSE_TO_SEND / ]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "TX_QUEUE_FLUSHED", "", "MEDIUM BUSY", "IDLE", "tr_31_0", "wlan_mac_hcf [MEDIUM BUSY -> IDLE : TX_QUEUE_FLUSHED / ]")
				FSM_CASE_TRANSIT (3, 8, state8_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "MEDIUM BUSY", "MEDIUM BUSY", "tr_40", "wlan_mac_hcf [MEDIUM BUSY -> MEDIUM BUSY : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			/** state (IFS and BACKOFF) enter executives **/
			FSM_STATE_ENTER_UNFORCED (9, "IFS and BACKOFF", state9_enter_exec, "wlan_mac_hcf [IFS and BACKOFF enter execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IFS and BACKOFF enter execs]", state9_enter_exec)
				{
				/* We enter into this state when we have a high layer or management	*/
				/* frame in at least one access category to send and/or we have a	*/
				/* contention window backoff (backoff after a successful			*/
				/* transmission) to perform, and the medium is idle. We will leave	*/
				/* this state when our deference (inter-frame spacing and backoff)	*/
				/* is complete or if the medium becomes busy.						*/
				
				
				
				
				
				
				
				/* Make sure this is not a reentry into this state.					*/
				if (state_reentered == OPC_FALSE)
					{
					/* Determine the AIFS and backoff durations and schedule an		*/
					/* interrupt for the end of it. If there are multiple access	*/
					/* categories contending then schedule the interrupt only for	*/
					/* the AC that will complete its deference first.				*/
					
					/* Initialize the temporary variables used to find out the		*/
					/* access category with the shortest backoff period.			*/
					min_backoff_slots = OPC_INT_INFINITY;
					max_cw_slots      = 0;
				
					/* Adjust the medium idle time, which is the current time, if	*/
					/* the EIFS flag is set (section 9.2.3.4).						*/
					if (wlan_flags->wait_eifs_dur == OPC_TRUE)
						{
						/* Adjust the idle time by "EIFS - DIFS" based on receiver	*/
						/* idle time. 												*/
						bk_medium_idle_time = rcv_idle_time + eifs_time - difs_time;
						
						/* Make sure that the EIFS flag is recent.					*/
						if (bk_medium_idle_time < MEDIUM_IDLE_TIME)
							bk_medium_idle_time = MEDIUM_IDLE_TIME;
						
						/* Reset the EIFS flag.										*/
						wlan_flags->wait_eifs_dur = OPC_FALSE;
						}
					else
						bk_medium_idle_time = MEDIUM_IDLE_TIME;
					
					/* Go over the list of the active access categories.			*/
					for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
						{
						/* Store the current AC in a temporary variable.			*/
						ac = ac_queue_status_arr [i];
						
						/* Is this a new backoff or a resumed backoff?				*/
						if (deference_info_arr [ac].backoff_slots == BACKOFF_SLOTS_UNSET)
							{
							/* A new backoff. Is it a retransmission?				*/
							if (src_arr [ac] + lrc_arr [ac] > 0)
								{
								/* This is a retransmission. Increase the CW size	*/
								/* unless it already reached its maximum size.		*/
								if (cw_arr [ac] < cwmax_arr [ac])
									cw_arr [ac] = cw_arr [ac] * 2 + 1;
								}
							else
								/* First trial. Hence, CW size equals to CWmin.		*/
								cw_arr [ac] = cwmin_arr [ac];
							
							/* Pick a random number of backoff slots from CW.		*/
							
							if(strcmp(bnadwidth_allocation_method,"EDCA")==0)
								deference_info_arr [ac].backoff_slots = (int) floor (op_dist_uniform (cw_arr [ac] + 1));// (mohammad)standard EDCA. should be changed to p-persistant
							else
								{
								geometricDis=op_dist_load("geometric",2.0/(cwmin_arr [ac]+2),0);
								deference_info_arr [ac].backoff_slots = (int) floor (op_dist_outcome (geometricDis));
								}
							
							//printf("AC = %d\n",ac);
							
							/* Update the dimensioned backoff slot statistic for	*/
							/* this ac.												*/
							//op_stat_write (ac_backoff_slots_shndl_arr [ac], (double) deference_info_arr [ac].backoff_slots);
							
							/* Write an ODB trace message if enabled.				*/
							if (wlan_trace_active)
								{
								sprintf (msg1, "Initiating a backoff period for AC %s for %d slots (CW size = %d slots).",
										 WLANC_AC_NAME_ARRAY [ac], deference_info_arr [ac].backoff_slots, cw_arr [ac]);
								op_prg_odb_print_major (msg1, OPC_NIL);
								}
							}
						
						/* We are resuming an already scheduled backoff. Write an	*/
						/* ODB trace message if enabled.							*/
						else if (wlan_trace_active)
							{
							sprintf (msg1, "Resuming backoff period for AC %s for the remaining %d slots.",
											WLANC_AC_NAME_ARRAY [ac], deference_info_arr [ac].backoff_slots);
							op_prg_odb_print_major (msg1, OPC_NIL);
							}
						
						/* Is the queue of the access category empty? If it is then	*/
						/* this backoff is just to complete a successful			*/
						/* transmission.											*/
						deference_info_arr [ac].type = (op_prg_list_size (hlpk_lptr_arr [ac]) == 0) ? WlanC_CW_Elapsed : WlanC_Backoff_Elapsed;
						
						/* Find out the total number of slots in the deference		*/
						/* period.													*/
						ac_total_slots = aifsn_arr [ac] + deference_info_arr [ac].backoff_slots;
						
						/* Update the lowest/highest number of slots across the ACs	*/
						/* if necessary.											*/
						if (deference_info_arr [ac].type == WlanC_Backoff_Elapsed)
							{
							if (ac_total_slots < min_backoff_slots)
								{
								min_backoff_slots = ac_total_slots;
								min_backoff_ac    = ac;
								}
							}
						else
							{
							if (ac_total_slots > max_cw_slots)
								{
								max_cw_slots = ac_total_slots;
								max_cw_ac    = ac;
								}
							}
						}
				
					/* Schedule an end of deference interrupt for the access		*/
					/* category that has the shortest time when its AIFSN and		*/
					/* random backoff slots are added. In case of a tie, then pick	*/
					/* the AC with higher priority. We will schedule an interrupt	*/
					/* for a CW-backoff (backoff for ACs with empty queue, which is	*/
					/* performed due to the recent successful transmission) only if	*/
					/* there is not an AC performing a regular backoff. In that		*/
					/* case, schedule the interrupt for the longest CW-backoff so	*/
					/* that when the interrupt delivered, all the CW-backoff will	*/
					/* be complete, which will enable us to go back to the IDLE		*/
					/* state, unless we receive a packet from the higher layer		*/
					/* during the backoff period.									*/
					if (min_backoff_slots != OPC_INT_INFINITY)
						{
						backoff_ac  = min_backoff_ac;
						intrpt_time = bk_medium_idle_time + sifs_time + slot_time * min_backoff_slots;
						deference_info_arr [backoff_ac].deference_end_evh = op_intrpt_schedule_self (intrpt_time, WlanC_Backoff_Elapsed);
						}
					else
						{
						backoff_ac  = max_cw_ac;
						intrpt_time = bk_medium_idle_time + sifs_time + slot_time * max_cw_slots;
						deference_info_arr [backoff_ac].deference_end_evh = op_intrpt_schedule_self (intrpt_time, WlanC_CW_Elapsed);
						}
					
					/* Record the state name for debugging purposes.				*/
					if (debug_mode)
						{
						strcpy (current_state_name, "IFS and BACKOFF");
						}
					}
				
				/* Unlock the mutex that serializes accessing the roaming related	*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_unlock (roam_state_ptr->roam_info_mutex);
				}
				FSM_PROFILE_SECTION_OUT (state9_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (19,"wlan_mac_hcf")


			/** state (IFS and BACKOFF) exit executives **/
			FSM_STATE_EXIT_UNFORCED (9, "IFS and BACKOFF", "wlan_mac_hcf [IFS and BACKOFF exit execs]")
				FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IFS and BACKOFF exit execs]", state9_exit_exec)
				{
				/* Lock the mutex that serializes accessing the roaming related		*/
				/* information of this MAC. 										*/
				op_prg_mt_mutex_lock (roam_state_ptr->roam_info_mutex, 0);
				
				/* Call the interrupt processing routine for each interrupt.		*/
				//*Loren
				//printf("I am %d: Calling wlan_hcf_interrupts_process 7.\n", (int)my_address);
				
				new_hlpk_ac = wlan_hcf_interrupts_process ();
				
				/* If the receiver became busy then cancel the end-of-backoff		*/
				/* interrupt and compute the number of remaining slots for each		*/
				/* contending AC.													*/
				if (wlan_flags->receiver_busy == OPC_TRUE)
					{
					/* First check whether we are experiencing a special case: we	*/
					/* started receiving a transmission at the exact same time when	*/
					/* we will complete our backoff and start our own transmission.	*/
					/* In such cases we ignore the reception and continue with our	*/
					/* planned transmission for the accuracy of the simulation		*/
					/* model, because these two events are happening at the exact	*/
					/* same	time and their execution order should not change the	*/
					/* overall behavior of the MAC. Similarly, this will take us to	*/
					/* IDLE	state in the next interrupt, if the reception started	*/
					/* at the exact time when we would complete our CW period and	*/
					/* move	back to IDLE because of empty high layer buffer.		*/
					if (intrpt_time - PRECISION_RECOVERY <= current_time)
						{
						/* Set the flag indicating this special case.				*/
						wlan_flags->forced_bk_end = OPC_TRUE;
						}
					
					/* Suspend all ongoing backoff processes. Start by canceling	*/
					/* the end-of-deference interrupt.								*/
					op_ev_cancel (deference_info_arr [backoff_ac].deference_end_evh);
					
					/* Compute the remaining slot numbers for each active AC. If	*/
					/* the special case flag is set, then we will follow the same	*/
					/* computation that we would use when the end-of-deference		*/
					/* interrupt is delivered.										*/
					if (wlan_flags->forced_bk_end == OPC_FALSE)
						{
						wlan_hcf_suspended_backoff_remaining_slots_compute (WlanC_AC_None);
						}
					}
				
				/* If the AC with the shortest backoff period completed its backoff	*/
				/* then compute the remaining backoff slots for other ACs.			*/
				if	((intrpt_type == OPC_INTRPT_SELF        && intrpt_code == WlanC_Backoff_Elapsed)                          ||
					 (wlan_flags->forced_bk_end == OPC_TRUE && deference_info_arr [backoff_ac].type == WlanC_Backoff_Elapsed)   )
					{
					/* The winner of the contender performs the next transmission.	*/
					cur_tx_ac = backoff_ac;
					
					/* Find out the number of slots left for other contending ACs.	*/
					/* Pay attention to internal collision possibility.				*/
					slots_completed = deference_info_arr [backoff_ac].backoff_slots + aifsn_arr [backoff_ac];
					for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
						{
						/* Skip the winner AC.										*/
						ac = ac_queue_status_arr [i];
						if (ac != backoff_ac)
							{
							/* Compute the actual number of slots completed for		*/
							/* this AC.												*/
							ac_slots_completed = slots_completed - aifsn_arr [ac];
							
							/* Check for internal collision.						*/
							if (ac_slots_completed == deference_info_arr [ac].backoff_slots && deference_info_arr [ac].type == WlanC_Backoff_Elapsed)
								{
								/* This is an internal collision for the current	*/
								/* AC. Update the related statistic.				*/
								op_stat_write (ac_internal_coll_shndl_arr [ac], 1.0);
								
								/* Write an ODB trace message if enabled.			*/
								if (wlan_trace_active)
									{
									sprintf (msg1, "Internal collision experienced by AC %s.", WLANC_AC_NAME_ARRAY [ac]);
									op_prg_odb_print_major (msg1, OPC_NIL);
									}
								
								/* Since the backoff is complete, reset the slot	*/
								/* count.											*/
								deference_info_arr [ac].backoff_slots = BACKOFF_SLOTS_UNSET;
				
								/* Also reset the cw_required flag which may be	set.*/
								wlan_ac_flags->cw_required &= ~(WLANC_AC_BITMAP_ARRAY [ac]);
								
								/* Increment the short retry count of the AC.		*/
								src_arr [ac] += 1;
								
								/* Get the type information of the frame at the		*/
								/* head of the AC's queue to be used in the discard	*/
								/* function.										*/
								txframe_type = ((WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [ac], OPC_LISTPOS_HEAD))->type;
								
								/* Check whether the frame at the head of the AC's	*/
								/* queue needs to be discarded as a result of		*/
								/* reaching the retry limit.						*/
								wlan_hcf_frame_discard (ac);
								}
							
							/* If the remaining backoffs are negative or zero, then	*/
							/* this AC has empty queue and performing a CW-backoff.	*/
							else if (ac_slots_completed >= deference_info_arr [ac].backoff_slots)
								{
								/* CW-backoff is complete. Reset the slot count.	*/
								deference_info_arr [ac].backoff_slots = BACKOFF_SLOTS_UNSET;
								
								/* Reset the bit of this AC in the cw_required flag.*/
								wlan_ac_flags->cw_required ^= WLANC_AC_BITMAP_ARRAY [ac];
								
								/* Update the queue status array.					*/
								for (j = i; ac_queue_status_arr [j] != WlanC_AC_None; j++)
									ac_queue_status_arr [j] = ac_queue_status_arr [j + 1];
								
								/* Adjust the loop index for the next iteration		*/
								/* since we have removed one entry from the queue	*/
								/* status array.									*/
								i--;
								}
							
							/* The AC didn't complete any backoff slots if it was	*/
							/* still within its AIFS period.						*/
							else if (ac_slots_completed > 0)
								deference_info_arr [ac].backoff_slots -= ac_slots_completed;
							}
						else
							{
							/* Reset the backoff count of the winner AC.			*/
							deference_info_arr [ac].backoff_slots = BACKOFF_SLOTS_UNSET;
							
							/* If the connection with the AP is lost, then go to	*/
							/* SCAN state to start searching for a new AP, instead	*/
							/* of initiating a new transmission sequence. To enfore	*/
							/* this state transition, overwrite the interrupt code.	*/
							if (roam_state_ptr->scan_mode == OPC_TRUE && (wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [ac]))
								intrpt_code = WlanC_CW_Elapsed;
							
							/* Similarly reset the cw_required flag which may be	*/
							/* set.													*/
							wlan_ac_flags->cw_required &= ~(WLANC_AC_BITMAP_ARRAY [ac]);
							}
						}
					}
				
				/* If this is an interrupt indicating the completion of a			*/
				/* CW-backoff, then all the AC queue are empty and all the required	*/
				/* backoff are completed.											*/
				else if ((intrpt_type == OPC_INTRPT_SELF        && intrpt_code == WlanC_CW_Elapsed)                          ||
						 (wlan_flags->forced_bk_end == OPC_TRUE && deference_info_arr [backoff_ac].type == WlanC_CW_Elapsed)   )
					{
					/* Reset the cw_required flag and the queue status array.		*/
					wlan_ac_flags->cw_required = 0;
					for (i = 0; ac_queue_status_arr [i] != WlanC_AC_None; i++)
						{
						/* Also update the deference record to indicate that the	*/
						/* backoff is complete.										*/
						deference_info_arr [ac_queue_status_arr [i]].backoff_slots = BACKOFF_SLOTS_UNSET;
						ac_queue_status_arr [i] = WlanC_AC_None;
						}
					}
				
				/* If there is a new AC joining the contention, then first check	*/
				/* whether it can perform a transmission without any backoff. If	*/
				/* not, then compute its deference duration and reschedule the		*/
				/* end-of-backoff interrupt if the new AC has the shortest 			*/
				/* deference duration. Since arrival of a new data packet may also	*/
				/* trigger enqueuing of a management frame for transmission, we		*/
				/* need to check the value of immediate_xmt flag. When it is set,	*/
				/* that means the "end of backoff" interrupt is already cancelled,	*/
				/* because we also have a new MMPDU to send and it can be sent		*/
				/* immediately due to inactivity on the medium.						*/
				else if (new_hlpk_ac != WlanC_AC_None && op_prg_list_size (hlpk_lptr_arr [new_hlpk_ac]) == 1 && 
						 wlan_flags->immediate_xmt == OPC_FALSE)
					{
					wlan_hcf_new_ac_to_contention_add (new_hlpk_ac);
					}
				}
				FSM_PROFILE_SECTION_OUT (state9_exit_exec)


			/** state (IFS and BACKOFF) transition processing **/
			FSM_PROFILE_SECTION_IN ("wlan_mac_hcf [IFS and BACKOFF trans conditions]", state9_trans_conds)
			FSM_INIT_COND (SUSPENDED_BACKOFF)
			FSM_TEST_COND (BACKOFF_COMPLETE)
			FSM_TEST_COND (CW_BACKOFF_COMPLETE)
			FSM_TEST_COND (SCAN_AFTER_CW)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("IFS and BACKOFF")
			FSM_PROFILE_SECTION_OUT (state9_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 8, state8_enter_exec, ;, "SUSPENDED_BACKOFF", "", "IFS and BACKOFF", "MEDIUM BUSY", "tr_30", "wlan_mac_hcf [IFS and BACKOFF -> MEDIUM BUSY : SUSPENDED_BACKOFF / ]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "BACKOFF_COMPLETE", "", "IFS and BACKOFF", "TRANSMIT", "tr_34", "wlan_mac_hcf [IFS and BACKOFF -> TRANSMIT : BACKOFF_COMPLETE / ]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "CW_BACKOFF_COMPLETE", "", "IFS and BACKOFF", "IDLE", "tr_35", "wlan_mac_hcf [IFS and BACKOFF -> IDLE : CW_BACKOFF_COMPLETE / ]")
				FSM_CASE_TRANSIT (3, 6, state6_enter_exec, ;, "SCAN_AFTER_CW", "", "IFS and BACKOFF", "SCAN", "tr_44", "wlan_mac_hcf [IFS and BACKOFF -> SCAN : SCAN_AFTER_CW / ]")
				FSM_CASE_TRANSIT (4, 9, state9_enter_exec, SET_REENTRY;, "default", "SET_REENTRY", "IFS and BACKOFF", "IFS and BACKOFF", "tr_39", "wlan_mac_hcf [IFS and BACKOFF -> IFS and BACKOFF : default / SET_REENTRY]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wlan_mac_hcf")
		}
	catch (...)
		{
		Vos_Error_Print (VOSC_ERROR_ABORT,
			(const char *)VOSC_NIL,
			"Unhandled C++ exception in process model (wlan_mac_hcf)",
			(const char *)VOSC_NIL, (const char *)VOSC_NIL);
		}
	}




void
wlan_mac_hcf_state::_op_wlan_mac_hcf_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
#if defined (OPD_ALLOW_ODB)
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = __LINE__+1;
#endif

	FIN_MT (wlan_mac_hcf_state::_op_wlan_mac_hcf_diag ())

	try
		{

		/* Diagnostic Block */

		BINIT
		int					i, j;
		int					queue_size [WLANC_HCF_AC_COUNT];
		WlanT_HCF_Hld_Info*	hld_ptr;
		Boolean				pkt_in_tx = OPC_FALSE;
		char				frame_type_name [32];
		
		/* Introduce the MAC process.				*/
		printf ("\n--- QSTA with MAC Address "OPC_INT64_FMT" ---\n\n\n", my_address);
		
		/* Print the current state of the MAC.		*/
		printf ("Current state name: %s\n\n\n", current_state_name);
		
		/* Print the buffer usage report.		 	*/
		printf ("Printing higher layer packet buffer status report:\n");
		printf ("--------------------------------------------------\n\n");
		printf ("Total buffer usage: " OPC_PACKET_SIZE_FMT "/%d bits.\n\n", total_hlpk_size, hld_max_size);
		printf ("Packet listing of AC queues:\n");
		for (i = 0; i < WLANC_HCF_AC_COUNT; i++)
			{
			/* List the packets in the queue of		*/
			/* each access category.				*/
			queue_size [i] = op_prg_list_size (hlpk_lptr_arr [i]);
			printf ("\n%s:\n", WLANC_AC_NAME_ARRAY [i]);
			for (j = 0; j < queue_size [i]; j++)
				{
				/* Access the packet's record.		*/
				hld_ptr = (WlanT_HCF_Hld_Info *) op_prg_list_access (hlpk_lptr_arr [i], j);
				
				/* Print its ID.					*/
				if (hld_ptr->pkptr != OPC_NIL)
					printf ("ID: " OPC_PACKET_ID_FMT ", ", op_pk_id (hld_ptr->pkptr));
				else
					{
					printf ("ID: ******, ");
					pkt_in_tx = OPC_TRUE;			
					}
				
				/* Print the arrival time if		*/
				/* applicable, and frame type info.	*/
				wlan_frame_type_conv (hld_ptr->type, frame_type_name);
				if ((hld_ptr->type & ~(WLANC_QOS_DATA_BIT)) == WlanC_Data || hld_ptr->type == WlanC_Action || hld_ptr->type & WLANC_CONTROL_TYPE_BIT)
					printf ("Receive time: %.9f, Type: %s (%d)  ", hld_ptr->time_rcvd, frame_type_name, hld_ptr->type);
				else
					printf ("Receive time: N/A, Type: %s (%d)  ", frame_type_name, hld_ptr->type);
				
				/* Display the ACK policy.			*/
				switch (hld_ptr->ack_policy)
					{
					case WlanC_Normal_ACK      : printf ("ACK Policy: Normal ACK\n"); break;
					case WlanC_Block_ACK       : printf ("ACK Policy: Block ACK\n"); break;
					case WlanC_No_ACK          : printf ("ACK Policy: No ACK\n"); break;
					case WlanC_No_Explicit_ACK : printf ("ACK Policy: No Explicit ACK\n"); break;
					default                    : printf ("ACK Policy: Unset (Error!)\n");
					}
				}
			}
		
		/* Add the "transmitted packet" note if		*/
		/* necessary.								*/
		if (pkt_in_tx == OPC_TRUE)
			{
			printf ("\n*Note: Packet(s) whose IDs displayed as \"******\" are\n"); 
			printf ("either data or action frames currently being transmitted by their\n");
			printf ("ACs, or they are beacon, block-ACK request or block-ACK messages.\n");
			}
		
		/* Display the current values of various	*/
		/* flags used by the MAC model.				*/
		printf ("\n\nPrinting the values of some MAC model flags:\n");
		printf ("--------------------------------------------\n");
		printf ("receiver_busy   : %d\n", wlan_flags->receiver_busy);
		printf ("rts_sent        : %d\n", wlan_flags->rts_sent);
		printf ("tx_beacon       : %d\n", wlan_flags->tx_beacon);
		printf ("rcvd_bad_packet : %d\n", wlan_flags->rcvd_bad_packet);
		printf ("non_erp_present : %d\n", wlan_flags->non_erp_present);
		printf ("wait_eifs_dur   : %d\n", wlan_flags->wait_eifs_dur);
		printf ("nav_updated     : %d\n", wlan_flags->nav_updated);
		printf ("txop_on         : %d\n", wlan_flags->txop_on);
		printf ("scan_mode       : %d\n", roam_state_ptr->scan_mode);
		printf ("cts_to_self     : %d\n", wlan_flags->cts_to_self);
		printf ("\n\nPrinting the values of some MAC model state variables:\n");
		printf ("------------------------------------------------------\n");
		printf ("slot_time          : %.1f usec\n", slot_time * 1000000.0);
		printf ("SIFS               : %.1f usec\n", sifs_time * 1000000.0);
		printf ("DIFS               : %.1f usec\n", difs_time * 1000000.0);
		printf ("EIFS               : %.1f usec\n", eifs_time * 1000000.0);
		printf ("expected_frame_type: %d\n", expected_frame_type);
		printf ("fresp_to_send      : %d\n", fresp_to_send);
		printf ("rcv_idle_time      : %.8f\n", rcv_idle_time);
		printf ("nav_duration       : %.8f\n", nav_duration);
		
		/* Display access category parameters.	*/
		printf ("\n\nPrinting the values of some access category specific parameters and variables:\n");
		printf ("------------------------------------------------------------------------------\n\n");
		printf ("Parameter\\Category       Voice       Video    Best Effort Background\n");
		printf ("---------------------- ----------- ----------- ----------- ----------\n");
		printf ("Queue size                %4d        %4d        %4d        %4d\n",
			queue_size [WlanC_AC_VO], queue_size [WlanC_AC_VI], queue_size [WlanC_AC_BE], queue_size [WlanC_AC_BK]);
		printf ("CW Size                   %4d        %4d        %4d        %4d\n",
			cw_arr [WlanC_AC_VO], cw_arr [WlanC_AC_VI], cw_arr [WlanC_AC_BE], cw_arr [WlanC_AC_BK]);
		printf ("AIFSN                     %4d        %4d        %4d        %4d\n",
			aifsn_arr [WlanC_AC_VO], aifsn_arr [WlanC_AC_VI], aifsn_arr [WlanC_AC_BE], aifsn_arr [WlanC_AC_BK]);
		printf ("Backoff slots     ");
		for (i = WLANC_HCF_AC_COUNT - 1; i >= 0; i--)
			{
			if (deference_info_arr [i].backoff_slots == BACKOFF_SLOTS_UNSET)
				printf ("          --");
			else
				printf ("        %4d", deference_info_arr [i].backoff_slots);
			}
		printf ("\n");
		printf ("CW Required Flag          %4d        %4d        %4d        %4d\n",
			(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VO]) >> 3, (wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_VI]) >> 2,
			(wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BE]) >> 1, wlan_ac_flags->cw_required & WLANC_AC_BITMAP_ARRAY [WlanC_AC_BK]);
		printf ("Long/Short Retry Counts   %2d/%-2d       %2d/%-2d       %2d/%-2d       %2d/%-2d\n",
			lrc_arr [WlanC_AC_VO], src_arr [WlanC_AC_VO], lrc_arr [WlanC_AC_VI], src_arr [WlanC_AC_VI],
			lrc_arr [WlanC_AC_BE], src_arr [WlanC_AC_BE], lrc_arr [WlanC_AC_BK], src_arr [WlanC_AC_BK]);

		/* End of Diagnostic Block */

		}
	catch (...)
		{
		Vos_Error_Print (VOSC_ERROR_ABORT,
			(const char *)VOSC_NIL,
			"Unhandled C++ exception in process model (wlan_mac_hcf)",
			"In Diagnostic Block",
			(const char *)VOSC_NIL);
		}

	FOUT
#endif /* OPD_ALLOW_ODB */
	}

void
wlan_mac_hcf_state::operator delete (void* ptr)
	{
	FIN (wlan_mac_hcf_state::operator delete (ptr));
	Vos_Poolmem_Dealloc (ptr);
	FOUT
	}

wlan_mac_hcf_state::~wlan_mac_hcf_state (void)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = __LINE__;
#endif

	FIN (wlan_mac_hcf_state::~wlan_mac_hcf_state ())

	try
		{

		/* Termination Block */

		BINIT
		if(ap_flag == OPC_BOOLINT_ENABLED && (strcmp(bnadwidth_allocation_method,"matlabOptimization_accu")==0 || strcmp(bnadwidth_allocation_method,"matlabOptimization_accuD")==0))
			{
			free(fees);
			free(Y);
			free(D);
			free(T);
			free(W);
			free(TXOP);
			
		//	engClose(ep);
			}
		free(accuracyCalculationCounter);
		free(trimmedAccuracyCounter);
		free(peerStreamDataRate);
		free(peerStreamAccuracy);
		free(peerStreamDistortion);
		free(totalPeerStreamData);
		free(peerStreamData);
		free(frameSizeOfNode);
		free(peerStreamAccuracyError);
		free(last_DataRate_reset_time);
								
		
		free(MyExcecutionTracename);
			
		free(peerStreamData2);
		free(peerStreamDataRate2);
		free(peerStreamAccuracy2);
		free(peerStreamDistortion2);
		free(peerStreamAccuracyError2);
		free(accuracyCalculationCounter2);
		free(trimmedAccuracyCounter2);
		free(totalPeerStreamData2);
		free(last_DataRate_reset_time2);
		free(packetCounter);
		free(lastPacketN);
		free(lastFrameN);
		free(lastFrameSizeInPackets);

		/* End of Termination Block */

		}
	catch (...)
		{
		Vos_Error_Print (VOSC_ERROR_ABORT,
			(const char *)VOSC_NIL,
			"Unhandled C++ exception in process model (wlan_mac_hcf)",
			"In Termination Block",
			(const char *)VOSC_NIL);
		}

	FOUT
	}


#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

void *
wlan_mac_hcf_state::operator new (size_t)
#if defined (VOSD_NEW_BAD_ALLOC)
		throw (VOSD_BAD_ALLOC)
#endif
	{
	void * new_ptr;

	FIN_MT (wlan_mac_hcf_state::operator new ());

	new_ptr = Vos_Alloc_Object (wlan_mac_hcf_state::obtype);
#if defined (VOSD_NEW_BAD_ALLOC)
	if (new_ptr == VOSC_NIL) throw VOSD_BAD_ALLOC();
#endif
	FRET (new_ptr)
	}

/* State constructor initializes FSM handling */
/* by setting the initial state to the first */
/* block of code to enter. */

wlan_mac_hcf_state::wlan_mac_hcf_state (void) :
		_op_current_block (0)
	{
#if defined (OPD_ALLOW_ODB)
		_op_current_state = "wlan_mac_hcf [INIT enter execs]";
#endif
	}

VosT_Obtype
_op_wlan_mac_hcf_init (int * init_block_ptr)
	{
	FIN_MT (_op_wlan_mac_hcf_init (init_block_ptr))

	wlan_mac_hcf_state::obtype = Vos_Define_Object_Prstate ("proc state vars (wlan_mac_hcf)",
		sizeof (wlan_mac_hcf_state));
	*init_block_ptr = 0;

	FRET (wlan_mac_hcf_state::obtype)
	}

VosT_Address
_op_wlan_mac_hcf_alloc (VosT_Obtype, int)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wlan_mac_hcf_state * ptr;
	FIN_MT (_op_wlan_mac_hcf_alloc ())

	/* New instance will have FSM handling initialized */
#if defined (VOSD_NEW_BAD_ALLOC)
	try {
		ptr = new wlan_mac_hcf_state;
	} catch (const VOSD_BAD_ALLOC &) {
		ptr = VOSC_NIL;
	}
#else
	ptr = new wlan_mac_hcf_state;
#endif
	FRET ((VosT_Address)ptr)
	}



void
_op_wlan_mac_hcf_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wlan_mac_hcf_state		*prs_ptr;

	FIN_MT (_op_wlan_mac_hcf_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wlan_mac_hcf_state *)gen_ptr;

	if (strcmp ("a_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->a_stat);
		FOUT
		}
	if (strcmp ("ac_access_delay_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_access_delay_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_backoff_slots_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_backoff_slots_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_delay_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_delay_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_dropped_buffer_bits_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_dropped_buffer_bits_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_dropped_buffer_pkts_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_dropped_buffer_pkts_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_dropped_retx_bits_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_dropped_retx_bits_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_dropped_retx_pkts_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_dropped_retx_pkts_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_access_delay_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_access_delay_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_delay_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_delay_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_dropped_buffer_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_dropped_buffer_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_dropped_retx_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_dropped_retx_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_load_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_load_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_gb_throughput_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_gb_throughput_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_internal_coll_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_internal_coll_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_load_bits_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_load_bits_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_load_pkts_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_load_pkts_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_queue_size_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_queue_size_shndl_arr);
		FOUT
		}
	if (strcmp ("ac_queue_status_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_queue_status_arr);
		FOUT
		}
	if (strcmp ("ac_throughput_shndl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ac_throughput_shndl_arr);
		FOUT
		}
	if (strcmp ("accept_large_packets" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accept_large_packets);
		FOUT
		}
	if (strcmp ("accuracyCalculationCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accuracyCalculationCounter);
		FOUT
		}
	if (strcmp ("accuracyCalculationCounter2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accuracyCalculationCounter2);
		FOUT
		}
	if (strcmp ("accuracyConstant_a" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accuracyConstant_a);
		FOUT
		}
	if (strcmp ("accuracyConstant_b" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accuracyConstant_b);
		FOUT
		}
	if (strcmp ("accuracyConstant_c" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->accuracyConstant_c);
		FOUT
		}
	if (strcmp ("aifs_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->aifs_arr);
		FOUT
		}
	if (strcmp ("aifsn_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->aifsn_arr);
		FOUT
		}
	if (strcmp ("ap_conn_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_conn_handle);
		FOUT
		}
	if (strcmp ("ap_connectivity_check_evhndl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_connectivity_check_evhndl);
		FOUT
		}
	if (strcmp ("ap_connectivity_check_interval" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_connectivity_check_interval);
		FOUT
		}
	if (strcmp ("ap_connectivity_check_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_connectivity_check_time);
		FOUT
		}
	if (strcmp ("ap_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_flag);
		FOUT
		}
	if (strcmp ("AP_Lambda_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->AP_Lambda_stat);
		FOUT
		}
	if (strcmp ("ap_mac_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_mac_address);
		FOUT
		}
	if (strcmp ("ap_peer_info_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ap_peer_info_ptr);
		FOUT
		}
	if (strcmp ("appRateBits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->appRateBits);
		FOUT
		}
	if (strcmp ("average_accuracy" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->average_accuracy);
		FOUT
		}
	if (strcmp ("average_distortion" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->average_distortion);
		FOUT
		}
	if (strcmp ("average_stream_DataRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->average_stream_DataRate);
		FOUT
		}
	if (strcmp ("b_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->b_stat);
		FOUT
		}
	if (strcmp ("backoff_ac" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->backoff_ac);
		FOUT
		}
	if (strcmp ("backoff_elapsed_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->backoff_elapsed_evh);
		FOUT
		}
	if (strcmp ("beacon_int" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->beacon_int);
		FOUT
		}
	if (strcmp ("beacon_interval_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->beacon_interval_stat);
		FOUT
		}
	if (strcmp ("beacon_tx_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->beacon_tx_count);
		FOUT
		}
	if (strcmp ("beacon_tx_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->beacon_tx_time);
		FOUT
		}
	if (strcmp ("bits_load_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_load_handle);
		FOUT
		}
	if (strcmp ("bits_sent_in_the_last_TXOP" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_in_the_last_TXOP);
		FOUT
		}
	if (strcmp ("bk_medium_idle_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bk_medium_idle_time);
		FOUT
		}
	if (strcmp ("bss_edca_params_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bss_edca_params_arr);
		FOUT
		}
	if (strcmp ("bss_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bss_flag);
		FOUT
		}
	if (strcmp ("bss_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bss_id);
		FOUT
		}
	if (strcmp ("buffer_drop_bits_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->buffer_drop_bits_handle);
		FOUT
		}
	if (strcmp ("buffer_drop_pkts_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->buffer_drop_pkts_handle);
		FOUT
		}
	if (strcmp ("c_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->c_stat);
		FOUT
		}
	if (strcmp ("channel_bandwidth" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_bandwidth);
		FOUT
		}
	if (strcmp ("channel_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_count);
		FOUT
		}
	if (strcmp ("channel_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_num);
		FOUT
		}
	if (strcmp ("channel_spacing" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_spacing);
		FOUT
		}
	if (strcmp ("common_rsmbuf_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->common_rsmbuf_ptr);
		FOUT
		}
	if (strcmp ("common_seq_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->common_seq_count);
		FOUT
		}
	if (strcmp ("completeFrameRecievedFlag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->completeFrameRecievedFlag);
		FOUT
		}
	if (strcmp ("completeFrames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->completeFrames);
		FOUT
		}
	if (strcmp ("concealedFrames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->concealedFrames);
		FOUT
		}
	if (strcmp ("config_log_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->config_log_handle);
		FOUT
		}
	if (strcmp ("conn_ap_pos_info_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->conn_ap_pos_info_ptr);
		FOUT
		}
	if (strcmp ("control_data_rate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->control_data_rate);
		FOUT
		}
	if (strcmp ("ctrl_traffic_rcvd_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ctrl_traffic_rcvd_handle);
		FOUT
		}
	if (strcmp ("ctrl_traffic_rcvd_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ctrl_traffic_rcvd_handle_inbits);
		FOUT
		}
	if (strcmp ("ctrl_traffic_sent_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ctrl_traffic_sent_handle);
		FOUT
		}
	if (strcmp ("ctrl_traffic_sent_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ctrl_traffic_sent_handle_inbits);
		FOUT
		}
	if (strcmp ("cur_tx_ac" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cur_tx_ac);
		FOUT
		}
	if (strcmp ("current_lambda" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->current_lambda);
		FOUT
		}
	if (strcmp ("current_state_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->current_state_name);
		FOUT
		}
	if (strcmp ("current_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->current_time);
		FOUT
		}
	if (strcmp ("CVAccuracyA" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CVAccuracyA);
		FOUT
		}
	if (strcmp ("CVAccuracyC" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CVAccuracyC);
		FOUT
		}
	if (strcmp ("CVAccuracyI" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CVAccuracyI);
		FOUT
		}
	if (strcmp ("cw_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->cw_arr);
		FOUT
		}
	if (strcmp ("cwmax_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->cwmax_arr);
		FOUT
		}
	if (strcmp ("cwmin_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->cwmin_arr);
		FOUT
		}
	if (strcmp ("data_frames_sent_in_the_last_stateREport_int_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_frames_sent_in_the_last_stateREport_int_count);
		FOUT
		}
	if (strcmp ("data_frames_sent_in_the_last_stateREport_int_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_frames_sent_in_the_last_stateREport_int_count_stat);
		FOUT
		}
	if (strcmp ("data_packet_dropped" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_packet_dropped);
		FOUT
		}
	if (strcmp ("data_packet_droppedB_in_the_last_stateReport_int_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_packet_droppedB_in_the_last_stateReport_int_count);
		FOUT
		}
	if (strcmp ("data_packet_loaded_in_the_last_stateReport_int_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_packet_loaded_in_the_last_stateReport_int_count);
		FOUT
		}
	if (strcmp ("data_packet_sent_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_packet_sent_count);
		FOUT
		}
	if (strcmp ("data_packet_sent_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_packet_sent_count_stat);
		FOUT
		}
	if (strcmp ("data_traffic_rcvd_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_traffic_rcvd_handle);
		FOUT
		}
	if (strcmp ("data_traffic_rcvd_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_traffic_rcvd_handle_inbits);
		FOUT
		}
	if (strcmp ("data_traffic_sent_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_traffic_sent_handle);
		FOUT
		}
	if (strcmp ("data_traffic_sent_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_traffic_sent_handle_inbits);
		FOUT
		}
	if (strcmp ("data_tx_rate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_tx_rate);
		FOUT
		}
	if (strcmp ("dataRatePeriodCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->dataRatePeriodCounter);
		FOUT
		}
	if (strcmp ("debug_mode" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->debug_mode);
		FOUT
		}
	if (strcmp ("deference_info_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->deference_info_arr);
		FOUT
		}
	if (strcmp ("defragmentation_list_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->defragmentation_list_ptr);
		FOUT
		}
	if (strcmp ("difs_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->difs_time);
		FOUT
		}
	if (strcmp ("directoryName" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->directoryName);
		FOUT
		}
	if (strcmp ("disassociating_sta_lptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->disassociating_sta_lptr);
		FOUT
		}
	if (strcmp ("drop_pkt_entry_log_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->drop_pkt_entry_log_flag);
		FOUT
		}
	if (strcmp ("drop_pkt_log_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->drop_pkt_log_handle);
		FOUT
		}
	if (strcmp ("duplicate_entry" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->duplicate_entry);
		FOUT
		}
	if (strcmp ("EA_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->EA_stat);
		FOUT
		}
	if (strcmp ("EAcounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->EAcounter);
		FOUT
		}
	if (strcmp ("EAsum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->EAsum);
		FOUT
		}
	if (strcmp ("EDCA_last_DataRate_reset_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->EDCA_last_DataRate_reset_time);
		FOUT
		}
	if (strcmp ("eifs_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->eifs_time);
		FOUT
		}
	if (strcmp ("ete_delay_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_handle);
		FOUT
		}
	if (strcmp ("eval_bss_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->eval_bss_id);
		FOUT
		}
	if (strcmp ("expected_frame_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->expected_frame_type);
		FOUT
		}
	if (strcmp ("fee_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fee_stat);
		FOUT
		}
	if (strcmp ("first_chan_min_freq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->first_chan_min_freq);
		FOUT
		}
	if (strcmp ("frag_threshold" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frag_threshold);
		FOUT
		}
	if (strcmp ("fragmentation_buffer_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->fragmentation_buffer_arr);
		FOUT
		}
	if (strcmp ("frame_timeout_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frame_timeout_evh);
		FOUT
		}
	if (strcmp ("frameRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frameRate);
		FOUT
		}
	if (strcmp ("frameRate_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frameRate_stat);
		FOUT
		}
	if (strcmp ("frameRecievedFlag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frameRecievedFlag);
		FOUT
		}
	if (strcmp ("frameSizeOfNode" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->frameSizeOfNode);
		FOUT
		}
	if (strcmp ("fresp_ifs_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fresp_ifs_evh);
		FOUT
		}
	if (strcmp ("fresp_to_send" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->fresp_to_send);
		FOUT
		}
	if (strcmp ("global_buffer_drop_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_buffer_drop_handle);
		FOUT
		}
	if (strcmp ("global_ete_delay_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_ete_delay_handle);
		FOUT
		}
	if (strcmp ("global_load_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_load_handle);
		FOUT
		}
	if (strcmp ("global_mac_delay_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_mac_delay_handle);
		FOUT
		}
	if (strcmp ("global_network_load_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_network_load_handle);
		FOUT
		}
	if (strcmp ("global_retrans_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_retrans_handle);
		FOUT
		}
	if (strcmp ("global_retx_drop_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_retx_drop_handle);
		FOUT
		}
	if (strcmp ("global_throughput_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_throughput_handle);
		FOUT
		}
	if (strcmp ("hl_packets_rcvd" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hl_packets_rcvd);
		FOUT
		}
	if (strcmp ("hld_max_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hld_max_size);
		FOUT
		}
	if (strcmp ("hld_pmh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hld_pmh);
		FOUT
		}
	if (strcmp ("hlpk_lptr_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->hlpk_lptr_arr);
		FOUT
		}
	if (strcmp ("i_strm" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->i_strm);
		FOUT
		}
	if (strcmp ("imageName" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->imageName);
		FOUT
		}
	if (strcmp ("imageNo" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->imageNo);
		FOUT
		}
	if (strcmp ("importance" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->importance);
		FOUT
		}
	if (strcmp ("importance_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->importance_stat);
		FOUT
		}
	if (strcmp ("incompleteFrames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->incompleteFrames);
		FOUT
		}
	if (strcmp ("incrementCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->incrementCounter);
		FOUT
		}
	if (strcmp ("instrm_from_mac_if" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->instrm_from_mac_if);
		FOUT
		}
	if (strcmp ("intrpt_code" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_code);
		FOUT
		}
	if (strcmp ("intrpt_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_time);
		FOUT
		}
	if (strcmp ("intrpt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_type);
		FOUT
		}
	if (strcmp ("lambda_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lambda_stat);
		FOUT
		}
	if (strcmp ("last_calculated_average_TXOP_displasement" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_calculated_average_TXOP_displasement);
		FOUT
		}
	if (strcmp ("last_calculated_droppedB_prob" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_calculated_droppedB_prob);
		FOUT
		}
	if (strcmp ("last_DataRate_reset_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_DataRate_reset_time);
		FOUT
		}
	if (strcmp ("last_DataRate_reset_time2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_DataRate_reset_time2);
		FOUT
		}
	if (strcmp ("last_DataRate_reset_time_PERIODIC" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_DataRate_reset_time_PERIODIC);
		FOUT
		}
	if (strcmp ("last_my_droppedB_calculated_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_my_droppedB_calculated_time);
		FOUT
		}
	if (strcmp ("last_my_droppedR_calculated_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_my_droppedR_calculated_time);
		FOUT
		}
	if (strcmp ("last_my_load_calculated_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_my_load_calculated_time);
		FOUT
		}
	if (strcmp ("last_my_sent_calculated_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_my_sent_calculated_time);
		FOUT
		}
	if (strcmp ("last_rcvd_duration" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_rcvd_duration);
		FOUT
		}
	if (strcmp ("last_sent_averageProtocolOverhead" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_averageProtocolOverhead);
		FOUT
		}
	if (strcmp ("last_sent_droppedBRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_droppedBRate);
		FOUT
		}
	if (strcmp ("last_sent_droppedRRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_droppedRRate);
		FOUT
		}
	if (strcmp ("last_sent_loadRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_loadRate);
		FOUT
		}
	if (strcmp ("last_sent_physicalRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_physicalRate);
		FOUT
		}
	if (strcmp ("last_sent_protocolOverheadRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_protocolOverheadRate);
		FOUT
		}
	if (strcmp ("last_sent_sentRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_sentRate);
		FOUT
		}
	if (strcmp ("last_sent_video_frame_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_video_frame_size);
		FOUT
		}
	if (strcmp ("last_sent_video_frame_size_without_header" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_video_frame_size_without_header);
		FOUT
		}
	if (strcmp ("last_sent_video_frame_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_sent_video_frame_time);
		FOUT
		}
	if (strcmp ("last_tx_frtype_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->last_tx_frtype_arr);
		FOUT
		}
	if (strcmp ("last_TXOP_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_TXOP_start_time);
		FOUT
		}
	if (strcmp ("lastFrameN" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lastFrameN);
		FOUT
		}
	if (strcmp ("lastFrameSizeInPackets" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lastFrameSizeInPackets);
		FOUT
		}
	if (strcmp ("lastImageLineNumber" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lastImageLineNumber);
		FOUT
		}
	if (strcmp ("lastPacketN" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lastPacketN);
		FOUT
		}
	if (strcmp ("lastQ" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lastQ);
		FOUT
		}
	if (strcmp ("linesIndex" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->linesIndex);
		FOUT
		}
	if (strcmp ("llc_iciptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->llc_iciptr);
		FOUT
		}
	if (strcmp ("long_retry_limit" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->long_retry_limit);
		FOUT
		}
	if (strcmp ("LoopSum_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->LoopSum_stat);
		FOUT
		}
	if (strcmp ("lostPackets" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->lostPackets);
		FOUT
		}
	if (strcmp ("lostPacketsCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->lostPacketsCounter);
		FOUT
		}
	if (strcmp ("lrc_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->lrc_arr);
		FOUT
		}
	if (strcmp ("Ls" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Ls);
		FOUT
		}
	if (strcmp ("mac_appRate_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mac_appRate_stat);
		FOUT
		}
	if (strcmp ("mac_client_reassembly_buffer" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mac_client_reassembly_buffer);
		FOUT
		}
	if (strcmp ("mapping_info_mutex" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mapping_info_mutex);
		FOUT
		}
	if (strcmp ("max_frags_per_msdu" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_frags_per_msdu);
		FOUT
		}
	if (strcmp ("max_operational_speed" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_operational_speed);
		FOUT
		}
	if (strcmp ("max_operational_speed_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_operational_speed_stat);
		FOUT
		}
	if (strcmp ("max_receive_lifetime" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_receive_lifetime);
		FOUT
		}
	if (strcmp ("maxLoad" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->maxLoad);
		FOUT
		}
	if (strcmp ("maxLoad_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->maxLoad_stat);
		FOUT
		}
	if (strcmp ("media_access_delay" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->media_access_delay);
		FOUT
		}
	if (strcmp ("mgmt_retx_drop_bits_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_retx_drop_bits_handle);
		FOUT
		}
	if (strcmp ("mgmt_retx_drop_pkts_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_retx_drop_pkts_handle);
		FOUT
		}
	if (strcmp ("mgmt_traffic_rcvd_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_traffic_rcvd_handle);
		FOUT
		}
	if (strcmp ("mgmt_traffic_rcvd_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_traffic_rcvd_handle_inbits);
		FOUT
		}
	if (strcmp ("mgmt_traffic_sent_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_traffic_sent_handle);
		FOUT
		}
	if (strcmp ("mgmt_traffic_sent_handle_inbits" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mgmt_traffic_sent_handle_inbits);
		FOUT
		}
	if (strcmp ("missedFrames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->missedFrames);
		FOUT
		}
	if (strcmp ("mpdu_retx_copy_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->mpdu_retx_copy_arr);
		FOUT
		}
	if (strcmp ("my_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_address);
		FOUT
		}
	if (strcmp ("my_bss_info_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_bss_info_ptr);
		FOUT
		}
	if (strcmp ("my_droppedB_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_droppedB_stat);
		FOUT
		}
	if (strcmp ("my_droppedB_sum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_droppedB_sum);
		FOUT
		}
	if (strcmp ("my_droppedR_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_droppedR_stat);
		FOUT
		}
	if (strcmp ("my_droppedR_sum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_droppedR_sum);
		FOUT
		}
	if (strcmp ("my_load_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_load_stat);
		FOUT
		}
	if (strcmp ("my_load_sum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_load_sum);
		FOUT
		}
	if (strcmp ("my_node_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_objid);
		FOUT
		}
	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("my_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_sent_stat);
		FOUT
		}
	if (strcmp ("my_sent_sum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_sent_sum);
		FOUT
		}
	if (strcmp ("my_subnet_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_subnet_objid);
		FOUT
		}
	if (strcmp ("myDataRates" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->myDataRates);
		FOUT
		}
	if (strcmp ("MyExcecutionTrace" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->MyExcecutionTrace);
		FOUT
		}
	if (strcmp ("MyExcecutionTracename" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->MyExcecutionTracename);
		FOUT
		}
	if (strcmp ("nav_duration" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nav_duration);
		FOUT
		}
	if (strcmp ("nav_end_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nav_end_evh);
		FOUT
		}
	if (strcmp ("nav_reset_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nav_reset_evh);
		FOUT
		}
	if (strcmp ("new_variable" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->new_variable);
		FOUT
		}
	if (strcmp ("num_fragments_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->num_fragments_arr);
		FOUT
		}
	if (strcmp ("number_of_stations" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->number_of_stations);
		FOUT
		}
	if (strcmp ("number_of_TXOP_in_calculation_period" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->number_of_TXOP_in_calculation_period);
		FOUT
		}
	if (strcmp ("numberOfInputDataRates" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->numberOfInputDataRates);
		FOUT
		}
	if (strcmp ("oms_aa_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->oms_aa_handle);
		FOUT
		}
	if (strcmp ("operational_speed" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->operational_speed);
		FOUT
		}
	if (strcmp ("Os" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Os);
		FOUT
		}
	if (strcmp ("outstrm_to_mac_if" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->outstrm_to_mac_if);
		FOUT
		}
	if (strcmp ("own_ac_edca_params_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_ac_edca_params_objid);
		FOUT
		}
	if (strcmp ("own_process_record_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_process_record_handle);
		FOUT
		}
	if (strcmp ("packet_data_percent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->packet_data_percent_stat);
		FOUT
		}
	if (strcmp ("packet_load_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->packet_load_handle);
		FOUT
		}
	if (strcmp ("packet_size_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->packet_size_stat);
		FOUT
		}
	if (strcmp ("packetCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->packetCounter);
		FOUT
		}
	if (strcmp ("peer_info_hash_tbl" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peer_info_hash_tbl);
		FOUT
		}
	if (strcmp ("peerAddress" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerAddress);
		FOUT
		}
	if (strcmp ("peerStreamAccuracy" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamAccuracy);
		FOUT
		}
	if (strcmp ("peerStreamAccuracy2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamAccuracy2);
		FOUT
		}
	if (strcmp ("peerStreamAccuracyError" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamAccuracyError);
		FOUT
		}
	if (strcmp ("peerStreamAccuracyError2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamAccuracyError2);
		FOUT
		}
	if (strcmp ("peerStreamData" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamData);
		FOUT
		}
	if (strcmp ("peerStreamData2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamData2);
		FOUT
		}
	if (strcmp ("peerStreamDataForRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDataForRate);
		FOUT
		}
	if (strcmp ("peerStreamDataForRate2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDataForRate2);
		FOUT
		}
	if (strcmp ("peerStreamDataRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDataRate);
		FOUT
		}
	if (strcmp ("peerStreamDataRate2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDataRate2);
		FOUT
		}
	if (strcmp ("peerStreamDistortion" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDistortion);
		FOUT
		}
	if (strcmp ("peerStreamDistortion2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->peerStreamDistortion2);
		FOUT
		}
	if (strcmp ("phy_char_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->phy_char_flag);
		FOUT
		}
	if (strcmp ("phy_cw_max" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->phy_cw_max);
		FOUT
		}
	if (strcmp ("phy_cw_min" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->phy_cw_min);
		FOUT
		}
	if (strcmp ("phy_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->phy_type);
		FOUT
		}
	if (strcmp ("physicalRate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->physicalRate);
		FOUT
		}
	if (strcmp ("physicalRate_readfromtransmiter_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->physicalRate_readfromtransmiter_stat);
		FOUT
		}
	if (strcmp ("physicalRate_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->physicalRate_stat);
		FOUT
		}
	if (strcmp ("pkt_seq_cntl_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->pkt_seq_cntl_arr);
		FOUT
		}
	if (strcmp ("plcp_overhead_control" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->plcp_overhead_control);
		FOUT
		}
	if (strcmp ("plcp_overhead_data" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->plcp_overhead_data);
		FOUT
		}
	if (strcmp ("pruning_percent" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pruning_percent);
		FOUT
		}
	if (strcmp ("rcv_idle_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rcv_idle_time);
		FOUT
		}
	if (strcmp ("rcvd_bar_tid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rcvd_bar_tid);
		FOUT
		}
	if (strcmp ("rcvd_frame_drate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rcvd_frame_drate);
		FOUT
		}
	if (strcmp ("receive_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->receive_time);
		FOUT
		}
	if (strcmp ("received_beacon_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_beacon_count);
		FOUT
		}
	if (strcmp ("received_beacon_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_beacon_count_stat);
		FOUT
		}
	if (strcmp ("received_RTS_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_RTS_count);
		FOUT
		}
	if (strcmp ("received_RTS_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_RTS_count_stat);
		FOUT
		}
	if (strcmp ("received_stateReport_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_stateReport_count);
		FOUT
		}
	if (strcmp ("received_stateReport_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->received_stateReport_count_stat);
		FOUT
		}
	if (strcmp ("receivedPacketTrace" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->receivedPacketTrace);
		FOUT
		}
	if (strcmp ("rem_beacon_tx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rem_beacon_tx);
		FOUT
		}
	if (strcmp ("remainder_size_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->remainder_size_arr);
		FOUT
		}
	if (strcmp ("response_sta_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->response_sta_addr);
		FOUT
		}
	if (strcmp ("retrans_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retrans_handle);
		FOUT
		}
	if (strcmp ("retx_drop_bits_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retx_drop_bits_handle);
		FOUT
		}
	if (strcmp ("retx_drop_pkts_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retx_drop_pkts_handle);
		FOUT
		}
	if (strcmp ("roam_state_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->roam_state_ptr);
		FOUT
		}
	if (strcmp ("rts_threshold" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rts_threshold);
		FOUT
		}
	if (strcmp ("rx_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rx_objid);
		FOUT
		}
	if (strcmp ("rx_power_threshold" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rx_power_threshold);
		FOUT
		}
	if (strcmp ("rx_state_info_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rx_state_info_ptr);
		FOUT
		}
	if (strcmp ("rxch_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rxch_objid);
		FOUT
		}
	if (strcmp ("sent_beacon_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sent_beacon_count);
		FOUT
		}
	if (strcmp ("sent_beacon_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sent_beacon_count_stat);
		FOUT
		}
	if (strcmp ("sent_stateReport_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sent_stateReport_count);
		FOUT
		}
	if (strcmp ("sent_stateReport_count_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sent_stateReport_count_stat);
		FOUT
		}
	if (strcmp ("sentPacketTrace" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sentPacketTrace);
		FOUT
		}
	if (strcmp ("served_pk_id_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->served_pk_id_arr);
		FOUT
		}
	if (strcmp ("short_retry_limit" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->short_retry_limit);
		FOUT
		}
	if (strcmp ("sifs_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sifs_time);
		FOUT
		}
	if (strcmp ("sizes" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sizes);
		FOUT
		}
	if (strcmp ("slot_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->slot_time);
		FOUT
		}
	if (strcmp ("src_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->src_arr);
		FOUT
		}
	if (strcmp ("start_times" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->start_times);
		FOUT
		}
	if (strcmp ("stateReport_int" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stateReport_int);
		FOUT
		}
	if (strcmp ("stateReport_tx_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stateReport_tx_time);
		FOUT
		}
	if (strcmp ("stateReportStarted" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stateReportStarted);
		FOUT
		}
	if (strcmp ("sumD_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sumD_stat);
		FOUT
		}
	if (strcmp ("tc_config_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->tc_config_arr);
		FOUT
		}
	if (strcmp ("temp_ph_rate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->temp_ph_rate);
		FOUT
		}
	if (strcmp ("tempAccuracy" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tempAccuracy);
		FOUT
		}
	if (strcmp ("tempFrameSize" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tempFrameSize);
		FOUT
		}
	if (strcmp ("throughput_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->throughput_handle);
		FOUT
		}
	if (strcmp ("total_ba_reorder_buf_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_ba_reorder_buf_size);
		FOUT
		}
	if (strcmp ("total_bits_sent_in_the_last_TXOP" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_bits_sent_in_the_last_TXOP);
		FOUT
		}
	if (strcmp ("total_data_header_size_sent" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_data_header_size_sent);
		FOUT
		}
	if (strcmp ("total_data_sent" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_data_sent);
		FOUT
		}
	if (strcmp ("total_data_size_sent_without_headers" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_data_size_sent_without_headers);
		FOUT
		}
	if (strcmp ("total_hlpk_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_hlpk_num);
		FOUT
		}
	if (strcmp ("total_hlpk_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_hlpk_size);
		FOUT
		}
	if (strcmp ("total_reorder_size_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->total_reorder_size_handle);
		FOUT
		}
	if (strcmp ("totalDataResetedFalg" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->totalDataResetedFalg);
		FOUT
		}
	if (strcmp ("totalDataResetedFalgArray" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->totalDataResetedFalgArray);
		FOUT
		}
	if (strcmp ("totalFrames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->totalFrames);
		FOUT
		}
	if (strcmp ("totalPeerStreamData" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->totalPeerStreamData);
		FOUT
		}
	if (strcmp ("totalPeerStreamData2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->totalPeerStreamData2);
		FOUT
		}
	if (strcmp ("trimmedAccuracyCounter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->trimmedAccuracyCounter);
		FOUT
		}
	if (strcmp ("trimmedAccuracyCounter2" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->trimmedAccuracyCounter2);
		FOUT
		}
	if (strcmp ("tx_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tx_objid);
		FOUT
		}
	if (strcmp ("txch_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->txch_objid);
		FOUT
		}
	if (strcmp ("txframe_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->txframe_type);
		FOUT
		}
	if (strcmp ("TXOP_counter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TXOP_counter);
		FOUT
		}
	if (strcmp ("TXOP_displasement_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TXOP_displasement_stat);
		FOUT
		}
	if (strcmp ("TXOP_displasement_total" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TXOP_displasement_total);
		FOUT
		}
	if (strcmp ("txop_limit_arr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->txop_limit_arr);
		FOUT
		}
	if (strcmp ("txop_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->txop_start_time);
		FOUT
		}
	if (strcmp ("video_TXOP_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->video_TXOP_stat);
		FOUT
		}
	if (strcmp ("weighted_accuracy_sum" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->weighted_accuracy_sum);
		FOUT
		}
	if (strcmp ("wlan_ac_flags" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wlan_ac_flags);
		FOUT
		}
	if (strcmp ("wlan_flags" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wlan_flags);
		FOUT
		}
	if (strcmp ("wlan_trace_active" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wlan_trace_active);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

